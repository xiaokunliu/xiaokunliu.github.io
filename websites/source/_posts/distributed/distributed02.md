---
title: 分布式架构设计概要总结(下)
category: 分布式架构设计
date: 2020-05-14 11:02:47
tags: 分布式架构设计
---

<!-- more -->

### 分布式架构概要总结

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch00.jpg)

#### 构建分布式的原因

> 业务架构的演进

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch01.jpg)

在上图简单以时间线为准，粗略描述了我们系统架构随着业务的需求考量以及业务的发展，系统承担的并发量也将逐步提升，这就要求我们的系统架构需要开始思考如何利用现有的资源来解决
我们目前急需处理并发请求的服务.而思考的方向可以从我们已有的计算机知识体系中找到答案。比如：

- 对于并发问题，我们知道处理共享资源可以通过加锁的方式来保证我们的线程安全，那么在有限的资源下又要如何提升我们的并发量，于是我们很容易想到hashmap是如何处理线程安全的，对此我们就会考虑到一个设计思想，那就是分而治之的策略，即是否可以将共享资源拆分成多份来缓解我们的压力,即集群.
- 这个时候我们的流量压力通过集群分担到各个应用中,但是此时对数据库的压力反而增加了,于是我们会想到使用缓存策略来缓解我们的压力,对于缓存架构,我们是否也可以采用CPU高速缓存的策略来对我们现有的服务进行改进呢.
- 另外,随着业务的增长以及需求不断地调整变化,有时候为了提升我们的查询性能,还需要以不同的维度重新构建数据库表结构,比如订单服务,可以以用户维护进行数据异构产生用户与订单服务的数据库表结构来提升我们的查询性能.其实对于这种数据异构在编程设计中也是有体现的,比如表单的业务bean与数据库存储的业务bean多少存在一些冗余但可能是类型或者是状态显示不同.目的当然是简化便于理解.
- 随着业务不断扩大,团队人员也在增加,考虑到快速交付产品需求,我们可以划分团队负责不同的业务线,于是便有了服务的垂直拆分,也就是我们的服务化架构,在分布式架构设计中引入服务化架构是我们根据团队以及业务进行拆分的结果,目的是为了更快速交付,同时也是为了更为专注业务开发的落地实现.

引入性能技术的优化方案之后,这个时候我们从另外一个视角来看,即一个置身于互联网大环境下的项目系统,我们需要保证分布式系统服务的高可用.对此,一个分布式系统服务需要具备以下两个因素.

> 构建分布式系统的两个核心因素

- 增大系统容量: 我们的业务量越来越大,而要能应对越来越大的业务量,采取分而治之的设计思想,通过进行水平或是垂直拆分业务系统,让其变成一个分布式的架构.
- 保证系统服务的高可用: 为了增大系统容量,我们将业务进行拆分,彼此独立,但是每一块业务线都有其重要意义,因此我们就需要保证每一块业务线的服务不能存在单点故障.这样,整个系统不会因为单点服务出故障而导致业务服务系统不可用.所以,需要通过分布式架构来冗余系统以消除单点故障,从而提高系统的可用性. 

> 小结

我们使用分布式的设计来源于"分而治之"的思想,从整个系统架构上看,构建分布式架构的原因就是要扛住互联网海量并发请求处理以及在此基础上保证我们的系统服务具备高可用,抑或是允许一小部分服务不可用.

#### 分布式术语

- **节点**: 可以是操作系统上的一个进程服务,也可以是分布式系统中一组提供处理逻辑的程序并能够独立部署运作,在整个分布式系统中与其他服务协作也可以独立完成业务的请求处理操作.
- **集群**: 在分布式系统中,为了提升服务的并发处理能力,部署多个节点来提供相同的一组业务服务操作,这多个提供服务的节点组成一个集群.
- **副本**:在分布式系统中提供数据抑或是服务的冗余来保证系统的高可用,数据副本是指在不同的节点上持久化存储一份相同的数据,服务副本是指在不同的节点上部署一套或一组提供相同业务处理逻辑的服务,一般形成主从来保证服务节点的高可用.
- **中间件**:独立于应用服务,位于操作系统之上的一套为集群节点服务解决问题的通用方案的组件,简化开发人员的工作,让开发者更专注于业务上的开发.比如服务与服务之间通过消息中间件实现异步通信,实现服务解耦;为了加速数据访问速度,我们引入缓存中间件,为应用层与存储层提供一个缓存的过程,避免所有相同的数据查询操作的流量都落地到数据存储层;同时我们还看到接入层节点抑或是网关服务节点要实现高可用保证,需要引入负载均衡中间件实现高可用;再或者应用层与实现分片的数据存储层进行数据交互,为简化开发以及查询匹配等因素引入数据库中间件,从而对于应用层仍然可以透明地实现对数据存储的CRUD等操作,而无须关系数据匹配以及一致性等问题.
- **SOA与微服务架构**:SOA为面向服务的架构,是属于一种设计方法,每个服务之间都相互独立且通过网络进行服务调用来完成一次复杂的业务请求操作;微服务架构是在SOA的基础上演进而来,强调组件化与服务化,每个组件提供独立的服务可以实现可伸缩性的扩展.可以独立开发,设计,部署与优化而不影响微服务中其他的组件.
- **分布式协调**:其一分布式的多个服务节点之间的业务处理逻辑仍然需要保证与单体架构执行的业务逻辑处理顺序一致,即保证服务节点处理业务请的逻辑具备有序性;其二是对于共享资源的争用,在单体架构中我们通过加锁的方式来保证并发处理共享资源的安全性,同理对于分布式的多服务节点对共享资源进行事务操作的时候我们也需要协调各个服务节点的并发控制,保证系统服务中的共享资源的事务操作具备原子性以及数据一致性.因此,**对于分布式协调我们可以理解一个是协调服务节点来保证业务处理的有序性,一个是协调服务节点来保证并发操作共享资源的原子性以及数据的一致性.**
- **服务治理**:对于服务治理的理解,我们需要切换一个维度,此时应该从分布式服务化的架构设计上来看待问题,那么服务与服务之间的通信流程如下:服务启动并注册到注册中心 - 调用方从注册中心获取被调用方的服务列表 - 调用方通过负责均衡的方式选择服务 - 调用选择的服务,此时通过网络传输的方式传递消息 - 被调用方接收到消息并执行调用返回,这里涉及到业务拆分成独立服务,服务注册,服务发现,服务依赖以及服务调用链等关系,服务治理就是需要将服务之间的依赖与调用链全部梳理出来统一存储和管理,这样子我们就能够针对各个服务进行分析与优化等操作.
- **DevOps&自动化运维**:利用CI/CD等持续集成工具来完成一系列业务服务的发布流程,即代码review后提交 - 测试-单元测试-打包-集成测试-UI测试-测试环境发布部署服务-预生产灰度发布服务-真是发布部署服务等一系列流程可以称为DevOps全流程,这对于我们做服务化架构能够实现快速迭代开发;有了DevOps之后,我们就可以针对我们的业务服务进行自动伸缩,故障转移,配置管理,状态管理等一系列自动化运维工作.

#### 分布式技术

> 架构的高性能

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch03.jpg)

这里引入网名左耳朵耗子讲解分布式高性能相关的技术,我觉得已经很好地诠释了分布式高性能技术栈,对于高性能方面,自己也基于上述的基础上做一补充:

- **集群与负载均衡**: 通过水平扩展业务处理能力来提升系统的并发处理能力.
- **缓存设计**: 在我们的上述服务进行水平抑或是垂直扩展的时候,这个时候我们的业务吞吐量也会增加,这个时候会把所有的流量压力打到数据存储系统上,为了缓解数据存储系统的压力,这个时候我们会考虑将数据进行冷热划分,对于热点数据集中在缓存系统服务以降低我们的数据存储压力.对于缓存的设计存在以下三种模式:其一是Cache Aside更新模式,即失效 - 命中 - 更新策略;其二是Read/Write Through更新模式,即缓存更新对应用程序透明,对于应用程序而言只有一个数据存储操作,由cache负载更新数据操作;其三是Write Back模型,类似于Linux下的Page Cache算法,应用程序直接将数据更新到cache中,有cache异步批量更新到数据库中.
- **垂直拆分业务(服务化设计)**: 当我们的一个服务节点承担复杂繁多的业务服务的时候,必然会影响到我们业务处理的能力,为了提升我们的并发处理能力,为了提升我们的系统并发能力,可以考虑将我们的业务进行垂直拆分,于是就有了一个请求的处理需要多个服务之间进行协作完成.
- **数据镜像与分区(读写分离/分库分表)**: 尽管使用缓存可以缓解我们的服务压力,但是仍然无法从根源上缓解流量对数据存储的压力,于是我们一方面会做读写分离,做主从集群,主节点负责处理事务的数据写入,从节点数据负责数据的读取;另一方面为了提升单库单表的并发能力,这个时候我们也是借助分而治之的设计思想,采取分库分表的思路来缓解我们单库单表的流量压力.
- **借助MQ中间件实现异步处理**: 可以通过中间件技术实现异步处理,对流量进行削峰缓冲,进一步提高了程序的并发处理能力以及系统的稳定性.

- **数据异构设计**: 将同一个业务数据按照业务需求的用途划分为不同的数据仓库存储以适用相应的业务需求场景,比如对于爬虫的聚合资讯数据来源存在很多不确定的因素,我们可以通过MQ的方式接收数据变更并将数据持久化存储到ES存储的引擎中,抑或是查询一个用户的订单信息,如果按照订单表的订单ID进行拆分,则需要聚合多张表才能返回相应的聚合数据,这个时候可以采取按照用户维度来进行异构一个与用户相关的订单数据仓库的策略(存在数据冗余,但是提升读取性能).

> 高可用设计

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch04.jpg)

同样地,这里也是引入网名左耳朵耗子讲解分布式高可用相关的技术,在此基础自己也做以下的一些补充:

- **服务冗余与负载均衡技术**: 从集群角度上思考,我们需要考虑集群是流量如何分担到集群服务的节点,集群服务节点出现异常或者不可用的时候流量如何切换,这个时候我们就需要考虑到负载均衡技术来帮助我们实现流量分发的调度,对服务节点采取心跳检测以及当服务节点异常采取重试与流量切换重新调度分配可用服务节点来避免单点故障问题,简而言之服务的高可用可以是服务冗余与负载均衡技术来避免单点故障,实现故障自动的恢复.
- **隔离技术**: 为了防止故障蔓延到其他服务节点,我们通常会采取隔离技术来隔离拆分的业务服务,每个业务服务分别各自独立部署,在分布式系统设计中,一般会服务的种类或者是用户来进行隔离.
- **降级与限流技术**:当系统承担的并发流量服务压力十分庞大的时候,这个时候我们需要采取保护措施,通过降级或者限流的技术来停用部分业务服务或者是拒绝部分用户的请求操作以确保整个系统不会被流量冲垮导致整体不可用. 
- **超时重试与熔断**: 在服务化架构设计中,为了防止服务产生雪崩,需要在调用服务加入超时重试以及熔断机制,避免将错误蔓延到其他服务导致整个系统服务不可用.从而缩小部分服务.
- **高可用架构设计**: 利用服务冗余来避免单点故障,比如多租户隔离,灾备多活抑或是数据副本保证一致性,高可用不仅是的服务集群的高可用,还有就是中间件实现高可用设计.
- **高可用的运维**:实现devops的CI或者CD的持续集成计划任务,能够构建执行自动化测试,实现灰度发布部署以及线上系统的自动化控制.
- **缓存的高可用**:对于缓存系统也需要采用集群高可用的方式来避免单点故障以及实现故障恢复,同时对于缓存系统要实现高可用,需要注意以下几个问题:
  **1) 一个是缓存穿透**,即对于不存在的数据缓存始终都是没有命中会直接将流量打到数据存储层上.
  **2) 一个是缓存雪崩**,即在某一个时刻,所有的缓存都失效过期,这个时候流量都会打到数据存储层,很容易引起数据存储层的并发性能问题
  **3) 最后一个是缓存击穿**,即针对某一个热点缓存在某一个时间点存在并发访问量请求并且当前时间点缓存时间已经过期需要刷新缓存,这样也会将流量打到数据存层上.
  因此对于缓存的高可用不仅需要避免单点故障,同时还需要具备容错能力,比如增加布隆过滤器来控制缓存穿透,根据不同的业务场景可以采取随机时间段的缓存时间来避免同一个时间点缓存失效以及对于具备热点的共享资源缓存操作,需要借助中间件的协调者来管理和控制我们的应用服务的操作避免缓存击穿的产生.
- **切流量**: 面临高并发流量的接入时,我们并无法保证所有服务节点都是可用状态,于是需要在接入层或者服务网关做故障转移,将流量切换到可用的服务节点上.
- **可回滚**:在分布式的服务化架构设计,我们需要对服务实施版本控制与管理,一旦新发布的服务节点产生测试不可预知的测试,为了减少服务不可用时长抑或是服务的覆盖面,我们需要对服务进行回滚到上一个稳定版本以保证线上服务可用.

> 业务设计

- **防重与幂等设计**: 当我们应用在单位时间内接收到相同并发的事务请求操作时,这个时候我们需要考虑事务请求操作处理不论多少次请求最终只能处理一次,这个时候可以通过设计防重key或者是防重表来保证我们只处理一次请求,比如下单支付操作,由于支付渠道是无法避免重复支付的,因此对于我们系统服务而言就需要通过防重key为orderId+订单状态+以及支付渠道返回的支付payId来保证订单服务抑或是将支付记录在数据表并通过数据表进行查询验证,如果并发量很大的话,我们就需要通过MQ来接收支付渠道回调的响应结果并通过鉴权验证之后提交到MQ,再由MQ分发给消费者,这个时候就需要保证幂等,防止重复消息的消费.
- **事务补偿机制**:在分布式架构设计中,基于ACID以及BASE理论,事务补偿操作是保证一系列的业务操作具备原子性,当其中某一个操作出现异常的时候,我们采取重试让其运行得到我们期望的事件状态,如果重试不成功,则采取人工干预抑或是丢弃回滚事件.比如一个支付场景,用户下单之后并没有立即支付,此时商品扣减库存如果在等待15min之后没有收到用户支付的请求,就需要将商品库存释放,此时就需要对此场景进行事务补偿,保证我们的业务最终一致性;再比如一个主播提现系统,一般会有N+1或者N+7的支付平台,那么我们进行主播打款的时候有可能由于第三方支付平台网络不稳定导致支付成功但是没有返回响应,此时我们也需要进行事务补偿,针对不稳定的网络因素进行重试与验证处理,保证数据金额的追踪一致性.
- **状态机设计**:状态机系统包含条件,事件以及事件触发的状态变更操作,严格按照一定的状态变更规则通过外部事件触发以及条件的判断执行状态变更,比如设计一个订单状态的状态机,我们需要考虑订单状态的变化以及对应触发状态变更的事件,比如下单-订单被创建,支付-支付成功与失败,接单-已接单状态还是拒单状态,订单签收-订单完成以及后续的退单操作对应的订单退款状态等一系列事件触发的订单状态变更形成一个状态机.
- **后台系统可反馈**:可以针对一些核心业务功能采取行为记录的日志异步化持久化到数据层上,并通过后台管理系统查看反馈以及重要核心业务流程的追踪分析.

> 分布式服务指标监控

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch05.jpg)

在分布式架构中,最需要做到的就是能清楚每个服务节点运作的细节,此时就需要对整个分布式系统进行全栈监控,即不论是应用服务层(业务服务化),抑或是平台组件服务还是底层机器的资源监控,我们都需要做到心中有数,才能够针对某一个服务进行排查与优化.

- 基础层:主要监控底层以及资源情况,如CPU/内存/网络/磁盘IO/带宽流量等
- 组件层:主要监控我们引入的中间件,比如Redis/MQ等,都需要对组件的容量/io/内存/线程/服务节点健康状态等指标进行监控
- 应用层:一般是我们的业务服务上的监控,这个时候我们更关注服务依赖,服务调用链,日志收集,qps/tps等因素.

#### 分布式技术栈产生的问题

- 服务节点如何崩溃恢复
- 数据一致性与分布式事务
- 共享资源与分布式锁

在分布式架构设计中,为了解决上述带来的问题,我们需要借助分布式技术已有的基础理论知识来指导并促进我们问题的解决,其中分布式依赖的基础理论知识主要有以下两方面:

> 分布式理论基础

- 拜占庭将军解决共识问题
- CAP&BASE理论
- ACID&2PC&3PC

> 分布式协议与算法

- Paxos算法
- Raft算法
- 一致性hash算法
- gossip协议
- Quorum NWP算法
- PBFT算法
- zookeeper的ZAB协议

#### 分布式小结

> 两个目标

- 提高系统的性能
- 保证系统服务的高可用

> 设计角度

- 性能设计
- 弹力设计(高可用技术)
- 业务设计
- 全栈系统监控

> 宏观上看分布式架构

- 全栈系统监控: 单机的基础监控 -  中间件服务监控  - 应用服务监控
- 服务/资源调度: 计算机资源调度  - 服务资源调度 - 架构调度
- 流量调度: 流量控制 - 流量管理 - 服务治理
- 状态/数据调度: 数据可用性 - 数据一致性 - 数据分片
- DevOps与自动化运维: 基于上述的基础完成一系列的开发 - 版本提交 - 单元测试 - 打包 - 集成测试 - UI测试 - 发布测试环境 - 预生产环境发布 - 灰度发布 - 正式发布.

![](https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch06.jpg)