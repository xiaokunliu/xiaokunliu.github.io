
<!DOCTYPE html>
<html lang="zh-CN">
<!--
config header
-->



<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

  
      <meta name="google-site-verification" content="{{ theme.google_site_verification }}" />
  

  
    <meta name="keywords" content="网络IO编程," />
  

  
    <meta name="description" content="分享个人学习工作的技术知识" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.jpg">
  <title>category: 网络IO编程 [ 疾风先生 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://xiaokunliu.github.io/images/logo.jpg">
    <span class="title">疾风先生</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        深入分析Netty核心特性
      </h1>
      <span>
        
        <time class="time" datetime="2020-05-01T17:47:36.000Z">
        2020-05-01
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9CIO%E7%BC%96%E7%A8%8B/" rel="tag">网络IO编程</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
    </header>

    <div class="post-content">
      <span id="more"></span>

<h3 id="深入分析Netty高性能特性"><a href="#深入分析Netty高性能特性" class="headerlink" title="深入分析Netty高性能特性"></a>深入分析Netty高性能特性</h3><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_title.jpg"></p>
<p>在讲述Netty的高性能特性之前,基于之前的epoll技术分析中谈到C10K问题与高性能IO设计文章的认知,对于C10K问题其实是属于一个优化问题,目的是为了能够在单台机器上支撑更多的并发连接调度所做的性能优化,为了达到上述目标,需要要求我们设计的web服务采用合理的IO模型,并在对应的IO模型基础上引入多线程与并发库技术的使用来支撑更多的连接调度,同时考虑到计算机资源的限制,我们需要在设计web服务的时候合理对资源进行分配优化,比如内存,网络带宽以及CPU核数的充分利用,也就是说我们还需要考虑到可伸缩性的问题,通过增加资源来使得我们的web服务能够得到线性提升效果.接下来我们就来结合源码分析Netty技术是如何体现高性能这一个特性.</p>
<h4 id="C10K与C10M问题"><a href="#C10K与C10M问题" class="headerlink" title="C10K与C10M问题"></a>C10K与C10M问题</h4><h5 id="C10K-amp-C10M解决方案"><a href="#C10K-amp-C10M解决方案" class="headerlink" title="C10K&amp;C10M解决方案"></a>C10K&amp;C10M解决方案</h5><blockquote>
<p>C10K问题</p>
</blockquote>
<p>关于C10K的问题,在先前的epoll技术分析文章已经有讲述过,C10K是属于一个优化问题,即要让单个web服务支撑1w的并发连接,关于C10K的性能与可伸缩性问题,摘录C100M的博文并加入自己的理解:</p>
<ul>
<li>采用线程连接架构TBA模型,也就是1个客户端连接对应1个线程,那么对于内核而言,假设这个时候需要10k个连接,那么也就意味着要10k个线程,此时内核需要从这个10k个线程中轮询遍历哪个线程是有数据流量进来的,对于服务器本身而言,不论线程数量多少,线程上下文切换的时间是恒定的,即使再多的连接分配给再多的线程,其性能也不会上去,线程调度仍然无法扩展,除了本身线程资源的瓶颈之外,我们可以看到的一个现场就是线程调度无法扩展.</li>
<li>相对地,采用选择/轮询来处理连接事件,也就是面向事件驱动设计EDA模式,我们在分析select/poll/epoll技术中讲到,它们都是对一个socket集合fds进行监听,每个数据包都会经过socket套接字,即使套接字增加,我们同样可以通过选择和轮询的方式来遍历socket数据流量进来的事件,这个时候单线程是可以完成一个选择和轮询就绪事件的操作,同时还可以实现连接的扩展性,随着IO技术的发展,现代服务器都会引入可扩展的epoll技术与异步IO Compeletion Port在指定时间内查询就绪的socket集合并返回给应用程序.</li>
</ul>
<p>因此,优化一个C10K的问题可以从以下几个方面考虑:</p>
<ul>
<li>选用的IO模型能够支持web实现可伸缩性</li>
<li>结合IO模型设计的线程模型,能够通过增加适当的线程数量来支撑web服务更多的并发连接</li>
<li>最后一个可以理解为性能问题,一个Web服务的性能可以参考以下几个因素: <strong>数据复制拷贝问题/线程上下文切换问题/内存分配问题以及锁争用(无锁编程是一个我们理想的选择)</strong></li>
</ul>
<blockquote>
<p>C10M问题</p>
</blockquote>
<p>同理地,C10K问题的解决,随着互联网技术发展,又提出了一个C10M的优化问题,即如何让我们的单台机器支撑1000w的并发连接,这个时候Errata Security首席执行官Robert Graham从历史的角度出发讲述Unix最开始设计不是通用的服务器OS,而是作为电话网络的控制系统,实际上是电话网络在控制数据传输,因而控制平面与数据平面存在清晰的分隔,于是指出一个问题,即当前我们使用的Unix服务器是作为数据平面的一部分,这也是他所说的内核不是解决方案,而是问题所在,什么意思呢?<strong>不要让内核承担所有繁重的工作</strong>.将数据包处理,内存管理和处理器调度从内核中移出,并将其放入应用程序中,可以在其中高效地完成它.让Linux处理控制平面,让应用程序处理数据平面.对此,一个C10M关注的问题有以下几个方面:</p>
<ul>
<li>1000w个并发连接</li>
<li>支撑一个持续时间约为10s的100w并发连接</li>
<li>1000万个数据包/秒-期望当前的服务器每秒处理5万个数据包，这将达到更高的水平。过去服务器每秒能够处理100K次中断，每个数据包都会引起中断。</li>
<li>10微秒延迟-可伸缩服务器可能会处理规模，但延迟会增加。</li>
<li>10微秒抖动-限制最大延迟</li>
<li>10个连贯的CPU内核-软件应扩展到更大数量的内核。通常，软件只能轻松扩展到四个内核。服务器可以扩展到更多的内核，因此需要重写软件以支持更大的内核计算机</li>
</ul>
<p>基于上述的叙述,为了构建一个能够支撑1000w/s的并发连接系统,我们需要让数据平面系统能够处理1000w/s个数据包,而对于一个控制平面系统而言,持续10s的最多也就只能处理100w个并发连接,为了实现这个目标,我们借鉴C10K问题的解决方案,C10K问题主要是从构建一个可伸缩性的IO模型的web服务来达到支撑10K并发连接的目的,同时也引入线程模型与性能优化手段来配合实现达到目的,从这里我们也可以看到可伸缩性是我们设计的目标,同时为了支撑1000w的连接,我们不能将性能优化外包给操作系统,那么我们要编写一个可伸缩性的软件来达到上述的目标就需要解决以下的问题:</p>
<ul>
<li>数据包可扩展: 编写一个自定义驱动程序以绕过TCP堆栈,直接将数据包发送到应用程序.如PF_RING，Netmap，Intel DPDK</li>
<li>多核可扩展: 多核编码并不是多线程编码,而是让我们的应用程序分布在每个CPU核心上,保证我们能够随着内核的增加以线性扩展我们应用程序的处理能力.即一个是保持每个cpu核数的数据结构,一个是每个cpu保证原子性操作,一个是使用无锁技术的数据结构,一个是使用线程模型完成流水工作,最后一个是利用处理器的亲和力,即保持运行在每个cpu核数上分配的线程是固定的,即每个cpu对应着专有的线程来完成工作.</li>
<li>内存可扩展: 一个是使用连续内存分配技术,增加数据的缓存命中率,一个是分页表运用高效的缓存数据结果并对数据压缩,一个是使用池化技术管理内存,一个是合理分配线程以降低内存访问延迟,最后一个是使用预分配的内存技术.</li>
</ul>
<p>因此,我们可以借鉴C10K与C10M的优化思路来推导一个具备高并发,高性能且可伸缩性的web服务设计思路展开,高并发连接调度我们可以从IO模型以及线程模型思考,高性能的指标我们可以从计算机资源分配管理与优化方面思考(比如内存/无锁编程),而一个可伸缩性的web服务我们会从物理资源角度来考虑,通过增加相关的资源配置是否能够得到线性的性能提升.接接下来我们开始分析Netty是如何实现高并发,高性能以及如何体现可伸缩性的.</p>
<h5 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h5><blockquote>
<p>高并发关注指标</p>
</blockquote>
<ul>
<li>响应时间(Response Time):发起一个request请求,执行这个request请求从开始到最后返回响应结果所花费的总体时间,也就是客户端发起请求到最后收到服务端返回响应结果的时间.比如http请求响应时间为200ms,200ms表示RT.</li>
<li>每秒并发连接(并发用户数): 每秒可支撑的连接调度/同时承载正常使用系统功能的用户数量,并发连接/用户数更关注的是能够处理调度连接而不在于处理速度.</li>
<li>QPS/TPS(每秒查询量/每秒事物处理量): 比如现在客户端发起一个下单操作(用户鉴权/订单校验/下单操作三个步骤),这个下单操作形成一个TPS,而下单里的每个步骤形成一个QPS,也就是说TPS包含3个QPS操作,因而对于TPS理解是一个完整的事物请求的操作结果,而QPS是针对一个request请求的操作结果,对此TPS是衡量软件测试结果的度量单位,而QPS是特定的查询服务器在指定的时间段内处理流量度量标准的数量,域名服务器的机器性能通常用QPS来衡量,QPS与TPS更关注处理速度.</li>
<li>吞吐量(Throughput): 取决于我们关注系统的业务指标,比如我们关注的是软件测量结果相关的处理能力(处理速度),那么这个时候的吞吐量我们需要关注的是TPS,如果是关注机器性能的流量,那么我们关注的吞吐量是QPS,如果我们对接的是接入层的服务,那么我们可能需要关注的是并发连接的调度,此时关注的吞吐量是支撑的并发连接调度数据.</li>
</ul>
<blockquote>
<p>并发连接/QPS/TPS</p>
</blockquote>
<p>基于上述的高并发指标的理解,现将并发连接/QPS/TPS的区分通过以下图解的方式展开:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/connections_qps_tps.jpg"></p>
<ul>
<li>并发连接: 主要体现在服务端程序高效的连接调度机制上,也就是说服务端能够在一定的时间段内能够正确地响应给每个连接的请求即可,至于何时响应以及如何响应不是并发连接关注的事情.</li>
<li>QPS/TPS: 主要体现在处理速度上,要求能够正常完成对请求响应的处理,不仅是要对请求结果正确响应,同时还要求处理能力能够尽可能快速.</li>
</ul>
<blockquote>
<p>IO与线程模型实现高并发连接调度</p>
</blockquote>
<ul>
<li>基于先前的高性能IO编程设计并结合上述的C10K与C10M问题,实现一个支撑高并发连接调度的web服务需要借助具备可伸缩性的NIO或者AIO技术完成,通过监听socket的数据流量出入事件来响应给应用程序,并且轮询事件通过单线程的方式也能够处理,还能实现扩展,只要操作系统的fd资源配置足够大即可.</li>
<li>其次,为了支撑更多更快的响应连接调度处理,我们可以适当地加入多线程处理方式来扩展上述单线程处理连接事件的能力.同时也会看到在IO相关设计,基于事件的编程,为了简化应用开发者编写代码的复杂度以及具备更好的扩展性,引入了基于EDA的Reactor与Proactor的模式设计.</li>
</ul>
<h5 id="C10K与C10M提升性能优化因素"><a href="#C10K与C10M提升性能优化因素" class="headerlink" title="C10K与C10M提升性能优化因素"></a>C10K与C10M提升性能优化因素</h5><p>结合之前的高性能IO编程文章以及C10K与C10M问题,我们可以考虑设计一个高性能的Web服务可以从以下几个方面思考:</p>
<blockquote>
<p>数据包的存储</p>
</blockquote>
<ul>
<li>socket接收数据流量的时候我们要考虑如何将数据包直接传输到应用程序,尽量避免数据的拷贝问题.</li>
<li>应用程序接收数据包的时候能不能缓存起来,同时如果加入缓存的话,有没有办法提高命中率.</li>
<li>数据存储的区域能否重复利用,即使用池化技术进行管理分配,减少向计算机申请资源的性能.</li>
</ul>
<blockquote>
<p>应用程序的处理能力</p>
</blockquote>
<p>对于处理处理能力,我们可以用一个词来说明,那就是吞吐量,既然想要提升吞吐量,那么我们的目标其实也是很明确的,即“快”.</p>
<ul>
<li>充分利用CPU资源,避免CPU一直处于空闲假死状态(线程阻塞/空轮询/线程过多)</li>
<li>根据高性能IO设计的一文,我们可以在竞争环境下使用并发库,底层原子操作等手段有助于提升IO的吞吐量</li>
<li>同步环境下能够使用无锁来处理任务</li>
</ul>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>在Netty技术中主要是采用NIO实现多连接的单线程复用机制以及借助多线程异步处理方式来提升支撑并发连接调度的处理能力,在C10M问题中已经指出,为了优化C10M问题,我们应该考虑在应用程序方面去设计数据平面系统来构建一个支撑1000W并发连接的调度处理机制.</p>
<h5 id="可伸缩的IO模型"><a href="#可伸缩的IO模型" class="headerlink" title="可伸缩的IO模型"></a>可伸缩的IO模型</h5><ul>
<li>NIO多路复用技术具备可伸缩性,通过C10K问题的分析,我们知道单线程能够处理更多的socket就绪事件,也就是说单线程面向事件驱动设计的复用技术实现可扩展性且能支撑更多并发连接的请求调度处理,这里与线程连接不同的是我们关注的是事件而不是线程本身,因而不会受限于线程资源以及线程的调度分配问题.</li>
<li>其次Netty框架是基于Reactor模式进行演变,但于Reactor模式不同的是Netty是多线程异步处理,更像是Proactor模式,但异步处理是在应用程序通过回调的方式完成的,而Proactor是基于AIO的方式将异步操作传输到内核并在内核中进行回调返回.</li>
</ul>
<h5 id="Netty之Reactor模式"><a href="#Netty之Reactor模式" class="headerlink" title="Netty之Reactor模式"></a>Netty之Reactor模式</h5><p>关于Netty框架的线程模式架构设计图如下所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_model.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_model2.jpg"></p>
<p>现在我们基于宏观上对Netty的线程模型有一个基本认知之后,结合先前文章对Netty组件源码以及事件流程的分析可知,在Netty中存在EventLoopGroup,通过EventLoopGroup来分配EventLoop,而每一个EventLoop既具备线程池的功能又承担着事件轮询的工作,同时每个EventLoop都分配对应的一个FastThread专有线程来负责对处理当前EventLoop的pipeline的流水工作,由于每一个启动EventLoop都绑定专有的一个线程FastThread,那么对于EventLoop处理的一系列流水工作也将会在当前的线程执行,从而保证了单线程资源无竞争高效串行化流水任务的执行,简单点就是无锁流水工作,这个在我们上述讲到的C10M优化方案中体现的一个多核扩展问题,Netty框架很好地运用这一理念来提升我们web服务支撑高并发连接的调度处理.</p>
<p>关于Netty处理的单线程无锁串行化的流水工作流程示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_safe_pipeline.jpg"></p>
<p>在了解上述的无锁串行化任务执行流程之后,我们还需要关注Netty另一个问题,即在多Reactor模式中,我们看到服务端channel其实只完成一次创建,初始化以及注册,相比客户端channel,提供给客户端的EventLoopGroup由于在客户端有新连接进来的时候就会在Acceptor进行注册,而我们也分析channel的注册流程,注册的时候会在EventLoopGroup根据选举策略分配一个EventLoop来完成channel到EventLoop的绑定,对此,我们知道对于客户端channel而言,EventLoopGroup的作用是类似于我们分布式的“集群”机器服务来对外提供服务的,分担高并发的连接压力,那么对于服务端channel而言呢,提供EventLoopGroup如果指定的线程数量大于1,这个时候EventLoopGroup又起到什么作用呢?其实对于服务端的channel,我们很多时候并不仅仅是处理连接的接收,还要在处理连接之前做一些鉴权校验抑或是风控等安全措施的处理,如果这些过程会比较耗时,那么就需要在我们处理的handler上添加从Group选举一个新的EventLoop事件轮询活动来缓解我们并发连接调度处理能力,其实说到底Group还是类似于分布式系统中的“集群”来缓解并发调度的压力.</p>
<p>于是基于上述的分析,我们对Netty支撑高并发采用的技术手段总结如下:</p>
<ul>
<li>使用NIO模型实现多连接的可伸缩性扩展,同时引入Reactor模式以及责任链设计在原有的基础上使得Netty可伸缩性更为灵活,能够支撑更多的并发连接调度.</li>
<li>其次,Netty设计通过为每个执行的事件轮询EventLoop分配独有的线程,保证了每个事件轮询器之间处理的流水工作相互独立,同时也保证了在当前EventLoop下执行的所有流水工作都是专属于专有的线程,不存在资源竞争以及锁争用的情况,基于此,在多核环境下我们可以充分利用多核技术进一步去提升我们的并发连接调度处理能力.</li>
<li>最后一个就是Netty通过EventLoopGroup的“集群”手段来分担我们web服务的并发连接调度处理能力,有效缓解对单个线程处理并发连接的压力,提升并发连接调度的处理能力.</li>
</ul>
<h4 id="Netty高性能之ByteBuf"><a href="#Netty高性能之ByteBuf" class="headerlink" title="Netty高性能之ByteBuf"></a>Netty高性能之ByteBuf</h4><h5 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h5><p>对于linux操作系统读取数据块一般流程是:先从硬件设备将数据块加载数据到内核缓冲区,然后由内核将内核缓冲区的数据复制到用户空间的缓冲区,最后唤醒应用程序读取用户空间的缓冲区,对于Java程序而言,其无法直接操作OS系统内存区域,必须通过JVM堆申请内存区域来存放数据块,于是需要再从OS内存中的数据缓冲区将数据块复制到JVM堆中才能够进行操作数据,于是对于JVM操作socket的数据包,数据包拷贝的路径如下图示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_direct_bytebuf.jpg"></p>
<p>网卡设备接收到数据包流量事件,内核将数据块加载到内核缓冲区中,并且通过socket传输数据到用户空间的缓冲区,最后JVM要操作socket缓冲区的数据,需要将其读取到JVM堆中存储,这个时候需要再JVM堆中申请一个内存区域用于存放数据包数据,而如果直接通过堆外内存读取数据,则可以减少一次数据的拷贝以及内存资源的损耗,如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_direct_references.jpg"></p>
<p>Netty的堆外内存操作通过底层操作系统Unsfe的方式获取其内存位置来直接操作内存,相比使用堆内存分配更为高性能便利,同时也减少了数据拷贝,直接通过Unsafe指向的堆外内存引用来进行操作.</p>
<h5 id="零拷贝机制"><a href="#零拷贝机制" class="headerlink" title="零拷贝机制"></a>零拷贝机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设buffer1以及buffer2都存储在堆外内存,堆内内存同理(只是在JVM中)</span></span><br><span class="line">ByteBuf httpHeader = buffer1.silice(OFFSET_PAYLOAD, buffer1.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line">ByteBuf httpBody = buffer2.silice(OFFSET_PAYLOAD, buffer2.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line"><span class="comment">// 逻辑上的复制,header与body仍然存储在原有的内存区域中,http为JVM在堆中创建的对象,指向一个逻辑结构上的ByteBuf</span></span><br><span class="line">ByteBuf http = ChannelBuffers.wrappedBuffer(httpHeader, httpBody);</span><br></pre></td></tr></table></figure>

<p>上述的零拷贝机制示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/zero_copy.jpg"></p>
<p>这个时候在应用程序中可以直接通过http的ByteBuf操作合并之后的header+body的ByteBuf缓冲区,http的byteBuf是属于逻辑上的合并,实际上并没有发生数据拷贝,只是在JVM中创建一个http的ByteBuf引用指向并操作合并之后的bytebuf.</p>
<h5 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h5><blockquote>
<p>核心源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        checkPositiveOrZero(minNewCapacity, <span class="string">&quot;minNewCapacity&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,</span><br><span class="line">                    minNewCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> threshold;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">        <span class="comment">//  &gt; 4M</span></span><br><span class="line">        <span class="comment">// cap / 4 * 4 + 4</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">                newCapacity = maxCapacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newCapacity += threshold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">        <span class="comment">// &lt; 4M 进行以2的倍数进行增长</span></span><br><span class="line">        <span class="comment">// 2096，此时分配的内存为3072byte</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上述源码可知:</p>
</blockquote>
<ul>
<li>当写出的数据不足4M的时候,将以64byte为起始值,以2的倍数进行增长扩容</li>
<li>当写出的数据大于4M的时候,将以一个公式<code>newCapacity = capacity/4*4+4</code>进行计算</li>
<li>当写出的数据为4M的时候,直接返回4M预定的默认空间大小</li>
</ul>
<h5 id="引用计数与资源管理"><a href="#引用计数与资源管理" class="headerlink" title="引用计数与资源管理"></a>引用计数与资源管理</h5><p>在ByteBuf添加引用计数能够计算当前对象持有的资源引用活动情况,通常以活动的引用计数为1作为开始,当引用计数大于0的时候,就能够保证对象不会被释放,当引用计数减少到0的时候说明当前对象实例就会被释放,将会被JVM的GC进行回收,对于池化技术而言则是存放到内存池中以便于重复利用.因此使用池化技术的<code>PooledByteBufAllocator</code>而言,使用引用计数能够降低内存分配的开销,有助于优化内存使用和性能的提升.</p>
<ul>
<li>ByteBuf的实现接口ReferenceCounted</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByteBuf.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuf</span> <span class="keyword">implements</span> <span class="title">ReferenceCounted</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteBuf</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> refCnt() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractByteBuf.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title">ByteBuf</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于引用计数为0的实例将无法访问,会抛出异常IllegalReferenceCountException</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkAccessible &amp;&amp; !isAccessible()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReferenceCounted.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReferenceCounted</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用retain(increament) 将会增加引用计数increament</span></span><br><span class="line">   <span class="comment">// 调用release(increament)将会减少引用计数increament</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ChannelHandler的资源管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于入站事件,如果当前消费入站数据并且没有事件进行传播的话,那么就需要手动释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// not call fireChannelRead,事件传播在当前handler终止,这个时候需要手动清除</span></span><br><span class="line">  ReferenceCountUtil.release(msg);</span><br><span class="line">  <span class="comment">// SimpleChannelInboundHandler能够手动清除,但是一般入站事件我个人习惯用ChannelInboundHandlerAdapter并且自己手动管理,方法单一,处理简单,可以手动管理,同理出站事件也是用Adapter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于出站事件,如果当前需要对非法消息采取丢弃操作,则也需要手动进行处理释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWrite</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span>&#123;</span><br><span class="line">  ReferenceCountUtil.release(msg);</span><br><span class="line">  promise.setSuccess(); <span class="comment">// 丢弃消息意味着不会将数据传输到出站事件的责任链上,这个时候FutureListener无法监听到消息处理情况,需要手动通知处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Netty的资源监控类ResourceLeakDetector</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 关于监控类的级别详细查看Netty类下的ResourceLeakDetector</span></span><br><span class="line"><span class="comment">## 通过java配置并执行可以查看资源泄漏情况以及输出报告</span></span><br><span class="line">java -Dio.netty.leakDetection.level=ADVANCED</span><br></pre></td></tr></table></figure>

<h5 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h5><ul>
<li>入口程序</li>
</ul>
<p>首先,Netty处理读写事件默认分配的内存Allocator源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Channel的时候会创建默认的AdaptiveRecvByteBufAllocator,不论是客户端还是服务端channel</span></span><br><span class="line"><span class="comment">// DefaultChannelConfig.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelConfig</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(channel, <span class="keyword">new</span> AdaptiveRecvByteBufAllocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的DefaultChannelConfig类图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/config_class.jpg"></p>
<p>其次,我们关注socket的读写事件,也就是NioSocketChannel的相关事件,在NioEventLoop下的run方法定位到对应的unsafe的read方法,如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioByteChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 根据上述的config可以定位到是默认使用池化的内存分配器,默认为池化分配且为堆外内存分配</span></span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// RecvByteBufAllocator默认为AdaptiveRecvByteBufAllocator</span></span><br><span class="line">  <span class="comment">// allocHandle为AdaptiveRecvByteBufAllocator下的HandleImp,而HandleImp继承MaxMessageHandle</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//我们关注byteBuf的分配,调用上述的handler的allocate方法</span></span><br><span class="line">  byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxMessageHandle.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用池化的分配器创建ioBuffer</span></span><br><span class="line">  <span class="comment">// 根据数据包的大小计算要申请的内存区域大小,每个区域大小都存储在一个table表中进行存储,每次计算都会通过二分查找来搜索适合当前数据包存储的数据</span></span><br><span class="line">  <span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着,我们现在需要关注的是池化分配器的ioBuffer方法,其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractByteBufAllocator.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据上述传递进来的数据包进行创建</span></span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">    <span class="comment">// 默认执行方式</span></span><br><span class="line">    <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledByteBufAllocator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBufAllocator</span> <span class="keyword">extends</span> <span class="title">AbstractByteBufAllocator</span> <span class="keyword">implements</span> <span class="title">ByteBufAllocatorMetricProvider</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 默认使用堆外内存策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PooledByteBufAllocator DEFAULT =</span><br><span class="line">            <span class="keyword">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配bytebuf策略</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用线程缓存技术,类似于jemalloc的可伸缩的内存分配策略</span></span><br><span class="line">        PoolThreadCache cache = threadCache.get();</span><br><span class="line">        PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">        <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                    <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们可以看到,Netty采用的ByteBuf是使用池化且堆外内存分配的方式,如果OS支持Unsafe操作则默认为Unsafe操作,接下来我们来关注分配算法的核心代码</p>
<ul>
<li>内存分配算法的核心代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span></span><br><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">  allocate(cache, buf, reqCapacity);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到上述存在两个部分,一个是创建池化的ByteBuf,一个是从内存中申请资源存储数据</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建池化的ByteBuf源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">    <span class="comment">// 直接创建一个ByteBuf</span></span><br><span class="line">    <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledUnsafeDirectByteBuf.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里面的代码不深挖</span></span><br><span class="line">  <span class="comment">// 核心处理流程: 先从线程缓存获取栈，从栈获取buf，如果不存在则将创建ByteBuf并存储栈中,最后更新栈数据并一并更新到到线程的cache中</span></span><br><span class="line">  PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">  <span class="comment">// 重置buf的引用计数</span></span><br><span class="line">  buf.reuse(maxCapacity);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分配内存算法源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算合适的一个区域</span></span><br><span class="line">  <span class="comment">// 比如现在申请一个资源为19byte,则会为其创建一个2的临近整数方,这个时候会分配一个32byte的数据</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请的容量小于8kb</span></span><br><span class="line">  <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; </span><br><span class="line">    <span class="keyword">int</span> tableIdx;</span><br><span class="line">    PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">    <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">    <span class="comment">// 容量小于512byte</span></span><br><span class="line">    <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">      <span class="comment">// 从缓存中获取</span></span><br><span class="line">      <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tableIdx = tinyIdx(normCapacity);</span><br><span class="line">      table = tinySubpagePools;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分配的容量大于512byte小于8kb</span></span><br><span class="line">      <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tableIdx = smallIdx(normCapacity);</span><br><span class="line">      table = smallSubpagePools;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">      <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">      <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">        <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">        <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">        <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">        s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity);</span><br><span class="line">        incTinySmallAllocation(tiny);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incTinySmallAllocation(tiny);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 容量大于等于8kb小于16M</span></span><br><span class="line">  <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">      ++allocationsNormal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &gt; 16M,直接从操作系统中申请资源并且不做缓存和池化处理,于是不会添加到arena中</span></span><br><span class="line">    <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">    allocateHuge(buf, reqCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>摘录实际分配内存源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">       q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">       q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add a new chunk.</span></span><br><span class="line">   <span class="comment">// pageSize = 8kb</span></span><br><span class="line">   <span class="comment">// maxOrder = 11</span></span><br><span class="line">   <span class="comment">// pageShifts = 18</span></span><br><span class="line">   <span class="comment">// chunkSize = 16M</span></span><br><span class="line">   PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">   <span class="keyword">boolean</span> success = c.allocate(buf, reqCapacity, normCapacity);</span><br><span class="line">   <span class="keyword">assert</span> success;</span><br><span class="line">   qInit.add(c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoolChunk.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个subpage</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> handle;</span><br><span class="line">  <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) &#123; <span class="comment">// &gt;= pageSize</span></span><br><span class="line">    handle =  allocateRun(normCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &lt; 8kb</span></span><br><span class="line">    handle = allocateSubpage(normCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存队列获取nioBuffer</span></span><br><span class="line">  ByteBuffer nioBuffer = cachedNioBuffers != <span class="keyword">null</span> ? cachedNioBuffers.pollLast() : <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 填充实际数据</span></span><br><span class="line">  initBuf(buf, nioBuffer, handle, reqCapacity);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注allocateSubpage以及allocateRun方法,最终会执行allocateNode,这里只分析allocateSubpage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从arena查询对应的区域类型的PoolSubPage</span></span><br><span class="line">  PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">  <span class="keyword">int</span> d = maxOrder; </span><br><span class="line">  <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储subpage的池大小为8kb</span></span><br><span class="line">    <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line">    freeBytes -= pageSize;</span><br><span class="line">    <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">    PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">    <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建一个容量大小为normCapacity的subpage来存储数据</span></span><br><span class="line">      subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">      subpages[subpageIdx] = subpage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      subpage.init(head, normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成分配并返回subpage的bitmap</span></span><br><span class="line">    <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>分配的数据存储到线程缓存的源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于池化技术,有一点就是一旦数据释放的时候将会将资源进行回收重复利用.于是当调用byteBuf进行数据回收的时候,会执行以下动作</span></span><br><span class="line"><span class="comment">// 入口代码</span></span><br><span class="line">ReferenceCountUtil.release(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上述我们已经知道默认使用PooledByteBuf,于是如果msg为PooledByteBuf,当进行资源回收的时候,就会执行以下的动作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledByteBuf</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">    <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">    memory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里进行资源回收</span></span><br><span class="line">    chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);</span><br><span class="line">    tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    chunk = <span class="keyword">null</span>;</span><br><span class="line">    recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">    destroyChunk(chunk);</span><br><span class="line">    activeBytesHuge.add(-size);</span><br><span class="line">    deallocationsHuge.increment();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">    <span class="comment">// 可以看到这里将数据添加到线程缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">      <span class="comment">// cached so not free it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeChunk(chunk, handle, sizeClass, nioBuffer, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此,Netty从分配到回收一个池化的ByteBuf工作流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_cache_flow.jpg"></p>
<p>Netty内存分配逻辑结构视图:</p>
<ol>
<li>从宏观上看,线程与Arena之间的关系:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_arena.jpg"></p>
<ol start="2">
<li>从微观上看每个arena存储数据过程,在上述源码中我们看到在没有使用线程缓存的时候,会创建一个PoolChunk对象,在这个PoolChunk中对于小于8kb的数据会通过维护着一个subpage类型的数组来组成一个page,我们可以认为把存储数据的buffer存放在一个chunk的一个page,并且每个page的容量都是2幂次方且单位为byte,在chunk为了便于搜索可用的page,于是在逻辑上将page以完全二叉树的数据结构进行存储,方便进行搜索查询,每个二叉树节点存储对应一个可分配的容量,根容量为16M,深度每增加1,容量就减半.如下图所示:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_chunk.jpg"></p>
<ol start="3">
<li>最后我们看下线程缓存存储的逻辑结构(基于可伸缩性的jemalloc算法):</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_cache.jpg"></p>
<p>上述的Tiny MemoryRegionCache对应于TinySubPageCache,Small MemoryRegionCache对应于SmallSubPageCache,而Normal MemoryRegionCache对应于NormalCache.</p>
<p>最后,我们根据源码将内存分配策略如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_cache_memory.jpg"></p>
<blockquote>
<p>jemalloc算法</p>
</blockquote>
<ul>
<li>工作原理</li>
</ul>
<ol>
<li>按照对象的大小划分存储对象等级区域,比如tiny对象,Small对象,Normal对象以及Large对象等</li>
<li>划分尺寸等级,根据传递分配对象大小来技计算合适当前对象存储的区域,比如7kb与5kb的数据都会存储在一个大小为8kb的chunk的内存区域,且每个chunk的内存区域都是连续并且组成一个page.</li>
<li>控制分配器元数据的开销并严格限制为少于总内存的2%</li>
<li>最小化活动页面集,在操作系统内核中,通常是4kb来管理虚拟内存,即将所有数据集中到尽可能少地页存储,好比上述第2点所讲的,多个chunk组成一个page.</li>
<li>最小化锁争用,为了保证并发读写数据的效率,需要为执行的线程指定特定的线程缓存,避免线程操作同一个内存区域时竞争锁导致性能下降.</li>
<li>能够提供可扩展性的分配器,即可以有开发人员指定也可以由部分技术框架默认提供.</li>
</ol>
<ul>
<li>数据大小类别</li>
</ul>
<ol>
<li>Small: [8], [16, 32, 48, …, 128], [192, 256, 320, …, 512], [768, 1024, 1280, …, 3840]<br>2 .Large: [4 KiB, 8 KiB, 12 KiB, …, 4072 KiB]</li>
<li>Huge: [4 MiB, 8 MiB, 12 MiB, …]</li>
</ol>
<ul>
<li>逻辑视图:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/jemalloc_arean.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/thread_cache_arena.jpg"></p>
<h4 id="Netty高效处理机制"><a href="#Netty高效处理机制" class="headerlink" title="Netty高效处理机制"></a>Netty高效处理机制</h4><h5 id="解决空轮询的源码"><a href="#解决空轮询的源码" class="headerlink" title="解决空轮询的源码"></a>解决空轮询的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.java</span></span><br><span class="line"><span class="comment">// 仅摘录部分代码</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  <span class="comment">// 可配置select的循环次数,当网络数据包一直不可达的时候,通过次数控制减少当前selector不断无结果的空轮询,一旦超过次数将会重建selector,将原有的selector关闭,避免cpu飙升.</span></span><br><span class="line">    <span class="keyword">int</span> selectorAutoRebuildThreshold = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.selectorAutoRebuildThreshold&quot;</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (selectorAutoRebuildThreshold &lt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">      selectorAutoRebuildThreshold = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">       select();</span><br><span class="line">     &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">     selectCnt++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    ranTasks = runAllTasks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ranTasks || strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">       logger.debug(...);</span><br><span class="line">      selectCnt = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="comment">// Unexpected wakeup (unusual case)</span></span><br><span class="line">      selectCnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unexpectedSelectorWakeup方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unexpectedSelectorWakeup</span><span class="params">(<span class="keyword">int</span> selectCnt)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">    <span class="comment">// 超过一定的次数之后重建selector,如何重建这里不贴代码</span></span><br><span class="line">    rebuildSelector();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用责任链机制实现无锁串行化任务"><a href="#使用责任链机制实现无锁串行化任务" class="headerlink" title="使用责任链机制实现无锁串行化任务"></a>使用责任链机制实现无锁串行化任务</h5><p>基于事件轮询器的源码与线程模型可知,分配给每个EventLoop的专属线程都会负责处理select之后的就绪事件集合以及所有在阻塞队列中的任务,且线程与EventLoop通过FastThreadLocal进行绑定,也就是说所有事件的处理与任务的执行都是处于一个线程中,从而保证事件处理与任务处理都是保持在同一个线程中,同时与了保持一个channelHandler实例能够共享于多个pipeline中,需要通过注解@Shareble方式来保证线程安全.于是对于Netty处理的任务还是channelHandler下的完成事件处理都是能够得到线程安全的保证,于是对于无锁串行化的描述如下图:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_unlock_pipeline.jpg"></p>
<h5 id="使用并发库"><a href="#使用并发库" class="headerlink" title="使用并发库"></a>使用并发库</h5><p>在先前的高性能IO设计一文中有说到,在资源竞争的环境下,使用并发库甚至是无锁编程能够提升程序的性能,避免锁的争抢与等待.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_java_cocurrent.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_java_cocurrent1.jpg"></p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote>
<p>C10K &amp; C10M</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html">http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C10k_problem">https://en.wikipedia.org/wiki/C10k_problem</a></li>
</ul>
<blockquote>
<p>高性能</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://pl.atyp.us/content/tech/servers.html">http://pl.atyp.us/content/tech/servers.html</a></li>
</ul>
<blockquote>
<p>基于可伸缩性的jemalloc算法</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919</a></li>
</ul>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Netty%E9%AB%98%E6%80%A7%E8%83%BD%E7%89%B9%E6%80%A7"><span class="toc-text">深入分析Netty高性能特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C10K%E4%B8%8EC10M%E9%97%AE%E9%A2%98"><span class="toc-text">C10K与C10M问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C10K-amp-C10M%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">C10K&amp;C10M解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">高并发问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C10K%E4%B8%8EC10M%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9B%A0%E7%B4%A0"><span class="toc-text">C10K与C10M提升性能优化因素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Netty线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">可伸缩的IO模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E4%B9%8BReactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">Netty之Reactor模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8BByteBuf"><span class="toc-text">Netty高性能之ByteBuf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-text">堆外内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6"><span class="toc-text">零拷贝机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-text">动态扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">引用计数与资源管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">内存分配算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">Netty高效处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%A9%BA%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">解决空轮询的源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E4%B8%B2%E8%A1%8C%E5%8C%96%E4%BB%BB%E5%8A%A1"><span class="toc-text">使用责任链机制实现无锁串行化任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E5%BA%93"><span class="toc-text">使用并发库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <img src="/images/wechat-small.jpg" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div>
  
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/04/24/netty03/" rel="next" title="深入Netty事件流程分析(下)">
          深入Netty事件流程分析(下)
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/05/10/distributed01/" rel="prev" title="分布式架构设计概要总结(上)">
            分布式架构设计概要总结(上)
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://xiaokunliu.github.io">首页</a> |
        <a class="bottom-item" href="https://xiaokunliu.github.io" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/xiaokunliu" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
