
<!DOCTYPE html>
<html lang="zh-CN">
<!--
config header
-->



<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

  
      <meta name="google-site-verification" content="{{ theme.google_site_verification }}" />
  

  
    <meta name="keywords" content="网络IO编程," />
  

  
    <meta name="description" content="分享个人学习工作的技术知识" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.jpg">
  <title>category: 网络IO编程 [ 疾风先生 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://xiaokunliu.github.io/images/logo.jpg">
    <span class="title">疾风先生</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        深入Netty事件流程分析(上)
      </h1>
      <span>
        
        <time class="time" datetime="2020-04-19T11:14:54.000Z">
        2020-04-19
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9CIO%E7%BC%96%E7%A8%8B/" rel="tag">网络IO编程</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
    </header>

    <div class="post-content">
      <span id="more"></span>
<h4 id="Netty框架核心内容"><a href="#Netty框架核心内容" class="headerlink" title="Netty框架核心内容"></a>Netty框架核心内容</h4><h5 id="丰富的Buffer数据结构"><a href="#丰富的Buffer数据结构" class="headerlink" title="丰富的Buffer数据结构"></a>丰富的Buffer数据结构</h5><p>Netty在NIO的ByteBuffer基础上自定义一套自己的Buffer API,其实现的Buffer API具备以下特性:</p>
<ul>
<li>如果需要可以自定义自己的buffer类型</li>
<li>内建composite buffer类型实现零拷贝机制(无需在内存实现数据复制)</li>
<li>可以支持动态扩容,类似于StringBuffer</li>
<li>不需要像NIO的Buffer需要每次调用flip(),Netty实现的Buffer通过readerIndex以及writeIndex避免flip()调用</li>
<li>通常会比ByteBuffer在性能上更好</li>
</ul>
<p>零拷贝示例,通过分割与组合:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设buffer1以及buffer2都存储在堆外内存,堆内内存同理(只是在JVM中)</span></span><br><span class="line">ByteBuf httpHeader = buffer1.silice(OFFSET_PAYLOAD, buffer1.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line">ByteBuf httpBody = buffer2.silice(OFFSET_PAYLOAD, buffer2.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line"></span><br><span class="line">ByteBuf http = ChannelBuffers.wrappedBuffer(httpHeader, httpBody);</span><br></pre></td></tr></table></figure>

<p>上述的零拷贝示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/zero_copy.jpg"></p>
<h5 id="使用异步IO的API"><a href="#使用异步IO的API" class="headerlink" title="使用异步IO的API"></a>使用异步IO的API</h5><ul>
<li>基于TCP/IP的NIO模式</li>
<li>基于TCP/IP的BIO模式</li>
<li>基于UDP/IP的BIO模式</li>
</ul>
<h5 id="基于事件驱动设计的责任链设计"><a href="#基于事件驱动设计的责任链设计" class="headerlink" title="基于事件驱动设计的责任链设计"></a>基于事件驱动设计的责任链设计</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/pipeline.jpg"></p>
<h5 id="支持特性组件-简化开发"><a href="#支持特性组件-简化开发" class="headerlink" title="支持特性组件,简化开发"></a>支持特性组件,简化开发</h5><ul>
<li>支持SSL/TLS安全协议</li>
<li>HTTP/WebSocket协议的实现</li>
<li>支持Google的Protocol协议</li>
<li>支持编解码器,Netty也有内置一些编解码器实现</li>
</ul>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>讲述Netty线程模型之前,摘录Netty官网的描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance and high-scalability protocol servers and clients.</span><br></pre></td></tr></table></figure>

<p>从上述官网可得到以下的信息:</p>
<ul>
<li>Netty是基于EDA事件驱动架构设计实现</li>
<li>Netty采用异步方式来完成事件通知,完成事件之后会进行回调唤醒Handler,可以理解为Proactor模式,或者是多线程异步执行的Reactor模型.</li>
<li>Netty是一个高性能高扩展性的web服务框架,可以在不影响性能情况快速实现web服务的开发</li>
</ul>
<p>在Netty组件分析中,EventLoop是一个线程池执行器,同时对于长时间的耗时Handler操作,会额外分配一个线程池执行器来负责处理handler相关的业务逻辑,于是基于Reactor/Proactor模型可知,Netty的一个线程模型如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/thread_model.jpg"></p>
<h4 id="Netty事件流程"><a href="#Netty事件流程" class="headerlink" title="Netty事件流程"></a>Netty事件流程</h4><p>基于上述的Netty线程模型的理解,现摘录官网的一个EchoServer例子来深入分析Netty事件流程,对应的EchoServer代码示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅摘录部分核心代码</span></span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline p = ch.pipeline();</span><br><span class="line">        <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">        <span class="comment">// 将处理读写事件的handler添加到责任链中</span></span><br><span class="line">        p.addLast(serverHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the server.</span></span><br><span class="line">  ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">  f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">  bossGroup.shutdownGracefully();</span><br><span class="line">  workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述的代码示例,其运作的核心流程如下:</p>
<ul>
<li>初始化Boss以及Worker的事件轮询NioEventLoop线程,即Reactor线程</li>
<li>创建服务启动类ServerBootsrtap</li>
<li>将Boss以及Worker的Reactor线程添加到服务启动类中</li>
<li>服务启动类创建并注册服务端的Channel</li>
<li>服务启动类为服务端的Channel配置可选属性</li>
<li>服务启动类添加一个通用共享且日志级别为INFO的处理器并应用在整个Netty的pipeline</li>
<li>基于之前的Channel组件分析,我们知道childChannel也就是对应客户端的SocketChannel,这个时候是服务启动类为SocketChannel添加一个初始化的Handler,并在后续基于事件触发完成之后执行责任链下的handler回调</li>
<li>至此,一系列的初始化操作完成,这个时候服务启动类开始为ServerChannel绑定端口开始对客户端连接进行监听</li>
<li>关闭连接的监听以及销毁Reactor线程释放空间</li>
</ul>
<p>对此,基于上述给出的完整服务端流程,现对上述流程结合源码进行分析与总结.</p>
<h5 id="EventLoopGroup与EventLoop初始化流程"><a href="#EventLoopGroup与EventLoop初始化流程" class="headerlink" title="EventLoopGroup与EventLoop初始化流程"></a>EventLoopGroup与EventLoop初始化流程</h5><blockquote>
<p>EventLoopGroup初始化流程</p>
</blockquote>
<ul>
<li>NioEventLoopGroup类图结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloopgroup_class.jpg"></p>
<ul>
<li>EventLoopGroup初始化源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoopGroup构造器 </span></span><br><span class="line"><span class="comment">// NioEventLoopGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认使用阻塞式轮询策略</span></span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());   <span class="comment">// channel处理不过来的时候直接丢弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认线程数量为CPU*2 或者是通过 io.netty.eventLoopThreads进行配置</span></span><br><span class="line">  <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建默认事件执行选择器(从Group中选择一个EventLoop来处理Channel的策略选择器)</span></span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Group的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述可以看到初始化创建默认具备线程池的一些默认策略(线程大小/线程工厂/存储任务队列/丢弃策略)/创建默认的事件轮询选择器/默认的IO复用器提供者</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EventLoopGroup初始化的核心流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloopGroup_init.jpg"></p>
<p>根据上述可以知道,EventLoopGroup初始化的操作主要是初始化一组EventLoop的执行器,并创建选举EventLoop的选择器,并为每个EventLoop在销毁的时候添加监听器以便于程序能够获取当前EventLoop销毁情况,同时每个EventLoop对外提供服务都是只读模式,也就是选举EventLoop都是处于只读的稳定版本.</p>
<blockquote>
<p>EventLoop的创建流程</p>
</blockquote>
<p>EventLoop的创建流程包含在上述EventLoopGroup为每个执行器(EventLoop)进行初始化的过程,即在源代码中如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="comment">// 初始化执行器</span></span><br><span class="line">children[i] = newChild(executor, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// newChild的实现子类NioEventLoopGroup</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">                          ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">             EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">  <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),</span><br><span class="line">        rejectedExecutionHandler);</span><br><span class="line">  <span class="keyword">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">  <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">  <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">  <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EventLoop的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_init.jpg"></p>
<p>基于上述的EventLoopGroup与EventLoop的认知,我们来总结下EventLoopGroup,EventLoop,EventExecutor以及Thread之间的关系,首先先从源码开始分析如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="comment">// ThreadPerTaskExecutor看成线程池 - 对应默认的线程工厂类</span></span><br><span class="line">executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有多少个线程就有多少个EventLoop</span></span><br><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用线程池创建EventLoop</span></span><br><span class="line">children[i] = newChild(executor, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleThreadEventExecutor.java</span></span><br><span class="line"><span class="comment">// this为NioEventLoop</span></span><br><span class="line"><span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadExecutorMap.java</span></span><br><span class="line"><span class="comment">// 创建新的执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Executor executor, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// check not null ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ThreadPerTaskExecutor.execute -&gt; apply</span></span><br><span class="line">      <span class="comment">// 启动一个线程执行任务并传递事件轮询器</span></span><br><span class="line">      <span class="comment">// FastThreadLocalThread.run()</span></span><br><span class="line">      executor.execute(apply(command, eventExecutor));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新任务Task</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Runnable command, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(command, <span class="string">&quot;command&quot;</span>);</span><br><span class="line">  ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将EventLoop存储到FastThreadLocal(即保证FastThreadLocalThread独占持有自己的EventLoop)</span></span><br><span class="line">      setCurrentEventExecutor(eventExecutor);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        command.run();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务执行完之后释放独占EventLoop的资源</span></span><br><span class="line">        setCurrentEventExecutor(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentEventExecutor</span><span class="params">(EventExecutor executor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用FastThreadLocal来存储事件轮询器，保证每个事件轮询器都会有对应的一个线程来处理</span></span><br><span class="line">  mappings.set(executor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过上述的流程可知,在每个EventLoop都含有一个新的Executor</span></span><br><span class="line"><span class="comment">// 而每一个Executor都通过默认的线程工厂创建一个FastThreadLocalThread线程来处理task任务</span></span><br><span class="line"><span class="comment">// 此时的Task任务为一个新的任务task</span></span><br></pre></td></tr></table></figure>

<p>通过源码分析,可以得到以下简要的EventLoopGroup,Group下的线程池Executor,EventLoop与EventLoop下的Executor以及Thread之间的关系如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread.jpg"></p>
<p>通过上述示意图可知,每个EventLoop处理任务时都会通过Group下的Executor来创建对应的线程来执行EventLoop的事件任务,并且为了保证并发安全问题,在每次处理任务之前,将会把当前的EventLoop与Thread进行绑定,也就是当前EventLoop为当前执行的线程Thread所独占持有,通过FastThreadLocal来维护两者之间的关系,一旦EventLoop事件任务处理完成之后,将解除两者的绑定.同时也可以看到处理一组事件任务的Thread将通过线程组的方式进行维护和管理.</p>
<blockquote>
<p>Netty线程模型细化</p>
</blockquote>
<p>可以看到上述一个EventLoop绑定一个专有的线程,由专有的线程负责处理EventLoop的事件,且一个channel都会对应着一个EventLoop来负责处理channel相关的事件,同时一个EventLoop/Thread能够处理多个Channel需要依赖于AIO或者是NIO的API才能实现,AbstractBootstrap处理服务端Channel,ServerBootstrap处理客户端Channel,而对于BIO模型而言,只能一个EventLoop/Thread处理对应一个Channel,即摘录《Netty实战》关于NIO/OIO(old IO,BIO)模型如下:</p>
<ul>
<li>基于NIO/AIO的线程模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread_channel.jpg"></p>
<ul>
<li>基于BIO的线程模型(OIO为old IO,即使用BIO的API)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/group_thread_bio_channel.jpg"></p>
<ul>
<li>EventLoop启动任务的执行源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用以下的方法时执行流程</span></span><br><span class="line"><span class="comment">// SingleThreadEventExecutor.java</span></span><br><span class="line">eventLoop.execute(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的线程执行流程不弄清楚,后面的事件流程将很理解</span></span><br><span class="line"><span class="comment">// 根据类设计可知,execute为SingleThreadEventExecutor下的方法,结合上面的EventLoop初始化流程可知,每个EventLoop都拥有一个内置的Executor,而这个Executor用于创建FastThreadLocalThread线程来保证当前eventloop与当前线程之间的绑定关联,源码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断当前执行的线程是否与eventloop对应(EventLoop - Thread绑定一起）</span></span><br><span class="line">  <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">  <span class="comment">// 将任务添加到队列中,如果队列满则丢弃当前任务</span></span><br><span class="line">  addTask(task);</span><br><span class="line">  <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">    <span class="comment">// 启动一个线程,如果当前EventLoop持有的线程已经开启过则直接跳过,如果开启过线程,则执行doStartThread方法</span></span><br><span class="line">    startThread();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// EventLoop持有的executor来创建一个FastThreadLocalThread线程,在该线程中保证当前事件轮询器与线程处于线程安全,通过FastThreadLocal将线程与EventLoop进行关联</span></span><br><span class="line">  executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    	<span class="comment">//....</span></span><br><span class="line">  &#125;);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合EventLoop初始化对应的executor以及ThreadExecutorMap中的源码,现将一个不在当前线程的EventLoop提交任务时创建一个完整线程执行细节流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread_detail.jpg"></p>
<p>也就是说,最终处理任务task都在NioEventLoop执行的run方法中体现,或者更为严格意义上来取决于我们选择的EventLoop的IO操作模式,具体是交由EventLoop的IO操作模式的run方法通过队列中获取任务来进行处理,于是根据源码中提供的任务队列与拒绝策略,对于EventLoop处理任务的流程如下(摘录自《Netty实战》):</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_task_nettyinaction.jpg"></p>
<ul>
<li>与线程池不一样的是,EventLoop是与指定的线程绑定在一起,也就是一个线程处理一个EventLoop,并且在整个Web服务中EventLoop始终是由当前的专有线程负责事件的任务的处理</li>
<li>当添加任务到EventLoop执行的时候,需要校验当前的线程是不是持有之前分配好的EventLoop,如果不是那么就添加到任务队列进行等待EventLoop下一次处理事件时再执行,如果队列满了,那么此时就会触发拒绝策略丢弃任务,如果是之前分配好的EventLoop那么就会直接执行任务Task.</li>
</ul>
<blockquote>
<p>Netty之NIO事件轮询流程</p>
</blockquote>
<p>基于上述的线程任务流程分析之后,我们知道在EventLoop中最终会调用NioEventLoop下的run方法,对此,现该run方法执行的事件轮询操作流程进行分析.</p>
<ul>
<li>事件轮询源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.run()核心代码</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  	<span class="comment">// 检测当前的EventLoop的队列中是否有任务</span></span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">      strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 根据服务器配置eventloop的IO处理能力比率</span></span><br><span class="line">  <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果IO处理比率高，则同时处理就绪事件以及当前轮询器队列中的所有任务</span></span><br><span class="line">    <span class="comment">// 不然就分开处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理一系列的就绪事件</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">      <span class="comment">// 执行所有的任务</span></span><br><span class="line">      ranTasks = runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理就绪事件,处理ACCEPT/READ/WRITE事件</span></span><br><span class="line">      processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 在一定事件内处理队列中的任务</span></span><br><span class="line">      <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">      ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">    ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">  &#125;             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop的unsafe为NioMessageUnsafe</span></span><br><span class="line">processSelectedKeys()&#123;</span><br><span class="line">  <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">    unsafe.finishConnect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runAllTasks</span></span><br><span class="line">runAllTasks()&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) &#123;</span><br><span class="line">      ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!fetchedAll); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runAllTasksFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>&#123;</span><br><span class="line">  Runnable task = pollTaskFrom(taskQueue);</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 在当前EventLoop所在的线程执行run方法</span></span><br><span class="line">    <span class="comment">// task.run();</span></span><br><span class="line">    safeExecute(task);</span><br><span class="line">    task = pollTaskFrom(taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件轮询流程图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_run.jpg"></p>
<h5 id="SeverBootstrap初始化流程"><a href="#SeverBootstrap初始化流程" class="headerlink" title="SeverBootstrap初始化流程"></a>SeverBootstrap初始化流程</h5><blockquote>
<p>Netty组件初始化流程</p>
</blockquote>
<p>在分析启动类初始化之前,我们先来查看下启动类的类图结构设计</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/boostrap_class.jpg"></p>
<p>根据类图结构,启动类比较简单,同时关于启动类的详细已经在先前组件分析过,现来看下启动类初始化Netty相关组件的源码</p>
<ul>
<li>EventLoopGroup添加到启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootsrtap.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.group = group;</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上述可知并结合多Reactor模式可知</span></span><br><span class="line"><span class="comment">// ServerBootstrap持有childGroup,用于处理socketChannel的读写事件</span></span><br><span class="line"><span class="comment">// AbstractBootstrap持有parentGroup,用于处理serverChannel的accept事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将服务端的Channel类对象以及服务端配置添加到启动类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="comment">// 创建一个服务端的ServerChannel并指定其BACKLOG大小为100</span></span><br><span class="line">bootstrap.channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 通过传递的服务端Channel构造一个Channel创建工厂类,用于后续构建服务端的Channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">    ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端Channel的配置存储到容器Map中</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(option, <span class="string">&quot;option&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      options.remove(option);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      options.put(option, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将处理服务端的Handler添加到启动类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口程序类</span></span><br><span class="line">bootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 当前的服务端channelHandler存在于AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handler = ObjectUtil.checkNotNull(handler, <span class="string">&quot;handler&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将处理客户端channelHandler添加到启动类</li>
</ul>
<p>由于服务端程序启动服务端Channel之后会监听客户端SocketChannel的连接,一旦有连接进来这个时候就会注册绑定客户端的SocketChannel并监听读写事件,对此,对于使用Netty框架的服务端程序而言只需要关注处理读写事件的Handler即可,由于先前在组件源码分析中已经说明到,ServerChannel是作为客户端SocketChannel的语义层次上的父类,于是对于handler我们也可以理解childHandler是处理客户端读写事件的handler的处理器,其对应的源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口类程序</span></span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; </span><br><span class="line">  <span class="comment">// 保证每一个socket channel都会对应着一个自己的channel handler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = ch.pipeline();</span><br><span class="line">    <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">      p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">    &#125;</span><br><span class="line">    p.addLast(serverHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// ServerBootstrap.java</span></span><br><span class="line"><span class="comment">// 将上述的childHandler绑定到ServerBootstrap,为ServerBootstrap所持有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.childHandler = ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Bootstrap初始化</li>
</ul>
<p>基于上述添加EventLoopGroup以及ChannelHandler,我们再来看下Bootsrtap启动类初始化的时候做了什么事情.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口程序</span></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上述执行初始化流程中,会在内部完成以下组件的初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>结合之前组件分析,我们知道Channel是存在语义上的层次关系,对此,我们关注ServerBootstrap与ServerBootstrapConfig, AbstractBootstrap与AbstractBootstrapConfig之间分别获取channel信息的区分,其类图组件如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_config_class.jpg"></p>
<p>通过上述的类图可以知道,ServerBootsrtap与SocketChannel进行关联,AbstractServerBootstrap与ServerSocketChannel进行关联,对于channel,ServerSocketChannel与SocketChannel是层次上的父子关系,对于Bootsrap类抑或是Config类,均通过子类获取与SocketChannel相关的信息,通过父类获取与ServerSocketChannel相关信息,层次划分明确,现将Bootstrap构造初始化操作事件流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_flow.jpg"></p>
<p>我们知道在Netty框架在处理服务端与客户端的事件是划分层次的,在语义层次上,服务端属于“父类”,客户端属于“子类”,两者之间的事件所依赖的组件也在语义上划分层次,对此,结合上述对EventLoopGroup与EventLoop的源码分析,现将启动类Bootstrap,EventLoopGroup,EventLoop,Channel以及Thread之间的关联示意图绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_group_thread_channel.jpg"></p>
<h5 id="启动类绑定端口事件流程"><a href="#启动类绑定端口事件流程" class="headerlink" title="启动类绑定端口事件流程"></a>启动类绑定端口事件流程</h5><p>入口程序源码分析如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口程序</span></span><br><span class="line">bootsrtap.bind(PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 通过类名称可知是创建服务端的Channel并注册Channel事件实现对客户端Channel连接的监听</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind包括: 创建channel -&gt; 初始化channel -&gt; 注册channel -&gt; channel绑定端口操作</span></span><br><span class="line">doBind(<span class="keyword">final</span> SocketAddress localAddress)&#123;</span><br><span class="line">  <span class="comment">// 由于注册绑定流程复杂,这里将绑定注册流程划分出来,摘录核心方法,Netty框架中使用EventLoop来处理每个channel事件,存在多线程异步执行的情况.对于异步返回的结果ChannelFuture已在Netty组件源码分析说明到,这里不再详述</span></span><br><span class="line"><span class="comment">// 初始化并注册服务端的channel</span></span><br><span class="line">initAndRegister();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果注册成功,执行服务端channel的绑定操作</span></span><br><span class="line">doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务端channel初始化与注册事件</p>
</blockquote>
<ul>
<li>创建服务端channel的流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="comment">// 使用channelFactory创建NioServerSocketChannel实例</span></span><br><span class="line">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure>

<p><code>NioServerSocketChannel</code>类图结构设计如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/nioserversocketchannel_class.jpg"></p>
<p>这个时候再来看创建<code>NioServerSocketChannel</code>实例都做了哪些事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建java的nio下的ServerSocketChannel并传递到当前的NioServerSocketChannel构造器中</span></span><br><span class="line">  <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 服务端监听Accept事件并保存,后续在进行注册的时候将会使用到OP_ACCEPT</span></span><br><span class="line">  	<span class="comment">// 1.设置channel的父类,如果当前为服务端的channel则为null</span></span><br><span class="line">  	<span class="comment">// 2.创建channelId</span></span><br><span class="line">    <span class="comment">// 3.创建Nio的Unsafe类</span></span><br><span class="line">    <span class="comment">// 4.创建channel的责任链pipeline,同时每个pipeline都会创建一个双端链表连接上下文对象</span></span><br><span class="line">  <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">  <span class="comment">// 1. 为当前的channel创建接收数据的ByteBuff分配器,即AdaptiveRecvByteBufAllocator,该分配器默认从1024kb开始创建缓冲区分配数据,最小为64kb,最多不超过65536kb</span></span><br><span class="line">  <span class="comment">// 2. 保存java对象的ServerSocketChannel</span></span><br><span class="line">  config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述源码可知,创建Channel时会将与操作Channel相关的组件也一起完成初始化操作,即创建操作缓冲区数据的Unsafe以及对缓冲区数据进行读写存储的ByteBuff分配器.</p>
<ul>
<li>服务端channel的初始化流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上述完成channel的创建,接下来对channel进行初始化操作</span></span><br><span class="line"><span class="comment">// 对应的源码</span></span><br><span class="line"><span class="comment">// ServerBootstrap.java</span></span><br><span class="line">	<span class="comment">// 1. 为当前的channel设置option以及attributes</span></span><br><span class="line">  <span class="comment">// 2. 获取当前channel的责任链,为当前的责任添加初始化handler处理器</span></span><br><span class="line">init(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// init下初始化handler核心代码</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">    ChannelHandler handler = config.handler();</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pipeline.addLast(handler);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 在channel所在的eventloop创建一个线程来执行任务</span></span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在任务下为服务端的channel添加Acceptor处理器负责处理客户端channel连接进来的事件完成处理</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">          ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端channel的注册流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 获取boss NioEventLoopGroup,将channel注册到当前的group下</span></span><br><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NioEventLoopGroup的继承类图,可知register方法是在MultithreadEventLoopGroup下</span></span><br><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 选举一个EventLoop来注册channel</span></span><br><span class="line">   <span class="comment">// 在初始化Group操作的时候已经完成选择器的初始化操作,这里调用选择器来选择一个EventLoop</span></span><br><span class="line">   <span class="comment">// 这里调用EventLoop的注册方法,在上述入口中使用NioEventLoop可知使用的register方法为SingleThreadEventLoop类下的方法,最终调用AbstractChannel下的register方法</span></span><br><span class="line">   <span class="comment">// 方法调用走向如下:</span></span><br><span class="line">   <span class="comment">// MultithreadEventLoopGroup.regitser() -&gt; SingleThreadEventLoop.regitser() -&gt; promise.channel().unsafe().register() -&gt; unsafe(NioMessageUnsafe).regitser() -&gt; AbstractNioUnsafe.regitser() -&gt; AbstractUnsafe.register() -&gt; AbstractUnsafe.register0()</span></span><br><span class="line">   <span class="keyword">return</span> next().register(channel);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractChannel.java下的AbstractUnsafe</span></span><br><span class="line">register0(promise);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述注册方法的核心步骤:</span></span><br><span class="line"><span class="comment">// 1. 将channel注册到复用器selector上</span></span><br><span class="line"><span class="comment">// 2. 注册完成之后唤醒回调责任链下所有先前已加入的channelHandler类下的handlerAdd方法</span></span><br><span class="line"><span class="comment">// 3. 注册完成之后将结果设置在promise中</span></span><br><span class="line"><span class="comment">// 4. 将注册结果传递到责任链pipeline中,并执行回调channelHandler(ChannelInboundHandler)类下的channelRegistered方法,链式回调执行</span></span><br><span class="line"><span class="comment">// 5. 如果channel为active状态,则继续传播结果事件到channelHandler(ChannelInboundHandler)类下的channelActive方法,链式回调执行</span></span><br><span class="line"><span class="comment">// 6. 5步骤是在第一次进行注册的时候会执行(表示channel已经打开),如果已经注册过,那么校验会自动开始数据读取操作,客户端channel注册读取OP_READ操作, 对应服务端的Channel而言就是监听客户端socket的连接ACCEPT事件</span></span><br></pre></td></tr></table></figure>

<p>在基于上述的线程执行任务细节基础之上,将服务端的初始化并注册流程示意图流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_create_init_register.jpg"></p>
<blockquote>
<p>执行端口绑定与监听操作</p>
</blockquote>
<ul>
<li>端口绑定源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述channel注册成功之后,这个时候在上面流程只会触发Active事件,这个时候没有绑定端口没有触发监听事件</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line">doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  // channel所在的eventloop线程执行任务</span></span></span><br><span class="line"><span class="params"><span class="function">  channel.eventLoop()</span>.<span class="title">execute</span><span class="params">(new Runnable()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册成功将channel进行绑定操作</span></span><br><span class="line">      <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promise.setFailure(regFuture.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannel.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在链表尾部添加绑定操作</span></span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="comment">// cancelled</span></span><br><span class="line">      <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 搜索outboundContext上下文</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">      <span class="comment">// 执行责任链pipeline 出站事件,从链表尾部开始搜索,因而最后的context是headContext</span></span><br><span class="line">      <span class="comment">// 执行headContext下的invokeBind方法,该方法还是属于当前类,对此查看下文</span></span><br><span class="line">      next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          next.invokeBind(localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, promise, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyOutboundHandlerException(t, promise);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// headContext的绑定方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// unsafe为NioMessageUnsafe,执行该类下的bind方法(AbstractUnsafe.java中定义)</span></span><br><span class="line">  <span class="comment">// 最后再执行channel下的doBind(localAddress);方法,即NioServerSocketChannel下的方法</span></span><br><span class="line">  <span class="meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 可以看到实现了端口的绑定操作</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">      javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 对此,基于上述源码的分析,我们绘制服务端channel的端口绑定流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_bind_flow.jpg"></p>
<h5 id="责任链创建执行流程"><a href="#责任链创建执行流程" class="headerlink" title="责任链创建执行流程"></a>责任链创建执行流程</h5><ul>
<li>基于ChannelInitial来初始化pipeline的handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加handler的入口程序</span></span><br><span class="line"><span class="comment">// 这里主要是捡重点说明</span></span><br><span class="line">ChannelPipeline p = channel.pipeline();</span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer()&#123;</span><br><span class="line">  <span class="comment">// 在源码中有如下说明:</span></span><br><span class="line">  <span class="comment">// 一旦channel注册将调用当前initChannel方法，方法执行完成之后将实例会从ChannelPipeline中移除</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">     pipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 使用EventLoop添加</span></span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">          ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(handlers, <span class="string">&quot;handlers&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    checkMultiplicity(handler);</span><br><span class="line">		<span class="comment">// 创建一个上下文对象,默认为DefaultChannelHandlerContext</span></span><br><span class="line">    newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// head -&gt; handler1 --- handler - tail </span></span><br><span class="line">    addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">      <span class="comment">// channel还没有注册,设置当前handler处于等待状态</span></span><br><span class="line">      newCtx.setAddPending();</span><br><span class="line">      <span class="comment">// 将其添加到等待链表的尾部中</span></span><br><span class="line">      callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventExecutor executor = newCtx.executor();</span><br><span class="line">    <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">      callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHandlerAdded0(newCtx);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会当channel完成注册的时候会调用handlerAdd方法,而ChannelInitial的handlerAdd方法如下:</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">    <span class="comment">// 最终会调用initChannel方法</span></span><br><span class="line">    <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">      <span class="comment">// 完成channel的初始化链会将当前实例移除</span></span><br><span class="line">      removeState(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      initChannel((C) ctx.channel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">      exceptionCaught(ctx, cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 最后会在pipeline链中删除当前实例</span></span><br><span class="line">      ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">      <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>责任链添加处理器handler流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/pipeline_add_flow.jpg"></p>
<ul>
<li>channel事件与责任链生命周期联系</li>
</ul>
<p>通过上述可知,channel在注册前后过程中的pipeline存储的handler结构为:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_pipeline_flow.jpg"></p>
<h5 id="服务端接收客户端连接的事件流程"><a href="#服务端接收客户端连接的事件流程" class="headerlink" title="服务端接收客户端连接的事件流程"></a>服务端接收客户端连接的事件流程</h5><p>根据EventLoop的事件轮询流程可知,服务端监听的事件变化以及事件转发处理都在EventLoop.run方法中,对此,我们详细看下Netty的服务端是如何接收并处理客户端的连接事件以及对应的事件流程是如何的.</p>
<ul>
<li>Netty框架下的核心事件轮询run方法源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述已经贴有源码,这里我们更关注细节问题,仅列出run方法的核心源码</span></span><br><span class="line"><span class="comment">// NioServerSocketChannel.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">  <span class="comment">// 服务端不断轮询监听事件</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行select操作</span></span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">      strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理任务队列中的任务</span></span><br><span class="line">    ranTasks = runAllTasks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然关注ACCEPT事件,这个时候我们需要知道服务端Channel在创建注册并绑定的时候初始化handler并将Acceptor添加到handler中,对此我们追踪下bind方法,最后查阅代码到init方法,其代码如下:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在先前分析可知,这里已经完成了channel的创建,且此时channel为NioServerSocketChannel事件</span></span><br><span class="line">  ChannelPipeline p = channel.pipeline();</span><br><span class="line">  p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">      <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">      ChannelHandler handler = config.handler();</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pipeline.addLast(handler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述源代码,服务端监听连接事件的流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_listen_flow.jpg"></p>
<p>其中关于创建和注册流程基本和上述服务端channel一致,这里绘制的时候直接简化,没有详细绘制出来.</p>
<h5 id="服务端处理客户端channel的读写事件流程"><a href="#服务端处理客户端channel的读写事件流程" class="headerlink" title="服务端处理客户端channel的读写事件流程"></a>服务端处理客户端channel的读写事件流程</h5><ul>
<li>读写事件源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里关注的读写事件是NioSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">     ch.unsafe().forceFlush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">     unsafe.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioSocketChannel使用NioByteUnsafe来实现读写</span></span><br><span class="line"><span class="comment">// 先读后写</span></span><br><span class="line"><span class="comment">// 读取流程</span></span><br><span class="line"><span class="comment">// AbstractNioByteChannel.NioByteUnsafe</span></span><br><span class="line">read()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="comment">// 从socket中读取数据</span></span><br><span class="line">      doReadBytes(byteBuff);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传播数据</span></span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">    &#125;<span class="keyword">while</span>(continueReading())</span><br><span class="line">    	pipeline.fireChannelReadComplete();</span><br><span class="line">    	<span class="keyword">if</span>(close)&#123;</span><br><span class="line">      	closeOnRead(pipeline);</span><br><span class="line">    	&#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">//传播userEventTriggered</span></span><br><span class="line">    handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">      <span class="comment">// 取消读取操作</span></span><br><span class="line">      removeReadOp();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出流程</span></span><br><span class="line"><span class="comment">// 写出操作的触发点是在某个handler下的channelRead方法下手动执行write或者writeAndFlush方法</span></span><br><span class="line"><span class="comment">// handler 通过addLast方法添加,默认上下文对象为DefaultChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerRead</span><span class="params">(AbstractHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 执行写操作的流程说明责任链执行当前入站事件handler已经是最后一个,从当前handler的上下文对象开始执行出站事件</span></span><br><span class="line">  ctx.writeAndFlush(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行链为:</span></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.writeAndFlush() - invokeWriteAndFlush -&gt; handler.write()  - head.write() - AbstractUnsafe.write() - filterOutboundMessage() - AbstractNioByteChannel.filterOutboundMessage()[创建一个堆外内存] - addMessage() -&gt; incrementPendingOutboundBytes() -&gt; [newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()] -&gt; setUnwritable -&gt; fireChannelWritabilityChanged -&gt; head.fireChannelWritabilityChanged -&gt; handler.fireChannelWritabilityChanged -&gt; tail.fireChannelWritabilityChanged </span></span><br><span class="line"><span class="comment">// -&gt; invokeFlush0 -&gt; handler.flush()  -&gt; head.flush() -&gt; AbstractUnsafe.flush() -&gt; addFlush()  -&gt; flush0() -&gt;. NioSocketChannel.doWrite() -&gt; ch.write(nioBuffers, 0, nioBufferCnt) -&gt; incompleteWrite() -&gt; setOpWrite()[注册写事件] -&gt; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>读事件流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_read.jpg"></p>
<ul>
<li>写事件流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_write.jpg"></p>
<h5 id="ServerChannel-ChannelHandler-ChannelPipeline事件生命周期"><a href="#ServerChannel-ChannelHandler-ChannelPipeline事件生命周期" class="headerlink" title="ServerChannel/ChannelHandler/ChannelPipeline事件生命周期"></a>ServerChannel/ChannelHandler/ChannelPipeline事件生命周期</h5><p>结合之前组件的源码以及上述的事件流程分析,关于channel事件与pipeline责任链回调执行生命周期流程总结如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_pipeline_life.jpg"></p>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="toc-text">Netty框架核心内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B0%E5%AF%8C%E7%9A%84Buffer%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">丰富的Buffer数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5IO%E7%9A%84API"><span class="toc-text">使用异步IO的API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于事件驱动设计的责任链设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%89%B9%E6%80%A7%E7%BB%84%E4%BB%B6-%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-text">支持特性组件,简化开发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Netty线程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">Netty事件流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EventLoopGroup%E4%B8%8EEventLoop%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">EventLoopGroup与EventLoop初始化流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SeverBootstrap%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">SeverBootstrap初始化流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">启动类绑定端口事件流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%88%9B%E5%BB%BA%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">责任链创建执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">服务端接收客户端连接的事件流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AFchannel%E7%9A%84%E8%AF%BB%E5%86%99%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">服务端处理客户端channel的读写事件流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ServerChannel-ChannelHandler-ChannelPipeline%E4%BA%8B%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">ServerChannel&#x2F;ChannelHandler&#x2F;ChannelPipeline事件生命周期</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <img src="/images/wechat-small.jpg" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div>
  
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/04/10/netty01/" rel="next" title="Netty组件源码分析">
          Netty组件源码分析
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/04/23/proactor/" rel="prev" title="IO事件驱动设计实现">
            IO事件驱动设计实现
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://xiaokunliu.github.io">首页</a> |
        <a class="bottom-item" href="https://xiaokunliu.github.io" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/xiaokunliu" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
