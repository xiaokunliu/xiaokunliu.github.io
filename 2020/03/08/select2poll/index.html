
<!DOCTYPE html>
<html lang="zh-CN">
<!--
config header
-->



<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

  
      <meta name="google-site-verification" content="{{ theme.google_site_verification }}" />
  

  
    <meta name="keywords" content="网络IO编程," />
  

  
    <meta name="description" content="分享个人学习工作的技术知识" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.jpg">
  <title>category: 网络IO编程 [ 疾风先生 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://xiaokunliu.github.io/images/logo.jpg">
    <span class="title">疾风先生</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        深入分析Select/Epoll原理
      </h1>
      <span>
        
        <time class="time" datetime="2020-03-08T17:09:09.000Z">
        2020-03-08
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9CIO%E7%BC%96%E7%A8%8B/" rel="tag">网络IO编程</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
    </header>

    <div class="post-content">
      <span id="more"></span>
<h5 id="Linux内核的休眠与唤醒机制"><a href="#Linux内核的休眠与唤醒机制" class="headerlink" title="Linux内核的休眠与唤醒机制"></a>Linux内核的休眠与唤醒机制</h5><p>在Linux内核中存在着等待队列的数据结构,该数据结构是基于双端链表实现,Linux内核通过将阻塞的进程任务添加到等待队列中,而进程任务被唤醒则是在队列轮询遍历检测是否处于就绪状态,如果是那么会等待队列中删除等待节点并通过节点上的回调函数进行通知然后加入到cpu就绪队列中等待cpu调度执行.其具体流程主要包含以下两个处理逻辑,即休眠逻辑以及唤醒逻辑.</p>
<blockquote>
<p>休眠逻辑</p>
</blockquote>
<ul>
<li><p>linux 内核休眠逻辑核心代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中cmd = schedule(), 即一个调用schedule函数的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq_head, condition, state, exclusive, ret, cmd)</span></span><br><span class="line">(&#123;										</span><br><span class="line">	__label__ __out;							</span><br><span class="line">	struct wait_queue_entry __wq_entry;					</span><br><span class="line">	<span class="keyword">long</span> __ret = ret;	<span class="comment">/* explicit shadow */</span>				</span><br><span class="line">	<span class="comment">// 初始化过程(内部代码这里省略,直接说明)</span></span><br><span class="line">	<span class="comment">// 1. 设置独占标志到当前节点entry</span></span><br><span class="line">	<span class="comment">// 2. 将当前任务task指向节点的private</span></span><br><span class="line">	<span class="comment">// 3. 同时为当前entry节点传递一个唤醒的回调函数autoremove_wake_function,一旦唤醒将会自动被删除</span></span><br><span class="line">	init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : <span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 防止队列中没有entry产生不断的轮询,主要处理wait_queue与entry节点添加或者删除</span></span><br><span class="line">		<span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);</span><br><span class="line">		<span class="comment">// 事件轮询检查是否事件有被唤醒							</span></span><br><span class="line">		<span class="keyword">if</span> (condition)							</span><br><span class="line">			<span class="keyword">break</span>;							</span><br><span class="line">										</span><br><span class="line">		<span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;			</span><br><span class="line">			__ret = __int;						</span><br><span class="line">			<span class="keyword">goto</span> __out;						</span><br><span class="line">		&#125;								</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 调用schedule()方法						</span></span><br><span class="line">		cmd;								</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 事件被唤醒,将当前的entry从队列中移除				</span></span><br><span class="line">	finish_wait(&amp;wq_head, &amp;__wq_entry);					</span><br><span class="line">__out:	__ret;									</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对此,我们可以总结如下:</p>
<ul>
<li>在linux内核中某一个进程任务task执行需要等待某个条件condition被触发执行之前,首先会在内核中创建一个等待节点entry,然后初始化entry相关属性信息,其中将进程任务存放在entry节点并同时存储一个wake_callback函数并挂起当前进程</li>
<li>其次不断轮询检查当前进程任务task执行的condition是否满足,如果不满足则调用schedule()进入休眠状态</li>
<li>最后如果满足condition的话,就会将entry从队列中移除,也就是说这个时候事件已经被唤醒,进程处于就绪状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>唤醒逻辑</p>
</blockquote>
<ul>
<li><p>linux内核的唤醒核心代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">			<span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 省略其他非核心代码...</span></span><br><span class="line">	<span class="comment">// 循环遍历整个等待队列</span></span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用唤醒的函数</span></span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查当前节点是否为独占节点,如果是,即nr_exclusive = 0退出循环遍历</span></span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">void</span>			*<span class="keyword">private</span>;</span><br><span class="line">	<span class="comment">// 这里的func就是上述休眠的时候在init_wait_entry传递autoremove_wake_function</span></span><br><span class="line">	<span class="keyword">wait_queue_func_t</span>	func;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">autoremove_wake_function</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 公用的唤醒函数逻辑</span></span><br><span class="line">	<span class="comment">// 内部执行try_to_wake_up, 也就是将wq_entry的private(当前进程)添加到cpu的执行队列中,让cpu能够调度task执行</span></span><br><span class="line">	<span class="keyword">int</span> ret = default_wake_function(wq_entry, mode, sync, key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 其他为当前唤醒函数私有逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(autoremove_wake_function);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对此,基于上述的唤醒逻辑可以总结如下:</p>
<ul>
<li>在等待队列中循环遍历所有的entry节点,并执行回调函数,直到当前entry为排他节点的时候退出循环遍历</li>
<li>执行的回调函数中,存在私有逻辑与公用逻辑,类似模板方法设计模式</li>
<li>对于default_wake_function的唤醒回调函数主要是将entry的进程任务task添加到cpu就绪队列中等待cpu调度执行任务task</li>
</ul>
</li>
</ul>
<p>至此,linux内核的休眠与唤醒机制有了上述认知之后,接下来揭开IO复用模型设计的本质就相对会比较容易理解</p>
<h5 id="IO复用模型本质"><a href="#IO复用模型本质" class="headerlink" title="IO复用模型本质"></a>IO复用模型本质</h5><p><img src="https://img-blog.csdnimg.cn/20200306232219394.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="IO复用模型"></p>
<p>在讲述IO复用模型之前,我们先简单回顾下IO复用模型的思路,从上述的IO复用模型图看出,一个进程可以处理N个socket描述符的操作,等待对应的socket为可读的时候就会执行对应的read_process处理逻辑,也就是说这个时候我们站在read_process的角度去考虑,我只需要关注socket是不是可读状态,如果不可读那么我就休眠,如果可读你要通知我,这个时候我再调用recvfrom去读取数据就不会因内核没有准备数据处于等待,这个时候只需要等待内核将数据复制到用户空间的缓冲区中就可以了.那么对于read_process而言,要实现复用该如何设计才能达到上述的效果呢?</p>
<blockquote>
<p>复用本质</p>
</blockquote>
<ul>
<li>摘录电子通信工程中术语,“在一个通信频道中传递多个信号的技术”, 可简单理解: 为了提升设备使用效率,尽可能使用最少的设备资源传递更多信号的技术</li>
<li>回到上述的IO复用模型,也就是说这里复用是实现一个进程处理任务能够接收N个socket并对这N个socket进行操作的技术</li>
</ul>
<blockquote>
<p>复用设计原理</p>
</blockquote>
<p>在上述的IO复用模型中一个进程要处理N个scoket事件,也会对应着N个read_process,但是这里的read_process都是向内核发起读取操作的处理逻辑,它是属于进程程序中的一段子程序,换言之这里是实现read_process的复用,即N个socket中只要满足有不少于一个socket事件是具备可读状态,read_process都能够被触发执行,联想到Linux内核中的sleep &amp; wakeup机制,read_process的复用是可以实现的,这里的socket描述符可读在Linux内核称为事件,其设计实现的逻辑图如下所示:<br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/writing2images/io/io_select_flow.jpg" alt="IO复用设计模型"></p>
<ul>
<li>用户进程向内核发起select函数的调用,并携带socket描述符集合从用户空间复制到内核空间,由内核对socket集合进行可读状态的监控.</li>
<li>其次当前内核没有数据可达的时候,将注册的socket集合分别以entry节点的方式添加到链表结构的等待队列中等待数据报可达.</li>
<li>这个时候网卡设备接收到网络发起的数据请求数据,内核接收到数据报,这个时候就通过轮询唤醒的方式(内核并不知道是哪个socket可读)逐个进行唤醒通知,直到当前socket描述符有可读状态的时候就退出轮询然后从等待队列移除对应的socket节点entry,并且这个时候内核将会更新fd集合中的描述符的状态,以便于用户进程知道是哪些socket是具备可读性从而方便后续进行数据读取操作</li>
<li>同时在轮询唤醒的过程中,如果有对应的socket描述符是可读的,那么此时会将read_process加入到cpu就绪队列中,让cpu能够调度执行read_process任务</li>
<li>最后是用户进程调用select函数返回成功,此时用户进程会在socket描述符结合中进行轮询遍历具备可读的socket,此时也就意味着数据此时在内核已经准备就绪,用户进程可以向内核发起数据读取操作,也就是执行上述的read_process任务操作</li>
</ul>
<h5 id="IO复用模型实现"><a href="#IO复用模型实现" class="headerlink" title="IO复用模型实现"></a>IO复用模型实现</h5><p>基于上述IO复用模型实现的认知,对于IO复用模型实现的技术select/poll/epoll也应具备上述两个核心的逻辑,即等待逻辑以及唤醒逻辑,对此用伪代码来还原select/poll/epoll的设计原理.</p>
<blockquote>
<p>select/poll/epoll的等待逻辑</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;maxfds,i++)&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 检测当前fd是否就绪</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fd[i].poll())&#123;</span><br><span class="line">           <span class="comment">// 更新事件状态,让用户进程知道当前socket状态是可读状态</span></span><br><span class="line">            fd_sock.event |= POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res | tiemout | expr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    schdule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>select/poll/epoll的唤醒逻辑</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foreach(entry as waiter_queues)&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒通知并将任务task加入cpu就绪队列中</span></span><br><span class="line">    res = callback();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 说明当前节点为独占节点,只能唤醒一次,因此需要退出循环</span></span><br><span class="line">    <span class="keyword">if</span>(res &amp;&amp; current == EXCLUSIVE)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select-技术"><a href="#select-技术" class="headerlink" title="select 技术"></a>select 技术</h6><blockquote>
<p>select 函数定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd1,							<span class="comment">// 最大文件描述符个数,传输的时候需要+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *readset,						<span class="comment">// 读描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *writeset,					<span class="comment">// 写描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *exceptset,					<span class="comment">// 异常描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct timeval *timeout)</span></span>;		<span class="comment">// 超时时间</span></span><br><span class="line"><span class="comment">// timeout的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">// 单位为秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;		<span class="comment">// 单位微秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// select函数返回结果</span></span><br><span class="line"><span class="comment">//select() &gt; 0: 表示当前调用select监视到有描述符就绪状态的描述符索引值,意味着可以开始读取/写入/异常处理等操作</span></span><br><span class="line"><span class="comment">//select() = 0: 表示当前调用select发生超时,在最后的一个参数指定</span></span><br><span class="line"><span class="comment">//select() = -1: 表示当前调用select发生异常错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在很多Unix/Liunx版本使用pselect函数,最新版本(5.6.2)的select已经弃用</span></span><br><span class="line"><span class="comment">// 其定义如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfd1,							<span class="comment">// 最大文件描述符个数,传输的时候需要+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *readset,						<span class="comment">// 读描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *writeset,					<span class="comment">// 写描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *exceptset,					<span class="comment">// 异常描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct timespec *timeout,		<span class="comment">// 超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct <span class="keyword">sigset_t</span> *sigmask)</span></span>;		<span class="comment">// 信号掩码指针		</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">// 单位为秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_nsec;		<span class="comment">// 单位纳秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>select/pselect技术等待逻辑</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于POSIX协议</span></span><br><span class="line"><span class="comment">// posix_type.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024  <span class="comment">// 最大文件描述符为1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只关注socket可读状态,以下主要是休眠逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 与上述休眠逻辑初始化等待节点操作类似</span></span><br><span class="line">	poll_initwait(&amp;table);	</span><br><span class="line">	wait = &amp;table.pt;<span class="comment">// 获取创建之后的等待节点</span></span><br><span class="line">	</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	n = retval;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 操作返回值</span></span><br><span class="line">	retval = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="comment">// 监控可读的描述符</span></span><br><span class="line">		inp = fds-&gt;in;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">				bit = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// BITS_PER_LONG若处理器为32bit则BITS_PER_LONG=32,否则BITS_PER_LONG=64;</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				f = fdget(i);</span><br><span class="line">				wait_key_set(wait, in, out, bit,</span><br><span class="line">						     busy_flag);</span><br><span class="line">				<span class="comment">// 检测当前等待节点是否可读</span></span><br><span class="line">				mask = vfs_poll(f.file, wait);</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="comment">// 当前等待节点是否可读</span></span><br><span class="line">				<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">					res_in |= bit;</span><br><span class="line">					retval++;</span><br><span class="line">					wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 说明有存在可读节点退出节点遍历</span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 调度带有超时事件的schedule</span></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除队列中的等待节点</span></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>select/pselect技术唤醒逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在poll_initwait -&gt;  __pollwait --&gt; pollwake 的方法,主要关注pollwake方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> wait-&gt;<span class="keyword">private</span>;</span><br><span class="line">	DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);</span><br><span class="line"></span><br><span class="line">	smp_wmb();	<span class="comment">// 与sheculde_time_out中的smp_store_mb方法相呼应,一旦触发那个方法,就会调用执行到这里</span></span><br><span class="line">	pwq-&gt;triggered = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 与linux内核中的唤醒机制一样,下面的方法是内核执行的,不过多关心,有兴趣可以看源码core.c下面定义</span></span><br><span class="line">	<span class="comment">// 就是polling_task也就是read_process添加到cpu就绪队列中,让cpu进行调度</span></span><br><span class="line">	<span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于上述的代码,现总结如下: </p>
<ul>
<li>select技术的实现也是基于Linux内核的等待与唤醒机制实现,对于等待与唤醒逻辑主要细节也在上文中讲述,这里不再阐述</li>
<li>其次可以通过源码知道,在Linux中基于POSIX协议定义的select技术最大可支持的描述符个数为1024个,虽然现代操作系统支持更多的描述符,但是对于select技术增加描述符的话,需要更改POSIX协议中描述符个数的定义,但是此时需要重新编译内核,对于互联网的高并发连接应用是远远不够的</li>
<li>另外一个是用户进程调用select的时候需要将一整个fd集合的大块内存从用户空间拷贝到内核中,期间用户空间与内核空间来回切换开销非常大,再加上调用select的频率本身非常频繁,这样导致高频率调用且大内存数据的拷贝,严重影响性能</li>
<li>最后唤醒逻辑的处理,select技术在等待过程如果监控到至少有一个socket事件是可读的时候将会唤醒整个等待队列,告知当前等待队列中有存在就绪事件的socket,但是具体是哪个socket不知道,必须通过轮询的方式逐个遍历进行回调通知,也就是唤醒逻辑轮询节点包含了就绪和等待通知的socket事件,如果每次只有一个socket事件可读,那么每次轮询遍历的事件复杂度是O(n),影响到性能</li>
</ul>
</li>
</ul>
<h6 id="poll-技术"><a href="#poll-技术" class="headerlink" title="poll 技术"></a>poll 技术</h6><p>poll技术与select技术实现逻辑基本一致,重要区别在于poll技术使用链表的方式存储描述符fd,不受数组大小影响,对此,现对poll技术进行分析如下:</p>
<blockquote>
<p>poll定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll已经被弃用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, 		<span class="comment">// fd的文件集合改成自定义结构体,不再是数组的方式,不受限于FD_SIZE</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, 		<span class="comment">// 最大描述符个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">int</span> timeout)</span></span>;		<span class="comment">// 超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;				<span class="comment">// fd索引值</span></span><br><span class="line">	<span class="keyword">short</span> events;		<span class="comment">// 输入事件</span></span><br><span class="line">	<span class="keyword">short</span> revents;		<span class="comment">// 结果输出事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前查看的linux版本(5.6.2)使用ppoll方式,与pselect差不多,其他细节不多关注</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(struct pollfd *fds, 			<span class="comment">// fd的文件集合改成自定义结构体,不再是数组的方式,不受限于FD_SIZE</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, 				<span class="comment">// 最大描述符个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 struct timespec timeout,			<span class="comment">// 超时时间,与pselect一样</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">const</span> struct <span class="keyword">sigset_t</span> sigmask,		<span class="comment">// 信号指针掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 struct <span class="keyword">size_t</span> sigsetsize)</span></span>;			<span class="comment">// 信号大小</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>poll技术实现的核心代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于poll与select实现的机制差不多,因此不过多贴代码,只简单列出核心点即可</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 从用户空间将fdset拷贝到内核中</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">					<span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 和select一样,初始化等待节点的操作</span></span><br><span class="line">		poll_initwait(&amp;table);</span><br><span class="line">		<span class="comment">// do_poll的处理逻辑与do_select逻辑基本一致,只是这里用链表的方式遍历,do_select用数组的方式</span></span><br><span class="line">		<span class="comment">// 链表可以无限增加节点,数组有指定大小,受到FD_SIZE的限制</span></span><br><span class="line">		fdcount = do_poll(head, &amp;table, end_time);</span><br><span class="line">		<span class="comment">// 从等待队列移除等待节点</span></span><br><span class="line">		poll_freewait(&amp;table);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结: poll技术使用链表结构的方式来存储fdset的集合,相比select而言,链表不受限于FD_SIZE的个数限制,但是对于select存在的性能并没有解决,即一个是存在大内存数据拷贝的问题,一个是轮询遍历整个等待队列的每个节点并逐个通过回调函数来实现读取任务的唤醒</p>
<h6 id="epoll技术"><a href="#epoll技术" class="headerlink" title="epoll技术"></a>epoll技术</h6><p>为了解决select&amp;poll技术存在的两个性能问题,对于大内存数据拷贝问题,epoll通过epoll_create函数创建epoll空间(相当于一个容器管理),在内核中只存储一份数据来维护N个socket事件的变化,通过epoll_ctl函数来实现对socket事件的增删改操作,并且在内核底层使用虚拟内存的管理方式保证用户空间与内核空间对该内存是具备可见性,直接通过指针引用的方式进行操作,避免了大内存数据的拷贝导致的空间切换性能问题,对于轮询等待事件通过epoll_wait的方式来实现对socket事件的监听,将不断轮询等待高频事件wait与低频socket注册事件两个操作分离开,同时会对监听就绪的socket事件添加到就绪队列中,也就保证唤醒轮询的事件都是具备可读的,现对epoll技术分析如下:</p>
<blockquote>
<p>epoll技术定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建保存epoll文件描述符的空间,该空间也称为“epoll例程”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;    <span class="comment">// 使用链表,现在已经弃用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;    <span class="comment">// 使用红黑树的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll注册/修改/删除 fd的操作</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,                        <span class="comment">// 上述epoll空间的fd索引值</span></span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> op,                         <span class="comment">// 操作识别，EPOLL_CTL_ADD |  EPOLL_CTL_MOD  |  EPOLL_CTL_DEL</span></span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> fd,                          <span class="comment">// 注册的fd</span></span></span></span><br><span class="line"><span class="params"><span class="function">               struct epoll_event *event)</span></span>;      <span class="comment">// epoll监听事件的变化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="keyword">__poll_t</span> events;</span><br><span class="line">	__u64 data;</span><br><span class="line">&#125; EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll等待，与select/poll的逻辑一致</span></span><br><span class="line">epoll_wait(<span class="keyword">int</span> epfd,                            <span class="comment">// epoll空间</span></span><br><span class="line">           struct epoll_event *events,           <span class="comment">// epoll监听事件的变化</span></span><br><span class="line">           <span class="keyword">int</span> maxevents,                        <span class="comment">// epoll可以保存的最大事件数</span></span><br><span class="line">        <span class="keyword">int</span> timeout);                         <span class="comment">// 超时时间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>epoll技术实现细节</p>
</blockquote>
<ul>
<li>epoll_ctl函数处理socket描述符fd注册问题,关注epoll_ctl的ADD方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘取核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *epds,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">bool</span> nonblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在红黑树中查找存储file对应的epitem，添加的时候会将epitem加到红黑树节点中</span></span><br><span class="line">	epi = ep_find(ep, tf.file, fd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对于EPOLL_CTL_ADD模式,使用mtx加锁添加到wakeup队列中</span></span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">	    <span class="comment">// fd注册操作</span></span><br><span class="line">		<span class="comment">// epds-&gt;events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line">		<span class="comment">// error = ep_insert(ep, epds, tf.file, fd, full_check);</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">	    <span class="comment">// // 删除操作：存储epitem容器移除epitem信息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 对注册的fd进行修改,但epoll的模式为EPOLLEXCLUSIVE是无法进行操作的</span></span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">	    <span class="comment">// 修改操作,内核监听到事件变化执行修改</span></span><br><span class="line">            <span class="comment">//error = ep_modify(ep, epi, epds);			</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放资源逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>EPOLL_CTL_ADD核心代码逻辑</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, <span class="keyword">const</span> struct epoll_event *event,</span></span></span><br><span class="line"><span class="params"><span class="function">		     struct file *tfile, <span class="keyword">int</span> fd, <span class="keyword">int</span> full_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将fd包装在epitem的epollfile中</span></span><br><span class="line">	epi-&gt;ep = ep;</span><br><span class="line">	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	epi-&gt;event = *event;</span><br><span class="line">	epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">	epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果当前监听到事件变化，那么创建wakeup执行的source</span></span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">		error = ep_create_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> error_create_wakeup_source;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化回调函数并与当前的epitem进行绑定添并将callback添加到poll table中，每一个epitem都有对应的callback，并添加到等待队列ep_pqueue</span></span><br><span class="line">	<span class="comment">// 注意这里每次添加fd都会有对应的epitem以及ep_pqueue，而一个ep_pqueue与一个callback进行绑定</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 轮询检测epitem中的事件，在内部会对epoll空间的ready list进行扫描，会触发执行回调函数并将已经唤醒就绪的fdset从epoll空间中拷贝到</span></span><br><span class="line">       <span class="comment">// epitem中的ready_list</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将epitem插入到红黑树中	</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有ready_list 则执行唤醒逻辑wakeup，这个是linux内核的唤醒机制，会将read_process添加到就绪队列中让cpu调度执行</span></span><br><span class="line">	<span class="keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存在预唤醒，则唤醒轮询等待节点</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">	    ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goto statement code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述的代码中存在两个核心逻辑(注册&amp;唤醒逻辑)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 队列回调添加注册逻辑 ep_ptable_queue_proc</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,</span><br><span class="line">				 poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">	struct epitem *epi = ep_item_from_epqueue(pt);</span><br><span class="line">	struct eppoll_entry *pwq;</span><br><span class="line"></span><br><span class="line">	if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">		pwq-&gt;whead = whead;</span><br><span class="line">		pwq-&gt;base = epi;</span><br><span class="line">		if (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		else</span><br><span class="line">			add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">		epi-&gt;nwait++;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* We have to signal that an error occurred */</span><br><span class="line">		epi-&gt;nwait = -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> locked;</span><br><span class="line"></span><br><span class="line">	pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">		<span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">	ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">	poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">	locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">				  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">				  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll_wait还有这个方法</span></span><br><span class="line"><span class="comment">// 执行ep_ptable_queue_proc队列回调函数</span></span><br><span class="line">p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ep_read_events_proc:监控ep空间事件是否可读的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_read_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="keyword">int</span> depth = *(<span class="keyword">int</span> *)priv;</span><br><span class="line"></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line">	depth++;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ep_item_poll(epi, &amp;pt, depth)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EPOLLIN | EPOLLRDNORM;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Item has been dropped into the ready list by the poll</span></span><br><span class="line"><span class="comment">			 * callback, but it&#x27;s not actually ready, as far as</span></span><br><span class="line"><span class="comment">			 * caller requested events goes. We can remove it here.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			__pm_relax(ep_wakeup_source(epi));</span><br><span class="line">			list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">__poll_t</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="params"><span class="function">					   struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">void</span> *priv, <span class="keyword">int</span> depth, <span class="keyword">bool</span> ep_locked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__poll_t</span> res;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">	LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">	 * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="comment">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="comment">	 * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="comment">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="comment">	 * because we want the &quot;sproc&quot; callback to be able to do it</span></span><br><span class="line"><span class="comment">	 * in a lockless way.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, <span class="literal">NULL</span>);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now call the callback function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * During the time we spent inside the &quot;sproc&quot; callback, some</span></span><br><span class="line"><span class="comment">	 * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="comment">	 * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="comment">		 * During the &quot;sproc&quot; callback execution time, items are</span></span><br><span class="line"><span class="comment">		 * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span></span><br><span class="line"><span class="comment">		 * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * -&gt;ovflist is LIFO, so we have to reverse it in order</span></span><br><span class="line"><span class="comment">			 * to keep in FIFO.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="comment">	 * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="comment">	 * ep-&gt;rdllist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Quickly re-inject items left on &quot;txlist&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">	__pm_relax(ep-&gt;ws);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的epoll_ctl技术代码实现的细节中存在着两个逻辑,即socket描述符注册与唤醒逻辑,主要体现在两个核心方法上,即ep_ptable_queue_proc &amp; ep_item_poll对此分析如下：</p>
</li>
<li><p>注册逻辑：</p>
<ul>
<li>在epoll空间中创建一个epitem的中间层,初始化一系列epitem的属性，同时将新增加的socket描述符包装到epitem下的epoll_filefd中，同时添加唤醒任务wakeup，同时将epitem的内部ep容器指向epoll空间</li>
<li>其次在进行item事件的轮询中，通过队列回调的方式将epitem绑定到队列节点entry上,并在entry节点上绑定epoll的回调函数来唤醒业务处理</li>
<li>最后是将epitem插入以epoll空间为根节点的红黑数中，后续内核可以通过fd查找到对应的epitem，通过epitem也就可以找到epoll空间引用</li>
</ul>
</li>
<li><p>唤醒逻辑：</p>
<ul>
<li>在item事件轮询中，通过轮询检测epoll空间中的等待队列是否有对应的节点entry可读，如果有退出循环，并且从当前注册的epitem开始轮询遍历查询就绪的entry节点并将就绪entry节点的socket描述符添加到ready_list上</li>
<li>其次在上述注册的逻辑之后，会检查当前的epitem的ready list节点,如果存在ready_list,会将epoll空间的等待队列唤醒,让执行处理的read_process添加到就绪队列中，让cpu能够进行调度</li>
</ul>
</li>
<li><p>epoll_wait等待逻辑</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_wait -&gt; do_epoll_wait -&gt; ep_poll, 我们关注核心方法ep_poll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fetch_events: <span class="comment">// 检测epoll是否有事件就绪</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 检测当前ep空间是否有fd事件就绪</span></span><br><span class="line">		eavail = ep_events_available(ep);</span><br><span class="line">		<span class="keyword">if</span> (eavail)</span><br><span class="line">			<span class="comment">// 是的跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 执行休眠方法 schedule()</span></span><br><span class="line">		<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	send_events: <span class="comment">// ep有事件就绪,将event_poll转换到用户空间中</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		ep_send_events(ep, events, maxevents);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上述可以看出等待处理逻辑主要有fetch_event以及send_events,现分析如下：<ul>
<li>循环检查当前epoll空间是否有就绪事件，如果有将跳出循环，如果没有将执行schedule的方法进入休眠等待再次轮询，原理与select/poll一致</li>
<li>其次当有就绪事件的时候,循环遍历将监听变化的事件拷贝到用户空间中,并且会将就绪事件socket添加到epitem的就绪队列ready_list上</li>
</ul>
</li>
</ul>
<blockquote>
<p>最后基于上述的分析做一个分析小结</p>
</blockquote>
<ul>
<li><p>解决大内存且频繁copy问题</p>
<ul>
<li>首先,epoll通过epoll_create创建epoll空间,同时在创建空间的同时将epoll空间拷贝到内存中,此后epoll对socket描述的注册监听通过epoll空间来进行操作,仅一次拷贝</li>
<li>其次,epoll注册将拆分为ADD/MOD/DEL三个操作,分别只对相应的操作进行处理,大大降低频繁调用的次数,相比select/poll机制，由原先高频率的注册等待转换为高频等待，低频注册的处理逻辑</li>
<li>接着,还有一点就是每次注册都通过建立一个epitem结构体对socket相关的fd以及file进行封装，并且epitem的ep容器通过指针引用指向epoll空间,即每次新增加一个socket描述符的时候而是通过单个epitem进行操作，相比fdset较为轻量级</li>
<li>最后,epoll在内核中通过虚拟内存方式将内核空间与用户空间的一块地址同时映射到相同的物理内存地址中，这块内存对用户空间以及内核空间均为可见，因此可以减少用户空间与内核空间之间的数据交换</li>
</ul>
</li>
<li><p>解决只对就绪队列进行唤醒循环遍历</p>
<ul>
<li>首先，我们可以看到在注册的过程中，epoll通过epitem将socket描述符存储到epoll_file中，同时将唤醒逻辑read_process也绑定到epitem，这样当处于唤醒状态就会被触发执行，然后在以当前epitem存储到队列entry节点上，并entry节点绑定回调函数，最后将entry节点添加到ep的等待队列上</li>
<li>其次，在进行wiat等待过程中，内核在执行file.poll()后会将等待队列上的节点添加到轮询等待中poll wait，处于半唤醒状态，也就是当前是就绪状态但还没唤醒，同时会将唤醒的socket描述符添加到epoll空间的ready list中</li>
<li>接着，每当有一个item被唤醒的时候就会退出上述的轮询遍历并持续设置当前的item处于唤醒状态，然后epoll空间开始遍历item（单链表存储）并执行回调函数通知，如果item为就绪状态，就将epoll空间的readylist拷贝到当前唤醒节点的epitem的ready list中</li>
<li>最后，会更新监听变化的事件状态，返回到用户进程，用户进程这个时候获取到ready list中的描述符均为可就绪状态</li>
</ul>
</li>
<li><p>epoll其他技术</p>
<ul>
<li>epoll支持并发执行，上述的休眠与唤醒逻辑都有加锁操作</li>
<li>其次对于就绪状态的ready_list是属于无锁操作，因此为了保证执行并发的安全性在epoll使用的加锁方式全局锁</li>
</ul>
</li>
</ul>
<h6 id="边缘触发与水平触发"><a href="#边缘触发与水平触发" class="headerlink" title="边缘触发与水平触发"></a>边缘触发与水平触发</h6><blockquote>
<p>边缘触发与水平触发定义</p>
</blockquote>
<ul>
<li><p>水平触发</p>
<ul>
<li>socket接收数据的缓冲区不为空的时候，则一直触发读事件，相当于”不断地询问是否数据是否可读”</li>
<li>socket发送数据的缓冲区不全满的时候，则一直触发写事件，相当于”不断地询问是否有区域可以让数据写入”<br>本质上就是一个不断进行交流的过程，如下图所示：<br><img src="http://s1.wailian.download/2020/03/10/level_triggerf57e0e324222c243.jpg" alt="level_triggerf57e0e324222c243.jpg"></li>
</ul>
</li>
<li><p>边缘触发</p>
<ul>
<li>socket接收数据的缓冲区发生变化，则触发读取事件，也就是当空的接收数据的socket缓冲区这个时候有数据传送过来的时候触发</li>
<li>socket发送数据的缓冲区发生变化，则触发写入事件，也就是当满的发送数据的socket缓冲区这个时候刚刷新数据初期的时候触发<br>本质上就是socket缓冲区变化而触发，如下图所示：<br><img src="http://s1.wailian.download/2020/03/10/edage_triigger.jpg" alt="edage_triigger.jpg"></li>
</ul>
</li>
<li><p>上述的触发事件会调用epoll_wait方法，也就是</p>
<ul>
<li>水平触发会多次调用epoll_wait</li>
<li>边缘触发在socket缓冲区中不发生改变那么就不会调用epoll_wait的方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>水平触发与边缘触发代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为水平触发对应标志为EPOLLONESHOT, 边缘触发标志为EPOLLET</span></span><br><span class="line">list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行唤醒逻辑</span></span><br><span class="line">		ws = ep_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (ws) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">				__pm_stay_awake(ep-&gt;ws);</span><br><span class="line">			__pm_relax(ws);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除epitem下的ready_list</span></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新轮询事件收集就绪事件</span></span><br><span class="line">		revents = ep_item_poll(epi, &amp;pt, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!revents)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">		    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">			<span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">				esed-&gt;res = -EFAULT;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		esed-&gt;res++;</span><br><span class="line">		uevent++;</span><br><span class="line">	    </span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">			epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">			 <span class="comment">// 水平触发模式，需要重新添加到ready_list以便于调用epoll_wait的时候能够检查到事件可用</span></span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>水平触发：遍历epoll下的等待队列的每个entry，唤醒entry节点之后从ready_list移除当前socket事件，然后再轮询当前item收集可用的事件，最后添加到ready_list以便于调用epoll_wait的时候能够检查到socket事件可用</li>
<li>边缘触发：遍历epoll下的等待队列的每个entry，唤醒entry节点之后从ready_list移除当前socket事件，再轮询当前item收集可用的事件然后唤醒执行的业务处理read_process</li>
</ul>

    </div>

    <div>全文完。</div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E7%9A%84%E4%BC%91%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-text">Linux内核的休眠与唤醒机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="toc-text">IO复用模型本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">IO复用模型实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#select-%E6%8A%80%E6%9C%AF"><span class="toc-text">select 技术</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#poll-%E6%8A%80%E6%9C%AF"><span class="toc-text">poll 技术</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#epoll%E6%8A%80%E6%9C%AF"><span class="toc-text">epoll技术</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91"><span class="toc-text">边缘触发与水平触发</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <img src="/images/wechat-small.jpg" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div>
  
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/03/06/sync03/" rel="next" title="synchronized的工作原理(三)">
          synchronized的工作原理(三)
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/03/12/sync_used/" rel="prev" title="Java线程synchronized使用">
            Java线程synchronized使用
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://xiaokunliu.github.io">首页</a> |
        <a class="bottom-item" href="https://xiaokunliu.github.io" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/xiaokunliu" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
