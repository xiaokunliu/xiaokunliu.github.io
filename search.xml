<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2020/04/02/linked_revert/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-单向链表实现反转"><a href="#1-单向链表实现反转" class="headerlink" title="1. 单向链表实现反转"></a>1. 单向链表实现反转</h6><blockquote>
<p>java 代码实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SingleLinked.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinked</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span> </span>&#123;</span><br><span class="line">		LinkedNode next;</span><br><span class="line">		<span class="keyword">int</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> LinkedNode head;</span><br><span class="line">	<span class="keyword">private</span> LinkedNode tail;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 链表遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LinkedNode cur = head;</span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">			out.printf(<span class="string">&quot;%d &quot;</span>, cur.item);</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转链表实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LinkedNode prev = <span class="keyword">null</span>;</span><br><span class="line">		LinkedNode next = <span class="keyword">null</span>;</span><br><span class="line">		LinkedNode cur = head;</span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">			next = cur.next;</span><br><span class="line">			cur.next = prev;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = next;</span><br><span class="line">		&#125;</span><br><span class="line">		head = prev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(LinkedNode node)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">			head = node;</span><br><span class="line">			head.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedNode old = head;</span><br><span class="line">		head = node;</span><br><span class="line">		head.next = old;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行main方法测试</span></span><br><span class="line">main()&#123;</span><br><span class="line">		SingleLinked linked = <span class="keyword">new</span> SingleLinked();</span><br><span class="line">		LinkedNode node1 = <span class="keyword">new</span> LinkedNode(<span class="number">1</span>);</span><br><span class="line">		LinkedNode node4 = <span class="keyword">new</span> LinkedNode(<span class="number">4</span>);</span><br><span class="line">        LinkedNode node5 = <span class="keyword">new</span> LinkedNode(<span class="number">5</span>);</span><br><span class="line">        LinkedNode node6 = <span class="keyword">new</span> LinkedNode(<span class="number">6</span>);</span><br><span class="line">        LinkedNode node7 = <span class="keyword">new</span> LinkedNode(<span class="number">7</span>);</span><br><span class="line">        LinkedNode node8 = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>);</span><br><span class="line">        linked.insert(node1);</span><br><span class="line">        linked.insert(node4);</span><br><span class="line">        linked.insert(node5);</span><br><span class="line">        linked.insert(node6);</span><br><span class="line">        linked.insert(node7);</span><br><span class="line">        linked.insert(node8);</span><br><span class="line">        System.out.println(<span class="string">&quot;before reverse&quot;</span>);</span><br><span class="line">        linked.traverse();</span><br><span class="line"></span><br><span class="line">        linked.reverse();</span><br><span class="line">        System.out.println(<span class="string">&quot;after reverse&quot;</span>);</span><br><span class="line">        linked.traverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before reverse</span><br><span class="line">1 4 5 6 7 0 </span><br><span class="line">after reverse</span><br><span class="line">0 7 6 5 4 1 </span><br></pre></td></tr></table></figure>

<h6 id="2-反转算法图解分析"><a href="#2-反转算法图解分析" class="headerlink" title="2. 反转算法图解分析"></a>2. 反转算法图解分析</h6><blockquote>
<p>执行反转的初始化状态代码与图解如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedNode prev = <span class="keyword">null</span>;</span><br><span class="line">LinkedNode next = <span class="keyword">null</span>;</span><br><span class="line">LinkedNode cur = head;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200207215728963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>第一次循环执行的代码与图解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next = cur.next;		<span class="comment">// 1</span></span><br><span class="line">cur.next = prev;		<span class="comment">// 2</span></span><br><span class="line">prev = cur;				<span class="comment">// 3</span></span><br><span class="line">cur = next;				<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200207220216370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>说明:</p>
<ul>
<li>执行1的代码之后,next的指针指向node1</li>
<li>执行2的代码之后,head的next指针指向null</li>
<li>执行3的代码之后,pre的指针指向head</li>
<li>执行4的代码之后current的指针指向node1</li>
</ul>
</li>
<li><p>于是最终结果为<br><img src="https://img-blog.csdnimg.cn/20200207220439761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>最后不断的循环,重复上述的动作,其过程以及最后的结果为:<br><img src="https://img-blog.csdnimg.cn/20200207220704888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200207220916455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>小结</p>
<ul>
<li>上述的算法时间复杂度为O(n),空间复杂度为O(1)</li>
<li>时间复杂度在于while循环,空间复杂度基本没有开辟内存空间,都是用指针引用现有的数据内存区域地址</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表实现反转算法</title>
    <url>/2020/04/02/merge_linked/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-合并两个有序链表实现"><a href="#1-合并两个有序链表实现" class="headerlink" title="1. 合并两个有序链表实现"></a>1. 合并两个有序链表实现</h6><blockquote>
<p>使用递归方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedNode <span class="title">mergeWithRecursive</span><span class="params">(LinkedNode head1, LinkedNode head2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(head1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// head1 &amp; head2 not null</span></span><br><span class="line">	LinkedNode head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(head1.item &lt;= head2.item)&#123;</span><br><span class="line">		head = head1;</span><br><span class="line">		head.next = mergeWithRecursive(head1.next, head2);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		head = head2;</span><br><span class="line">		head.next = mergeWithRecursive(head1, head2.next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用非递归方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedNode <span class="title">mergeSortedLinked</span><span class="params">(LinkedNode head1, LinkedNode head2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head1 == <span class="keyword">null</span>? head2:head1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第一个元素最小值的链表</span></span><br><span class="line">	LinkedNode min_cur = head1.item &lt;= head2.item?head1:head2;</span><br><span class="line">	<span class="comment">// 第一元素较大的链表</span></span><br><span class="line">	LinkedNode max_cur =  min_cur == head1?head2:head1;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 以min_cur为基准,将max_cur合并到min_cur</span></span><br><span class="line">	LinkedNode min_pre = <span class="keyword">null</span>;	<span class="comment">// min_cur的上一个节点</span></span><br><span class="line">	LinkedNode max_next = <span class="keyword">null</span>;	<span class="comment">// max_cur的下一个节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 目标节点</span></span><br><span class="line">	LinkedNode head = min_cur;</span><br><span class="line">	<span class="keyword">while</span>(min_cur != <span class="keyword">null</span> &amp;&amp; max_cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(min_cur.item &lt;= max_cur.item)&#123;</span><br><span class="line">			<span class="comment">// min的节点小于max节点,继续循环遍历</span></span><br><span class="line">			min_pre = min_cur;</span><br><span class="line">			min_cur = min_cur.next;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// 因为以min为基准,因此第一次循环的时候会在上面的if获取到min_pre的值</span></span><br><span class="line">			min_pre.next = max_cur;</span><br><span class="line">			<span class="comment">// 保存max的next节点</span></span><br><span class="line">			max_next = max_cur.next;</span><br><span class="line">			<span class="comment">// 连接到min的节点上,断开当前的max节点,将其的next指向min当前的节点</span></span><br><span class="line">			max_cur.next = min_cur;</span><br><span class="line">			<span class="comment">// min_cur的上一个节点移动到当前的max节点</span></span><br><span class="line">			min_pre = max_cur;</span><br><span class="line">			<span class="comment">// 	循环遍历下一个max的节点</span></span><br><span class="line">			max_cur = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后需要判断下节点,将末尾的所有节点连接起来</span></span><br><span class="line">	prev.next = min_cur == <span class="keyword">null</span>?max_cur:min_cur;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-合并两个链表非递归图解说明"><a href="#2-合并两个链表非递归图解说明" class="headerlink" title="2.合并两个链表非递归图解说明"></a>2.合并两个链表非递归图解说明</h6><blockquote>
<p>初始化状态</p>
</blockquote>
<ul>
<li>代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定min和max节点</span></span><br><span class="line">LinkedNode min_cur = head1.item &lt;= head2.item?head1:head2;</span><br><span class="line">LinkedNode max_cur =  min_cur == head1?head2:head1;</span><br></pre></td></tr></table></figure></li>
<li>其初始化图解如下<br><img src="https://img-blog.csdnimg.cn/20200208132522917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>第一次循环遍历</p>
</blockquote>
<ul>
<li>此时执行的代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(min_cur.item &lt;= max_cur.item)&#123;</span><br><span class="line">	<span class="comment">// min的节点小于max节点,继续循环遍历</span></span><br><span class="line">	min_pre = min_cur;</span><br><span class="line">	min_cur = min_cur.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>图解如下<br><img src="https://img-blog.csdnimg.cn/20200208132836507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>此时min_pre指向min链表中值为1的节点</li>
<li>min_cur,即当前的指针指向min链表中值为2的节点</li>
</ul>
<blockquote>
<p>循环执行到else的语句分析</p>
</blockquote>
<ul>
<li>执行代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为以min为基准,因此第一次循环的时候会在上面的if获取到min_pre的值</span></span><br><span class="line">min_pre.next = max_cur;			<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 保存max的next节点</span></span><br><span class="line">max_next = max_cur.next;		<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 连接到min的节点上,断开当前的max节点,将其的next指向min当前的节点</span></span><br><span class="line">max_cur.next = min_cur;			<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// min_cur的上一个节点移动到当前的min节点</span></span><br><span class="line">min_pre = max_cur;				<span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 	循环遍历下一个max的节点</span></span><br><span class="line">max_cur = next;					<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行代码前的图解<br><img src="https://img-blog.csdnimg.cn/20200208133035167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>执行代码过程图解<br><img src="https://img-blog.csdnimg.cn/20200208141819843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>min_pre此时的指针为<strong>min链表中值为2的节点</strong></p>
</li>
<li><p>执行1的代码之后,min_prev的next指针指向max当前的节点,也就是<strong>值为2的max链表的节点</strong></p>
</li>
<li><p>执行2的代码之后,max_next的指针<strong>指向max当前节点的下一个节点,也就是值为4的节点</strong></p>
</li>
<li><p>执行3的代码之后,max_cur的next指针指向min当前的节点,也就是<strong>min链表中值为5的节点</strong></p>
</li>
<li><p>执行4的代码之后,min_prev的指针指向当前max的节点,也就是<strong>值为2的max链表的节点</strong></p>
</li>
<li><p>执行5的代码之后,<strong>max_cur当前指针指向max值为4的节点</strong></p>
</li>
<li><p>执行代码后的图解<br><img src="https://img-blog.csdnimg.cn/20200208142012862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>根据上述代码以及图解的节点值再执行else代码<br><img src="https://img-blog.csdnimg.cn/20200208142457416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>此时的min_prev的指针<strong>指向max链表值为2的节点</strong></p>
</li>
<li><p>执行1代码之后,min_prev的<strong>next指针指向max_cur节点,也就是值为4的max节点</strong></p>
</li>
<li><p>执行2代码之后,max_next的<strong>指针指向值为6的max节点</strong></p>
</li>
<li><p>执行3代码之后,max_cur当前的<strong>next指针指向当前min_cur的节点,也就是值为5的min节点</strong></p>
</li>
<li><p>执行4代码之后,min_prev的<strong>指针指向当前max的节点,也就是值为4的max节点</strong></p>
</li>
<li><p>执行5代码之后,<strong>max指针指向max_next的节点,也就是当前值为6的max节点</strong><br><img src="https://img-blog.csdnimg.cn/20200208142613319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>此时再次循环,min_cur.item &lt; max_cur.item,执行流程如下</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prev = min_cur; <span class="comment">//1</span></span><br><span class="line">min_cur = min_cur.next; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>执行过程<br><img src="https://img-blog.csdnimg.cn/20200208145218834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>执行结果<br><img src="https://img-blog.csdnimg.cn/20200208145313288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来动作重复上述流程,可以看到<strong>prev 始终跟在min_cur之后</strong>,在经历整个循环之后,说明至少有一个链表已经遍历完成,最后只需要将prev的next节点与剩下的节点连接即可,最后max所有节点都将有序地合并到min中</p>
<ul>
<li>小结:使用的时间复杂度为O(n),空间复杂度为O(1)</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2021/04/13/design/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="建模术语"><a href="#建模术语" class="headerlink" title="建模术语"></a>建模术语</h3><h4 id="面向对象OO方法设计"><a href="#面向对象OO方法设计" class="headerlink" title="面向对象OO方法设计"></a>面向对象OO方法设计</h4><h5 id="微观视野"><a href="#微观视野" class="headerlink" title="微观视野"></a>微观视野</h5><blockquote>
<p>封装</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相对于外部而言，对象隐藏了其私有的属性，提供对外访问的接口抑或是消息通道来与外部建立关系。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聚合</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个独特的对象A和B可以结合在一起形成新的对象C，此时对象C具备A和B的特性总和。</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>arch</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存设计</title>
    <url>/2021/04/19/cache01/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h3><h4 id="响应时间RT-延迟时间DelayTime"><a href="#响应时间RT-延迟时间DelayTime" class="headerlink" title="响应时间RT(延迟时间DelayTime)"></a>响应时间RT(延迟时间DelayTime)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应时间是指系统对用户请求做出响应的时间，与人对软件性能的主观感受是非常一致的，它完整地记录了整个系统处理请求的时间</span><br><span class="line">响应时间 = 客户端界面渲染时间 + 系统响应时间</span><br><span class="line">系统响应时间 = 网络耗时 + 应用耗时</span><br><span class="line"></span><br><span class="line">延迟时间：制定请求耗时落在指定的响应时间范围称为响应延迟时间</span><br></pre></td></tr></table></figure>
<h4 id="吞吐量Throughput"><a href="#吞吐量Throughput" class="headerlink" title="吞吐量Throughput"></a>吞吐量Throughput</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">吞吐量是指系统在单位时间内处理请求的数量</span><br></pre></td></tr></table></figure>

<h4 id="并发用户数Concurrent"><a href="#并发用户数Concurrent" class="headerlink" title="并发用户数Concurrent"></a>并发用户数Concurrent</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并发用户数是指系统可以在某一个时刻能够同时承载的正常使用系统功能的用户数量</span><br></pre></td></tr></table></figure>

<h4 id="资源利用率ResUtilization"><a href="#资源利用率ResUtilization" class="headerlink" title="资源利用率ResUtilization"></a>资源利用率ResUtilization</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU/内存/负载/网络IO/磁盘IO/存储空间...</span><br></pre></td></tr></table></figure>

<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><h4 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h4><blockquote>
<p>浏览器HTTP设置缓存</p>
</blockquote>
<ul>
<li>Expires的HTTP头来告诉客户端在重新请求文件之前缓存多久是安全的，可以通过if-modified-since的条件请求来使用缓存</li>
<li>服务器可以用304-NotModified来应答。客户端收到304代码，就可以使用缓存的文件版本</li>
<li>Last-Modified/ETag配置，浏览器再次访问统一URI的资源时，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，浏览器则直接从本地缓存取数据；如果数据有变化，就将整个数据重新发给浏览器</li>
<li>Last-Modified/ETag与Cache-Control/Expires的作用是不一样的，如果检测到本地的缓存还在有效的时间范围内，浏览器则直接使用本地缓存，不会发送任何请求。</li>
<li>两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识ETag</li>
<li>Cache-Control与Expires的功能一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li>
<li>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间，当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用服务端的返回码304，从而减少响应开销</li>
<li>无缓存，在HTML页面的节点中加入meta标签，可以告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>APP缓存</p>
</blockquote>
<ul>
<li>APP可以将内容缓存在内存、文件或本地数据库（例如SQLite）中，但基于内存的缓存要谨慎使用，同时要留心数据库缓存的清理机制</li>
<li>采用文件缓存，这种方法使用文件操作的相关API得到文件的最后修改时间，与当前时间判断是否过期，从而实现缓存效果，操作简单，代价较低。需要注意的是，不同类型文件的缓存时间不一样</li>
</ul>
<h4 id="网络缓存"><a href="#网络缓存" class="headerlink" title="网络缓存"></a>网络缓存</h4><blockquote>
<p>web代理缓存(正向代理)</p>
</blockquote>
<p><img src="../../../zimages/cache/cache01/01.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Web代理缓存的作用跟浏览器的内置缓存类似，只是介于浏览器和互联网之间</span><br></pre></td></tr></table></figure>

<ul>
<li>Squid<br><img src="../../../zimages/cache/cache01/02.png"></li>
</ul>
<blockquote>
<p>边缘缓存</p>
</blockquote>
<ul>
<li><p>Web反向代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用Web反向代理服务器和使用正向代理服务器一样，可以拥有缓存的作用，反向代理缓存可以缓存原始资源服务器的资源，</span><br><span class="line">而不是每次都要向原始资源服务器请求数据，特别是一些静态的数据，比如图片和文件，很多Web服务器就具备反向代理的功能</span><br></pre></td></tr></table></figure>
</li>
<li><p>Varnish</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果这些反向代理服务器能够做到和用户来自同一个网络，那么用户访问反向代理服务器，就会得到很高质量的响应速度，所以可以将这样的反向代理缓存称为边缘缓存</span><br><span class="line">边缘缓存在网络上位于靠近用户的一侧，可以处理来自不同用户的请求，主要用于向用户提供静态的内容，以减少应用服务器的介入。</span><br><span class="line">边缘缓存的一个有名的开源工具就是Varnish，在默认情况下进行保守缓存。也就是说，Varnish只缓存它所知的安全内容。</span><br><span class="line">Varnish的一个特性是使用虚拟内存，精妙之处在于利用了操作系统的管理机制</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="../../../zimages/cache/cache01/03.jpeg"></p>
<ul>
<li>商业化CDN</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过HTTP响应头中的Cache-control: max-age的字段来设置CDN边缘节点的数据缓存时间。</span><br><span class="line">当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；</span><br><span class="line">否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端</span><br></pre></td></tr></table></figure>

<p><img src="../../../zimages/cache/cache01/04.jpeg"></p>
<h4 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h4><blockquote>
<p>数据库缓存</p>
</blockquote>
<ul>
<li>查询缓存</li>
</ul>
<blockquote>
<p>平台级缓存</p>
</blockquote>
<blockquote>
<p>应用级缓存</p>
</blockquote>
<h3 id="缓存部署方式"><a href="#缓存部署方式" class="headerlink" title="缓存部署方式"></a>缓存部署方式</h3><h4 id="单体缓存"><a href="#单体缓存" class="headerlink" title="单体缓存"></a>单体缓存</h4><h4 id="缓存集群"><a href="#缓存集群" class="headerlink" title="缓存集群"></a>缓存集群</h4><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h3 id="缓存案例设计"><a href="#缓存案例设计" class="headerlink" title="缓存案例设计"></a>缓存案例设计</h3>]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>缓存设计</tag>
      </tags>
  </entry>
  <entry>
    <title>基于AQS原理实现的锁</title>
    <url>/2020/01/02/aqs/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-AQS概念及其组件"><a href="#1-AQS概念及其组件" class="headerlink" title="1. AQS概念及其组件"></a>1. AQS概念及其组件</h6><blockquote>
<p>AQS基础概念及其作用</p>
</blockquote>
<ul>
<li><p>AQS基础概念</p>
<ul>
<li>AQS: 即抽象队列同步器,AbstractQueuedSynchronizer</li>
<li>AQS之shared mode: 即共享锁/读锁,用于线程读取加锁,不能进行写操作,可以读读共享</li>
<li>AQS之exclusive mode: 即独占锁/排他锁/写锁,用于线程原子写操作时加锁,只能一个线程持有,其他线程处于等待状态</li>
<li>AQS中不同mode的线程共享相同的等待队列wait queue,也就是在同一个阻塞队列中,线程持有的mode可能会不同</li>
<li>state属性: 作为AQS的同步状态信息属性,state具备线程安全特性(valatile &amp; CAS分别保证可见性和原子性)</li>
</ul>
</li>
<li><p>AQS主要作用</p>
<ul>
<li>提供一个基于FIFO等待队列的阻塞锁和相关同步器的模板框架,即AQS</li>
<li>对于阻塞锁和同步器的实现子类,必须定义一个非对外访问的<code>helper class</code>来继承AQS,利用AQS中受保护的方法来为阻塞锁和同步器对外暴露的方法提供服务</li>
<li>继承AQS的同步器子类将通过模板框架提供的CAS操作state方式来保证原子性,以及volatile修饰保证可见性,这样能够实时知道当前对象获取锁或者释放锁所处的状态信息</li>
<li>一般情况下,子类只会实现上述两种mode之一,但是对于ReadWriteLock具备上述两种mode,这也就是ReadWriteLock具备读写锁的特征</li>
<li>AQS内部定义一个实现Condition接口的实现内部类ConditionObject,主要作用是<strong>结合独占模式下的方法一同使用,也就是说在并发线程持有相同的独占锁情况下,独占资源下的方法可以结合Condition下的唤醒与挂起线程的方式完成线程之间的通信</strong>(独占资源方法有, 比如isHeldExclusively判断当前线程是否持有独占锁, release释放独占锁, acquire获取独占锁)</li>
</ul>
</li>
</ul>
<blockquote>
<p>AQS包含的组件</p>
</blockquote>
<ul>
<li>Node: 自定义双端链表,实现同步队列等待池,其包含的核心要素有<ul>
<li>指向前一个节点Node的prev</li>
<li>指向后一个节点Node的next</li>
<li>节点所处状态信息,即waiter status</li>
<li>指向下一个处于condition的等待队列的节点nextWaiter</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node 部分代码,在AQS内部中定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); 	<span class="comment">// 表示持有共享锁</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;		<span class="comment">// 持有独占锁</span></span><br><span class="line">	<span class="comment">// waiter status,即节点所处的阻塞状态列表如下</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;		<span class="comment">// 被取消,意味着放弃竞争锁资源,移出阻塞队列</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;		<span class="comment">// 持有锁状态</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;		<span class="comment">// 线程处于条件等待队列中,也就是condition.await让线程挂起</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;		<span class="comment">// 释放锁并正在处于通知其他等待节点可以竞争锁资源的状态</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;	<span class="comment">// 当前节点的状态,初始化为0,不属于上述任何一种状态,属于非阻塞可竞争获取锁的状态</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 实现双端链表</span></span><br><span class="line">	<span class="keyword">volatile</span> Node prev;</span><br><span class="line">	<span class="keyword">volatile</span> Node next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当前节点的线程</span></span><br><span class="line">	<span class="keyword">volatile</span> Thread thread;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 标志当前节点是共享锁还是独占锁,用节点指针引用指向对应的mode</span></span><br><span class="line">	Node nextWaiter;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 独占锁:nextWaiter = null &amp; thread = Thread.currentThread;</span></span><br><span class="line">	<span class="comment">// 共享锁:nextWaiter = SHARED &amp; thread = Thread.currentThread;</span></span><br><span class="line">	<span class="comment">// 不具备上述条件属于正常对象,不持有锁状态</span></span><br><span class="line">	 Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">         <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">         <span class="keyword">this</span>.thread = thread;</span><br><span class="line">     &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否为共享锁的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取上一个节点Node</span></span><br><span class="line">	<span class="function">Node <span class="title">predecessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConditionObject: 自定义接口Condition的实现,业务线程可以创建对应的锁条件来完成线程之间的通信.即线程唤醒与等待,其核心要素如下:<ul>
<li>自定义条件队列,即使拥有属性firstWaiter与lastWaiter</li>
<li>实现接口await/signal/signalAll等方法</li>
<li>ConditionObject内部实现的核心方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConditionObject部分代码,在AQS内部中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义队列的首尾节点,内部自定义队列实现wait queue的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;		<span class="comment">//  调用Thread.interrupt()中断当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;		<span class="comment">// 	直接向当前线程抛出中断异常</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// implements Condition methods ...</span></span><br><span class="line">	<span class="comment">// 调用await,当前线程挂起</span></span><br><span class="line">	await()&#123;&#125;	</span><br><span class="line">	<span class="comment">// 调用signal,当前线程被唤醒	</span></span><br><span class="line">	signal()&#123;&#125;		</span><br><span class="line">	signalAll()&#123;&#125;</span><br><span class="line">	<span class="comment">// 挂起/唤醒超时方法 ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 内部核心方法</span></span><br><span class="line">	<span class="comment">// 添加一个新的节点到当前条件阻塞队列中</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对于已经cancelled的waiter移出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒持有相同的Condition的线程去争抢资源锁,获取到锁并通过CAS设置对应节点的waiter status为SIGNAL</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AQS属性及其依赖<ul>
<li>state,即同步状态,在对应的实现类中表达含义不同,AQS中称为一个同步状态值信息</li>
<li>exclusiveOwnerThread,即当前线程持有独占锁,独占线程</li>
<li>Unsafe,即借助CAS技术来完成同步状态以及等待池队列节点的更新操作等</li>
<li>LockSupport工具类,借助LockSupport来完成线程的加锁与解锁操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 自定义实现双向FIFO的队列, 定义队列的head &amp; tail</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;				<span class="comment">// 当前AQS同步状态信息,具体实现类含义可能不一样</span></span><br><span class="line">	<span class="comment">// CAS操作上述的state,head&amp;tail, waitstuts</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 除了获取/释放锁之外,内部定义核心方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;&#125;	<span class="comment">// 	将Node插入队列</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;&#125;	<span class="comment">//  创建想要持有mode的锁方式的Node并将其添加到阻塞队列中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 内部实现的独占锁方式</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;&#125;	<span class="comment">// 获取独占锁,失败则挂起</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;&#125;	<span class="comment">// 唤醒当前Node的下一个节点的线程</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 内部实现共享锁</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;&#125;			<span class="comment">// 唤醒下一个节点的线程并通知其他节点的线程已经释放锁</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;&#125;	<span class="comment">// 如果获取锁失败则挂起线程,成功则持有锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>AQS的类图明细<br><img src="https://img-blog.csdnimg.cn/20200204152205143.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>AQS的使用,也就是子类继承AQS之后,根据需要重写AQS中定义的<code>protected</code>方法,从上述类图可以看出:</p>
<ul>
<li>tryAcquire: 获取独占锁</li>
<li>tryRelease: 释放独占锁</li>
<li>isHeldExclusively: 判断当前线程是否持有独占锁</li>
<li>tryAcquireShared: 获取共享锁</li>
<li>tryReleaseShared: 释放共享锁</li>
<li>操作和获取属性state的getState()以及CAS修改state的方法</li>
<li>操作线程独占方法get&amp;set方法</li>
<li>如果锁需要Condition,则可以直接使用ConditionObject来实现对应的分类锁逻辑实现线程通信(可选)</li>
</ul>
</li>
</ul>
<h6 id="2-AQS-工作原理"><a href="#2-AQS-工作原理" class="headerlink" title="2.AQS 工作原理"></a>2.AQS 工作原理</h6><blockquote>
<p>AQS 核心组成</p>
</blockquote>
<ul>
<li><p>内部核心主体</p>
<ul>
<li>state: AQS中表达为一个同步状态信息,具体实现类含义不一样,比如CountDownLatch的state表示计数器</li>
<li>exclusiveOwnerThread:独占线程对象</li>
<li>双向队列等待池(Node head &amp; Node tail): 基于内部类属性成员的链表head以及链表tail</li>
</ul>
</li>
<li><p>内部核心接口</p>
<ul>
<li>独占资源接口,设置为独占锁<ul>
<li>模板方法: acquire/release</li>
<li>具体实现方法: tryAcquire/tryRelease, </li>
</ul>
</li>
<li>共享资源接口,设置为共享锁<ul>
<li>模板方法: acquireShared/releaseShared, </li>
<li>具体实现方法: tryAcquireShared/tryReleaseShared</li>
</ul>
</li>
<li> acquire/acquireShared定义资源争用逻辑,没有拿到则加入队列等待池中等待</li>
<li> tryAcquire/tryAcquireShared实际执行占用资源的操作,交由具体实现的AQS完成</li>
<li>release/releaseShared定义释放资源的逻辑,释放之后通知等待池中的节点进行争抢</li>
<li>tryRelease/tryReleaseShared实际释放资源的操作,由具体实现的AQS完成</li>
</ul>
</li>
<li><p>AQS 加解锁核心代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">         Node h = head;</span><br><span class="line">         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">             unparkSuccessor(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享锁</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化阻塞队列方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize, 可以看到初始化的head不持有锁,属于正常状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">   Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AQS 加锁与解锁的流程</p>
</blockquote>
<ul>
<li>共享锁加锁<br><img src="https://img-blog.csdnimg.cn/20200204222436498.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>共享锁解锁<br><img src="https://img-blog.csdnimg.cn/20200204211918409.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>独占锁加锁<br><img src="https://img-blog.csdnimg.cn/20200204215201519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>独占锁解锁<br><img src="https://img-blog.csdnimg.cn/20200204220132343.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>根据上述流程总结如下<ul>
<li>AQS中加锁以及解锁的过程中是根据wait status来判断是否进行加锁和释放锁,wait status可理解为AQS中的“锁”,通过CAS更新wait status的状态来实现加锁和解锁,同时为了防止并发多线程再次修改,针对已经恢复正常的节点信息,通过<code>PROPAGATE</code>来控制,也就是拥有这个状态的wait status说明已经释放锁并唤醒其他线程争抢锁</li>
<li>AQS中通过链表的方式实现双向队列的操作,同时为了避免并发造成存储在链表中的节点顺序错乱,于是通过CAS的方式来设置链表的head和tail,保证修改的安全性</li>
<li>AQS中区分mode在于存储节点的nextWaiter的指向,在AQS中,共享锁和独占锁在加锁过程中,共享锁加锁后需要唤醒下一个mode为SHARED的阻塞节点线程,而独占锁不需要;在共享锁和独占锁解锁过程中,共享锁为了避免并发线程多次更新,于是通过<code>PROPAGATE</code>来控制,告知节点已经释放锁并通知其他线程</li>
<li>可以看到,加锁和解锁可以通过走“捷径”的方式来完成,也就是对应的AQS实现相应的加锁和解锁处理逻辑</li>
<li>总结,<strong>加锁流程:当前节点先加入阻塞队列,CAS自旋获取锁,成功则删除当前节点(重置为head);解锁流程就是从阻塞队列中获取下一个阻塞节点,并唤醒当前节点的线程</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>AQS 原理总结</p>
</blockquote>
<ul>
<li><p>AQS的核心组成部分</p>
<ul>
<li>具备线程安全的双向阻塞队列</li>
<li>具备线程安全的独占线程</li>
<li>具备线程安全的状态state属性</li>
</ul>
</li>
<li><p>基于上述的组成部分自定义AQS伪代码实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefineAQS.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefineAQS</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SHARED = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> EXCLUSIVE = -<span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mode;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AQSNode</span><span class="params">(<span class="keyword">int</span> mode)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">this</span>.mode = mode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; exclusiveOwnerThread = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;AQSNode&gt; waiters = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AtomicInteger <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> AtomicInteger(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state.compareAndSet(expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加入阻塞队列中</span></span><br><span class="line">        AQSNode node = <span class="keyword">new</span> AQSNode(AQSNode.EXCLUSIVE);</span><br><span class="line">        waiters.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!tryAcquire(arg))&#123;</span><br><span class="line">            LockSupport.park(node.getThread());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程已经获取到锁，移出阻塞队列，通知后续节点</span></span><br><span class="line">        waiters.remove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                AQSNode node = waiters.peek();</span><br><span class="line">                <span class="keyword">if</span> (node.getMode() == AQSNode.EXCLUSIVE)&#123;</span><br><span class="line">                    LockSupport.unpark(node.getThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        AQSNode node = <span class="keyword">new</span> AQSNode(AQSNode.SHARED);</span><br><span class="line">        waiters.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            LockSupport.park(node.getThread());</span><br><span class="line">        &#125;</span><br><span class="line">        waiters.remove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                AQSNode node = waiters.peek();</span><br><span class="line">                <span class="keyword">if</span> (node.getMode() == AQSNode.SHARED)&#123;</span><br><span class="line">                    LockSupport.unpark(node.getThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// abstract method for tryXXX </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发原子性技术之CAS机制</title>
    <url>/2020/01/04/cas/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-CAS机制"><a href="#1-CAS机制" class="headerlink" title="1. CAS机制"></a>1. CAS机制</h6><blockquote>
<p>CAS定义</p>
</blockquote>
<ul>
<li>从wiki百科中,Compare-and-swap简称为“CAS”,是属于并发多线程中实现同步原子操作的指令,是依赖于硬件层次的原语发起的原子操作</li>
<li>从程序代码理解上,CAS包含<code>check then act</code>的两个动作,这两个动作在处硬件的处理器上是具备原子性,也就是在操作系统底层上已经实现对CAS算法的原子性保证</li>
</ul>
<blockquote>
<p>CAS 使用条件</p>
</blockquote>
<ul>
<li>需要输入两个数值,一个是期望修改前的值(旧值),一个是需要被设置的新值(新值)</li>
<li>进行CAS操作需要进行对预期值的check操作</li>
</ul>
<blockquote>
<p>CAS之java简易版本</p>
</blockquote>
<ul>
<li><p>通过CAS设置新值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的check方式完成对象新值的设置</span></span><br><span class="line"><span class="comment">// cas.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(Object ref, <span class="keyword">int</span> refOldVal, <span class="keyword">int</span> refNewVal)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ref.value != refOldVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	ref.value = refNewVal;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CAS实现加法设置器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cas_adder.java</span></span><br><span class="line"><span class="comment">// import cas.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cas_adder</span><span class="params">(Object ref, <span class="keyword">int</span> incr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!cas(ref, ref.value, ref.value+incr))&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 表示修改成功</span></span><br><span class="line">	<span class="keyword">return</span> ref.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2-Java之CAS实现原理UnSafe"><a href="#2-Java之CAS实现原理UnSafe" class="headerlink" title="2. Java之CAS实现原理UnSafe"></a>2. Java之CAS实现原理UnSafe</h6><blockquote>
<p>java原子操作类Atomic*实现</p>
</blockquote>
<ul>
<li>比如AtomicBoolean的实现源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicBoolean.java 摘取核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBoolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4654671469794556979L</span>;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="comment">// 使用volatile修饰,保证修改的可见性,令当前的线程缓存失效,读取主内存修改后的数据</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;		</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前属性value的内存地址偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicBoolean.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用unsafe的CAS方法完成修改操作</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于UnSafe实现自定义的CAS操作(依样画葫芦)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicDefineInt.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDefineInt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">// 定义内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> iValueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 必须通过反射获取Unsafe,本身是属于不安全的一个操作,直接通过getUnsafe会抛出异常,</span></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 从JNI中获取value属性在堆内存中的地址偏移量</span></span><br><span class="line">            iValueOffset = unsafe.objectFieldOffset(AtomicDefineInt.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 借助UnSafe调用CAS方法完成操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, iValueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Unsafe源码以及实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 字段属性theUnsafe</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();</span><br><span class="line">        <span class="comment">// 只允许jvm调用,java程序无法直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// compareAndSwapInt的修改方法为native</span></span><br><span class="line">	<span class="comment">// 表示在线程的虚拟机栈中加载调用方法,由c++底层源码实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c++代码</span></span><br><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line"><span class="comment">// 获取内存偏移量</span></span><br><span class="line">UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset0(JNIEnv *env, jobject unsafe, jobject field)) &#123;</span><br><span class="line">  <span class="keyword">return</span> find_field_offset(field, <span class="number">0</span>, THREAD);</span><br><span class="line">&#125; UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成CAS操作</span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;</span><br><span class="line">  <span class="comment">// JNI解析加载java object</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="keyword">if</span> (p == NULL) &#123;</span><br><span class="line">  	<span class="comment">// 如果p不是java中定义的面向对象引用,直接从内存地址完成修改操作</span></span><br><span class="line">    <span class="keyword">volatile</span> jint* addr = (<span class="keyword">volatile</span> jint*)index_oop_from_field_offset_long(p, offset);</span><br><span class="line">    <span class="keyword">return</span> RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x) == e;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	<span class="comment">// 如果p是java对象,直接在堆内存中对p的属性数据进行修改操作</span></span><br><span class="line">    assert_field_offset_sane(p, offset);</span><br><span class="line">    <span class="keyword">return</span> HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析<ul>
<li>从上述可知,java底层CAS实现机制是通过JNI环境来调用c++的实现</li>
<li>底层实现一类是根据是否为java对象类型来直接在堆内存中完成CAS操作,而另一种是针对非java对象类型则直接从内存地址中完成对应的CAS操作</li>
</ul>
</li>
<li>UnSafe的实现中可以看出,需要在java中使用UnSafe需要以下条件<ul>
<li>必须要有一个对象的属性在内存的偏移量valueOffset</li>
<li>其次需要传递对应的java对象p</li>
<li>同时还需要有修改前期望的数值以及要设置修改的值</li>
<li>另外在java代码中使用volatile保证数据是刷新到内存的,因为JNI是调用c++实现是直接操作堆内存的,那么我们需要在并发多线程下保证读是可见的,写是最新的</li>
</ul>
</li>
</ul>
<h6 id="3-CAS存在的问题"><a href="#3-CAS存在的问题" class="headerlink" title="3. CAS存在的问题"></a>3. CAS存在的问题</h6><blockquote>
<p>CAS问题</p>
</blockquote>
<ul>
<li>在上述的CAS实现代码中,对于做一些自增或是自减等数学运算操作时,会产生自旋判断,容易造成CPU性能下降</li>
<li>在CAS操作仅针对单个变量,如果涉及多个变量的原子操作,CAS是无法保证原子性</li>
<li>最后一个就是ABA问题</li>
</ul>
<blockquote>
<p>ABA问题</p>
</blockquote>
<ul>
<li>java源码示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicDefineObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDefineObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 反射获取</span></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicDefineObject.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(String expect, String update)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compareAndSet(<span class="keyword">this</span>.value, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对应执行的main方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">		<span class="keyword">final</span> AtomicDefineObject atomicDefineObject = <span class="keyword">new</span> AtomicDefineObject();</span><br><span class="line">        atomicDefineObject.setValue(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; --- set value to A----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;thread1&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 完成写操作需要1s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">                    atomicDefineObject.setValue(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; --- set value to B----&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;thread2&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 完成写操作需要2s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">                    atomicDefineObject.setValue(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot; --- set value to A----&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="string">&quot;thread3&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="comment">// 由于网路原因，读取操作延迟</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">3L</span>);</span><br><span class="line">                   String val = atomicDefineObject.getValue();</span><br><span class="line">                   System.out.println(Thread.currentThread() + <span class="string">&quot; --- get value ----&quot;</span> + val);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// start &amp;&amp; join</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[main,5,main] --- set value to A----</span><br><span class="line">Thread[thread1,5,main] --- set value to B----</span><br><span class="line">Thread[thread2,5,main] --- set value to A----</span><br><span class="line">Thread[thread3,5,main] --- get value ----A</span><br><span class="line">finish task dome ...</span><br><span class="line"></span><br><span class="line">## 最终读线程读取到的数据是A,但是不知道之前对象已经发生过修改操作,对当前读操作是一个透明</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ABA解决方案</p>
</blockquote>
<ul>
<li>为ABA问题增加版本号,版本号的值设置为long类型的自增加方式,这样程序就知道共享资源数据的变更情况</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200128210626898.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>java提供的一个支持类AtomicStampedReference,通过增加时间戳方式来记录修改的时候对应的时间戳,这样的方式便可以知道当前的数据最近修改的时间段</p>
</li>
<li><p>ABA技术解决的意义</p>
<ul>
<li>通过知道数据对象变化的情况,我们可以利用版本或者时间戳的方式记录修改的变更日志,方便逻辑业务排查</li>
<li>同时知道变更的时间或者是版本号,可以利用最新的一个数据值来作为一个起点修复过程,比如我们应用在某一个时间点down掉,如果此时更新应用的数据存在ABA问题,那么可以结合实际场景来进行恢复</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU高速缓存与内存屏障</title>
    <url>/2020/01/12/cpu_cache/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="1-CPU缓存"><a href="#1-CPU缓存" class="headerlink" title="1. CPU缓存"></a>1. CPU缓存</h5><blockquote>
<p>cpu高速缓存的由来</p>
</blockquote>
<ul>
<li>在CPU的全部取指令周期中(程序计算),至少需要访问一次存储器(也就是我们所说物理内存上的数据)</li>
<li>通常需要多次访问存储器的取操作数或者保存结果,CPU处理计算的速度明显受限于访问存储器的限制</li>
<li>因此解决方案就是利用局部性原理,在CPU与物理内存之间提供一个容量小并且速度快的存储器,称为高速缓存<blockquote>
<p>高速缓存概述</p>
</blockquote>
</li>
<li>缓存是分“段”（line）的，一个段对应一块存储空间，大小是 32（较早的 ARM、90 年代 /2000 年代早期的 x86 和 PowerPC）、64（较新的 ARM 和 x86）或 128（较新的 Power ISA 机器）字节</li>
<li>高速缓存包含物理内存部分数据副本</li>
<li>cpu读取数据时将会先检查高速缓存中的数据是否存在,存在就返回,不存在就读取物理内存数据</li>
</ul>
<blockquote>
<p>高速缓存和内存</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VzZXItZ29sZC1jZG4ueGl0dS5pby8yMDIwLzEvOS8xNmY4OTk1ZTZjYWFkMDNj?x-oss-process=image/format,png" alt="高速缓存与内存.jpg"></p>
<blockquote>
<p>高速缓存分为L1-L3 Cache</p>
</blockquote>
<ul>
<li>L1 Cache: 一级缓存是CPU第一层高速缓存,分为指令缓存和数据缓存,一般服务器的CPU的L1缓存容量在32-4096kb,现在的L1 Cache都不能直接与内存直连传输数据</li>
<li>L2 Cache: 由于L1级别高速缓存容量的限制,为了再次提高CPU的运算速度,在CPU外部放置一个高速存储器,即二级缓存</li>
<li>L3 Cache: 现在的L3缓存都是内置的,主要是进一步降低内存延迟,提升处理器运算能力,一般是多核共享一个L3缓存</li>
</ul>
<blockquote>
<p>CPU系统架构</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VzZXItZ29sZC1jZG4ueGl0dS5pby8yMDIwLzEvOS8xNmY4OWQ3YzhjMjFlZjhk?x-oss-process=image/format,png" alt="cpu架构图.jpg"></p>
<h5 id="2-缓存一致性与MESI协议"><a href="#2-缓存一致性与MESI协议" class="headerlink" title="2. 缓存一致性与MESI协议"></a>2. 缓存一致性与MESI协议</h5><blockquote>
<p>单CPU缓存的读与写操作</p>
</blockquote>
<ul>
<li><p>缓存读操作</p>
<ul>
<li>CPU读取数据时,先在L1中寻找,再从L2中寻找,再从L3中寻找,然后是内存,最后是外存储器(持久化介质)</li>
<li>如果只处理读取操作,那么不论是L1-L3的缓存,都将会和主内存的数据保持一致</li>
</ul>
</li>
<li><p>缓存写操作</p>
<ul>
<li>缓存直写:直接透过本级缓存,直接将数据写入到下一级缓存或主内存中,写入成功/失败后将对应的缓存内容也执行更新/丢弃操作,这样缓存中的数据与将与主内存数据一致</li>
<li>缓存回写:将修改本级缓存并记录标志段,通过标志段将数据回写到下一级缓存或主内存中,如果标志段被丢弃也将会先进行一次回收,也保证所有级别的缓存数据保持一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>缓存的一致性协议</p>
</blockquote>
<ul>
<li>多核缓存的写操作问题<ul>
<li>场景: 在一个多核且每核都有对应的缓存的处理器进行读写操作</li>
<li>假设有一个CPU缓存了主内存上的某一段数据,在另一个CPU上需要对该内存段的数据进行写操作,此时在写数据的CPU更新了缓存而其他CPU并且更新到缓存,这时候便会产生缓存数据的不一致性</li>
</ul>
</li>
</ul>
<blockquote>
<p>缓存一致性约定</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何解决上述的问题,出现缓存数据不一致的原因如下:</span><br></pre></td></tr></table></figure>
<ul>
<li>多核CPU都有对应的高速缓存,每核缓存的数据都无法共享</li>
<li>这时候我们会想到就是让缓存能够为多核CPU共享,但出现的问题就是处理器运算能力性能会下降,每次都需要等待其中一个CPU进行写操作之后才能够进行下一步的处理</li>
<li>那么我们的期望就是使用多核缓存,同时也能够让它们运作变得像操作一组缓存一样,那么缓存的一致性协议就是为了这一点而设计解决问题的</li>
</ul>
<blockquote>
<p>缓存的MESI协议</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存的一致性协议有很多种,比较典型的就是MESI协议,关于MESI协议简述如下:</span><br></pre></td></tr></table></figure>
<ul>
<li>失效（Invalid）缓存段: 缓存不存在或者已经失效过时</li>
<li>共享（Shared）缓存段: 数据有效,并与主内存以及其他Cache的数据保持一致,用于读缓存操作</li>
<li>独占（Exclusive）缓存段: 数据有效,与主内存的数据保持一致,与S的区别就是在于该处理器处于独占的状态时,其他的cpu缓存将会失效</li>
<li>已修改（Modified）缓存段，属于脏段，表示当前的cpu缓存已经修改过,但是还没有同步到主内存中,为当前的cpu所专有</li>
<li>小结:也就是cpu控制缓存的读写操作,还需要监听其他cpu发生的通知,保证缓存最终数据的一致性</li>
</ul>
<blockquote>
<p>cpu数据读写流程</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VzZXItZ29sZC1jZG4ueGl0dS5pby8yMDIwLzEvOC8xNmY4NWM1NTRmMDgyNDU2?x-oss-process=image/format,png" alt="cpu数据访问.jpg"></p>
<h5 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3. 内存屏障"></a>3. 内存屏障</h5><blockquote>
<p>CPU优化手段:运行时指令重排序</p>
</blockquote>
<ul>
<li><p>为什么会出现指令重排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当CPU写缓存时发现区块正被其他CPU占用,为了提高CPU处理性能,可能将后面的读缓存命令优先执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>指令重排原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重排需要遵循as-if-serial语义规则,即不管怎么进行重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变.编译器/runtime/处理器都必须遵循as-if-serial语义,也就是说编译器和处理器不会对存在数据依赖关系的操作做重排序</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>CPU高速缓存存在的问题</p>
</blockquote>
<ul>
<li>缓存中的数据与主内存的数据并不是实时同步的,各CPU(或CPU核心)间缓存的数据也不是实时同步的,也就是在同一个时间点,各CPU所看到同一个内存地址的数据的值可能是不一致的</li>
<li>指令重排序存在问题,虽然遵循as-if-serial语义,但是仅仅能保证是在单核CPU下单线程自己执行的情况下保证结果是正确的,如果是多核多线程,指令逻辑无法分辨因果关联,可能会出现乱序,导致程序运行结果出现错误.</li>
</ul>
<blockquote>
<p>内存屏障</p>
</blockquote>
<ul>
<li>定义<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是一类同步屏障指令，它使得CPU或编译器在对内存进行操作的时候,严格按照一定的顺序来执行, 也就是说在memory barrier之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序</span><br></pre></td></tr></table></figure></li>
<li>内存屏障指令(大部分处理器)<ul>
<li>写内存屏障,在指令后插入Store Barrier,能让写入缓存中最新的数据更新写入主内存,让其他线程可见.强制写入主内存,这种显示调用,CPU就不会因为性能考虑而去对指令重排</li>
<li>读内存屏障,在指令前插入Load Barrier,可以让高速缓存中的数据失效,强制从新主内存中加载数据读取主内存内容,让CPU缓存与主内存保持一致,避免缓存导致的一致性问题</li>
<li>完全内存屏障,保障了早于屏障的内存读写操作的结果提交到内存之后，再执行晚于屏障的读写操作</li>
</ul>
</li>
<li>存储器的另一套语义<ul>
<li>acquire semantics(读屏障): 该操作结果可利用要早于代码中后续的所有操作的结果。</li>
<li>release semantics(写屏障): 该操作结果可利用要晚于代码中之前的所有操作的结果。</li>
<li>fence semantics(完全屏障): acquire与release两种语义的共同有效。即该操作结果可利用要晚于代码中之前的所有操作的结果，且该操作结果可利用要早于代码中后续的所有操作的结果</li>
</ul>
</li>
<li>作用<ul>
<li>就是解决上述CPU高速缓存存在的问题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之伪共享</title>
    <url>/2020/02/14/false_shared/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-CPU高速缓存与伪共享"><a href="#1-CPU高速缓存与伪共享" class="headerlink" title="1. CPU高速缓存与伪共享"></a>1. CPU高速缓存与伪共享</h6><blockquote>
<p>CPU缓存与一致性</p>
</blockquote>
<p>在<a href="https://blog.csdn.net/wind_602/article/details/103914263">CPU高速缓存与内存屏障</a>的介绍中,CPU在对数据进行读取的时候遵循缓存一致性来解决高速缓存的数据不一致问题,现简述如下:</p>
<ul>
<li>CPU高速缓存包含L1-L3 Cache缓存,每个缓存Cache都是分段(line)存储的,也就是缓存段(Cache line)</li>
<li>根据缓存的一致性,多核CPU处理器情况下,当其中一个CPU对其所在的Cache进行写操作并通知其他CPU,这时候其他CPU便会令该缓存失效从而去读取主内存上的数据并将连续的变量地址的数据copy到缓存段中</li>
</ul>
<blockquote>
<p>伪共享定义以及产生原因</p>
</blockquote>
<ul>
<li><p>伪共享</p>
<ul>
<li>前提:在多核CPU处理器中,每个CPU都会有对应的缓存数据,并且缓存段缓存连续存储的数据,假设是在多核处理器上有L1和L2缓存,那么此时在L1和L2的缓存段上将会从主内存中拷贝一份连续内存地址的变量数据的一个副本,实现一次读主内存,后续多次读取缓存段的数据,<strong>即CPU高速缓存是针对内存地址连续的数据变量实现一次写,多次读的效果</strong></li>
<li>伪共享情景:当其中一个CPU对一个内存地址不连续的变量数据进行写操作的时候,由于CPU遵循缓存的一致性,那么此时另外的CPU需要对变量数据进行读操作,<strong>由于变量数据内存地址不连续导致读取缓存段中不存在该数据而从主内存中加载,也就是说对数据变量写入缓存段的时候还没有来得及读取就失效了</strong></li>
<li>产生的影响: 伪共享产生的结果就是CPU高速缓存不生效,没有命中缓存,同时缓存的一致性破坏了读取CPU一级缓存的原则,原因是在于并发线程进行写操作的时候会令CPU缓存失效,也会造成伪共享</li>
<li>上述就是一个伪共享的现象,即在CPU多写的情况下,CPU高速缓存对内存地址不连续的数据变量并没有真正起到缓存的作用</li>
</ul>
</li>
<li><p>读取数据伪共享代码演示</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FalseShared.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseShared</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储连续数据，同一行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arr2continuous = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 存储不连续数据，同一列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] arr2notcontinuos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">1024</span>; index ++)&#123;</span><br><span class="line">            arr2continuous[<span class="number">0</span>][index] = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            arr2notcontinuos[index][<span class="number">0</span>] = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByContinuous</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> len = arr2continuous.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; len; row ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; len;  col ++)&#123;</span><br><span class="line">            	<span class="comment">// 读取1数据的时候会先从内存加载并把与1连续的数据也一起加载到缓存,下次读取3的时候是从缓存读取</span></span><br><span class="line">                <span class="keyword">long</span> temp = arr2continuous[row][col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;read arr by continuous with time : &quot;</span>+ (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByNotContinuous</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> len = arr2notcontinuos.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; len; row ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; len;  col ++)&#123;</span><br><span class="line">            	<span class="comment">// 读取1的时候并没有发现有连续数据的,因此只会copy数据1到缓存,也就是下次读取3的时候还要从</span></span><br><span class="line">            	<span class="comment">// 主内存中读取</span></span><br><span class="line">                <span class="keyword">long</span> temp = arr2notcontinuos[col][row];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;read arr by not continuous with time : &quot;</span>+ (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                readByContinuous();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                readByNotContinuous();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## case 1</span><br><span class="line">read arr by continuous with time : 12</span><br><span class="line">read arr by not continuous with time : 24</span><br><span class="line"></span><br><span class="line">## case 2</span><br><span class="line">read arr by continuous with time : 12</span><br><span class="line">read arr by not continuous with time : 19</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代码结果分析</p>
<ul>
<li>在上述演示的代码中,数组存储的数据都一样,区别在于数据分别存储在数据的同一行以及同一列</li>
<li>在程序运行过程中,遍历获取同一列数组的数据执行的时间要慢于同一行的数组</li>
<li>数组存储的数据在同一行上是数据连续的,同一列的数组数据不具备连续性</li>
<li>存储连续性的数据有助于提升程序的执行效率,也就是响应时间</li>
<li>不连续性的数据最终存储在不同的缓存段中</li>
</ul>
</li>
<li><p>结果示意图演示(便于理解)<br><img src="https://img-blog.csdnimg.cn/20200129164400909.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>写数据产生伪共享</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared.java</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write thread</span></span><br><span class="line">run()&#123;</span><br><span class="line">	x = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read thread</span></span><br><span class="line">run()&#123;</span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">	<span class="keyword">int</span> x1 = x;</span><br><span class="line">	<span class="keyword">int</span> temp = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<ul>
<li>根据缓存一致性原则,最后输出的x1必然与x=11的数据一致</li>
<li>说明由于缓存一致性的原则,读取线程最终会去读取主内存更新后的x的数据,读取线程当前的缓存段缓存的x与y(数据内存连续性会缓存在同一个缓存段中)失效,说明这时候的y也是从主内存中读取数据,对于y而言,缓存没有命中,存在伪共享</li>
</ul>
</li>
</ul>
<h6 id="2-java解决伪共享的方案"><a href="#2-java解决伪共享的方案" class="headerlink" title="2. java解决伪共享的方案"></a>2. java解决伪共享的方案</h6><blockquote>
<p>使用<code>@sun.misc.Contended</code>解决伪共享的问题</p>
</blockquote>
<ul>
<li><p>修饰字段属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"> <span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"> <span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"> <span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"> <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"> <span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"> <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"> <span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"> <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"> <span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 表示这个类下的属性内存地址在cache line都具备连续性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方案原理示意图<br><img src="https://img-blog.csdnimg.cn/20200129182306442.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>分析</p>
<ul>
<li>其实就是将不连续的数据变量通过注解的方式将它们存储到缓存段中连续紧密的区域中</li>
<li>按照这个思路,也可以根据实际场景有针对性地对数据进行划分,比如热点数据以及冷数据,即可以根据数据的读写场景情况来分配变量在缓存段的存储位置,这样能够有效地提升CPU利用缓存的特点来提升响应速度</li>
</ul>
</li>
<li><p>参考外链文档代码以及输出字段</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source.java</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">      <span class="keyword">private</span> Object contendedField1;</span><br><span class="line">      <span class="keyword">private</span> Object plainField1;</span><br><span class="line">      <span class="keyword">private</span> Object plainField2;</span><br><span class="line">      <span class="keyword">private</span> Object plainField3;</span><br><span class="line">      <span class="keyword">private</span> Object plainField4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">  TestContended$ContendedTest1: field layout</span><br><span class="line">     @ <span class="number">12</span> --- instance fields start ---</span><br><span class="line">     @ <span class="number">12</span> <span class="string">&quot;plainField1&quot;</span> Ljava.lang.Object;</span><br><span class="line">     @ <span class="number">16</span> <span class="string">&quot;plainField2&quot;</span> Ljava.lang.Object;</span><br><span class="line">     @ <span class="number">20</span> <span class="string">&quot;plainField3&quot;</span> Ljava.lang.Object;</span><br><span class="line">     @ <span class="number">24</span> <span class="string">&quot;plainField4&quot;</span> Ljava.lang.Object;</span><br><span class="line">     @<span class="number">156</span> <span class="string">&quot;contendedField1&quot;</span> Ljava.lang.Object; (contended, group = <span class="number">0</span>)</span><br><span class="line">     @<span class="number">288</span> --- instance fields end ---</span><br><span class="line">     @<span class="number">288</span> --- instance ends ---</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 结果: 将contendedField1与其他字段分配的内存地址区分开,没有放在同一个cache line中(jdk默认cache line是128bit)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用户使用方式<ul>
<li>在对应类或者属性字段添加注解<code>@Contended</code></li>
<li>其次运行的时候需要设置VM参数为<code>-XX:-RestrictContended</code></li>
<li>如果需要设置cache line的宽度,可以通过<code>-XX:-RestrictContended -XX:ContendedPaddingWidth=256</code>设置生效</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考文档</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://dzone.com/articles/what-false-sharing-is-and-how-jvm-prevents-it</span><br><span class="line">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>final线程安全与工作原理</title>
    <url>/2020/02/15/final/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-final语义与使用"><a href="#1-final语义与使用" class="headerlink" title="1.final语义与使用"></a>1.final语义与使用</h6><blockquote>
<p>final的语义</p>
</blockquote>
<ul>
<li><p>编译器做的处理</p>
<ul>
<li>编译器可以跨同步屏障移动对final修饰的字段值进行读取和调用任意或未知的方法</li>
<li>对于final与non-final修饰的字段,允许编译器保存一份final的数据缓存放在寄存器中,对比必须要加载non-final数据的情况下,它不需要从主内存中加载就可以获取​</li>
</ul>
</li>
<li><p>并发线程下是安全的</p>
<ul>
<li>对于final修饰的字段在所有线程中是属于不可变(基本类型值不可变,引用类型是引用地址不可变),也就是对于程序员而言,在线程中重新对final修饰的字段赋值将会编译不通过</li>
<li>只有在对象完全初始化之后，线程才能看到对该对象的引用，这样就可以保证看到该对象的final字段的正确初始化值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于Happen-Before原则,程序任何对象的初始化happen-before于程序中任何其他的动作操作行为</span><br><span class="line">因此能够保证不会被重排序,也就是说final修饰的字段在线程读取已经先在构造器中执行写操作</span><br><span class="line">因而所有线程看到final修饰的变量均为最终最新的版本</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>final的使用模型</p>
<ul>
<li>在对象的构造函数中为对象设置final字段;在对象的构造函数完成之前，不允许在其他线程可以看到的地方对正在构造的对象的引用执行写操作</li>
<li>这样可以保证在线程看到该对象的时候,将始终看到该对象final字段的最终正确构造版本</li>
</ul>
</li>
</ul>
<blockquote>
<p>final的线程安全性</p>
</blockquote>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FinalClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> DefineFinalObject defineFinalObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> FinalClass finalClass;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalClass</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        int x = i;</span></span><br><span class="line"><span class="comment">//        DefineFinalObject var = defineFinalObject;</span></span><br><span class="line">        i = <span class="number">4</span>;</span><br><span class="line">        defineFinalObject = <span class="keyword">new</span> DefineFinalObject();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// code ... may throw exception</span></span><br><span class="line"><span class="comment">//            i = 4;</span></span><br><span class="line"><span class="comment">//            defineFinalObject = new DefineFinalObject();</span></span><br><span class="line">            j = <span class="number">9</span>;</span><br><span class="line">            <span class="comment">// code ...</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        finalClass = <span class="keyword">new</span> FinalClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;have init FinalClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finalClass != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = finalClass.i;</span><br><span class="line">            <span class="keyword">int</span> y = finalClass.j;</span><br><span class="line">            System.out.printf(<span class="string">&quot;get x = %d, and y = %d&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalClass finalClass = <span class="keyword">new</span> FinalClass();</span><br><span class="line">        System.out.println(finalClass.defineFinalObject);</span><br><span class="line">        finalClass.defineFinalObject.setAge(<span class="number">10</span>);</span><br><span class="line">        System.out.println(finalClass.defineFinalObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码分析<ul>
<li>在构造器中,对于final修饰的基本类型/引用类型变量编译器不允许在try中对<code>i=4</code>进行写操作,会出现编译报错,对于没有使用final修饰的变量j进行写操作的<code>j=9</code>则没有出现编译报错</li>
<li>其次,在对<code>i=4</code>执行的写操作之前,编译器不允许对final修饰的基本/引用变量进行读操作,否则编译报错</li>
<li>基于上述编译器的规则,最终保证final的基本类型/引用变量是在其他线程是最终最新的版本,也就是<code>i=4</code>以及<code>defineFinalObject = new DefineFinalObject()</code>创建对象并引用对应的对象地址</li>
<li>在main的线程方法中,可以对不可变的defineFinalObject的属性信息进行修改,说明引用类型不可变是指对应的对象内存地址,即使无法再通过<code>defineFinalObject = new DefineFinalObject()</code>的方式重新指向一个新的引用地址</li>
<li>最后一点就是,final必须是在构造器中完成初始化,同时根据Happen-Before原则,线程访问final的数据一定是在完成初始化后的最终数据且无法再进行修改(引用类型是可以修改其属性信息),从而保证了线程对final修饰的变量是属于线程安全的共享数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>final与static使用分析</p>
</blockquote>
<ul>
<li><p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FinalSharedClass.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalSharedClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DefineFinalObject defineFinalObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//    静态代码块，保证在加载类信息的时候也完成上述静态数据变量的初始化赋值的操作</span></span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        defineFinalObject = <span class="keyword">new</span> DefineFinalObject();</span><br><span class="line">        System.out.printf(<span class="string">&quot;have finished static code for num=%d and obj=%s...\n&quot;</span>, num, defineFinalObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 默认代码块,等同于对象构造器,编译器报错,要么是声明被分配过要么是上述定义的static报没有被分配</span></span><br><span class="line"><span class="comment">//        num = 10;</span></span><br><span class="line"><span class="comment">//        defineFinalObject = new DefineFinalObject();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// final 修饰的无法修改，将会编译报错提示已经分配值操作</span></span><br><span class="line"><span class="comment">//        num = 20;</span></span><br><span class="line"><span class="comment">//        defineFinalObject = new DefineFinalObject();</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        defineFinalObject.setAge(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// must be same with the end of static code</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;read final static num: %d \n&quot;</span>, num);</span><br><span class="line">        System.out.printf(<span class="string">&quot;read final static defineFinalObject: %s \n&quot;</span>, defineFinalObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// may be 0 or 10</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;read static x: %d \n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>静态代码中的final初始化过程必须是在静态代码块中,也就是加载类信息的时候同时完成对final的数据赋予值的操作</li>
<li>在方法writer()中可以看到无法对num以及defineFinalObject再次进行写操作,从而保证线程对于final修饰的数据只能读取,因此并不存在线程安全问题</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>final且非静态的对象变量,final将在对象构造器中完成初始化赋值操作,且不能在构造器之外执行写操作,只能被读取,因而不存在线程安全性问题</li>
<li>final且为静态的类对象变量时,final将会在类的静态代码块中完成初始化(优先于对象构造器执行),且不能在静态代码之外完成初始化操作,由于JVM加载类的信息的时候是优先于创建线程的,因此当线程访问的时候final的static数据已经完成初始化赋值操作,因此也不存在线程安全问题</li>
</ul>
</li>
</ul>
<h6 id="2-final的内存语义与实现"><a href="#2-final的内存语义与实现" class="headerlink" title="2. final的内存语义与实现"></a>2. final的内存语义与实现</h6><blockquote>
<p>final的遵循的规则</p>
</blockquote>
<ul>
<li>对于final领域修饰的非static变量,对象的final领域变量的写操作优先于该对象构造器完成初始化之后的引用赋值操作,即<code>i=4</code>优先于<code>finalClass = new FinalClass();</code>,也就是两个操作不能重排序,final修饰的为引用类型也是一样遵循这个规则</li>
<li>对于final领域修饰的非static变量,对象的final领域变量在构造器初始化的读操作优先于所有线程对该对象的final数据的读操作,也就是构造器执行默认值<code>i 为默认值 0</code>的操作优先于其他线程对<code>i 为 4</code>的读操作,也就是两者不能重排序,同理final修饰的引用变量也是遵循这个规则</li>
<li>另外,对于final修饰且为static的变量,在java程序中静态代码只执行一次,且静态代码完成final领域的数据变量初始化操作优先于所有线程对该变量的读操作,相当于“写一次读多次”,并且写一次是在JVM第一次创建该对象实例的时候加载的,且优先于所有线程的其他行为动作,对此是保证写在前读在后的一个逻辑顺序</li>
</ul>
<blockquote>
<p>final的内存语义是如何实现的</p>
</blockquote>
<ul>
<li><p>aarch架构内存屏障指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A more convenient access to dmb for our purposes</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Membar_mask_bits</span> &#123;</span></span><br><span class="line">    StoreStore = ISHST,</span><br><span class="line">    LoadStore  = ISHLD,</span><br><span class="line">    LoadLoad   = ISHLD,</span><br><span class="line">    StoreLoad  = ISH,</span><br><span class="line">    AnyAny     = ISH</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final语义也是基于内存屏障实现(aarch架构)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// templateTable_aarch64.cpp</span></span><br><span class="line"><span class="comment">// Issue a StoreStore barrier after all stores but before return</span></span><br><span class="line"><span class="comment">// from any constructor for any class with a final field.  We don&#x27;t</span></span><br><span class="line"><span class="comment">// know if this is a finalizer, so we always do so.</span></span><br><span class="line"><span class="keyword">if</span> (_desc-&gt;<span class="built_in">bytecode</span>() == Bytecodes::_return)</span><br><span class="line">  <span class="function">__ <span class="title">membar</span><span class="params">(MacroAssembler::StoreStore)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>根据上述可知,jvm在实现中由于不清楚对象什么时候会调用finalizer方法进行回收,因此会在任何对象的构造器返回前插入内存屏障对final修饰的变量执行写操作</li>
<li>其次,可以看到final插入的内存屏障为StoreStore类型,也就是在构造器返回之前插入StoreStore的内存屏障,也就是说final对变量的写操作的可利用结果在内存屏障之前的代码是不可用的,也就是对<code>final x = 9</code>的写操作之前是看不到<code>x=9</code>的结果</li>
</ul>
</li>
<li><p>volatile与final写操作的内存屏障实现区分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// templateTable_aarch64.cpp</span></span><br><span class="line"><span class="comment">// According to the new Java Memory Model (JMM):</span></span><br><span class="line"><span class="comment">// (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;</span></span><br><span class="line"><span class="comment">//     writes act as aquire &amp; release, so:</span></span><br><span class="line"><span class="comment">// (2) A read cannot let unrelated NON-volatile memory refs that</span></span><br><span class="line"><span class="comment">//     happen after the read float up to before the read.  It&#x27;s OK for</span></span><br><span class="line"><span class="comment">//     non-volatile memory refs that happen before the volatile read to</span></span><br><span class="line"><span class="comment">//     float down below it.</span></span><br><span class="line"><span class="comment">// (3) Similar a volatile write cannot let unrelated NON-volatile</span></span><br><span class="line"><span class="comment">//     memory refs that happen BEFORE the write float down to after the</span></span><br><span class="line"><span class="comment">//     write.  It&#x27;s OK for non-volatile memory refs that happen after the</span></span><br><span class="line"><span class="comment">//     volatile write to float up before it.</span></span><br><span class="line"><span class="comment">// We only put in barriers around volatile refs (they are expensive),</span></span><br><span class="line"><span class="comment">// not _between_ memory refs (that would require us to track the</span></span><br><span class="line"><span class="comment">// flavor of the previous memory refs).  Requirements (2) and (3)</span></span><br><span class="line"><span class="comment">// require some barriers before volatile stores and after volatile</span></span><br><span class="line"><span class="comment">// loads.  These nearly cover requirement (1) but miss the</span></span><br><span class="line"><span class="comment">// volatile-store-volatile-load case.  This final case is placed after</span></span><br><span class="line"><span class="comment">// volatile-stores although it could just as well go before</span></span><br><span class="line"><span class="comment">// volatile-loads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// templateTable_arm.cpp</span></span><br><span class="line"><span class="comment">// StoreLoad barrier after volatile field write</span></span><br><span class="line">  <span class="built_in">volatile_barrier</span>(MacroAssembler::StoreLoad, Rtemp);</span><br><span class="line">  <span class="function">__ <span class="title">b</span><span class="params">(skipMembar)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// StoreStore barrier after final field write</span></span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notVolatile2)</span></span>;</span><br><span class="line">  <span class="built_in">volatile_barrier</span>(MacroAssembler::StoreStore, Rtemp);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>从上面可以看到volatile的写操作内存屏障是使用StoreLoad方式,final使用的内存屏障是StoreStore方式</li>
<li>在aarch64处理器架构中,final也可以使用与volatile相同的内存屏障</li>
</ul>
</li>
<li><p>volatile与final内存屏障伪代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对写操作</span></span><br><span class="line"><span class="comment">// Store为写屏障,作用就是防止重排序,同时让数据刷新到主内存</span></span><br><span class="line"><span class="comment">// Load为读屏障,作用就是使得当前工作线程的缓存失效,直接读取主内存数据,保证数据一致性</span></span><br><span class="line"><span class="comment">// for a volatile write</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//   dmb ish		// store内存屏障		-- 防止重排序</span></span><br><span class="line"><span class="comment">//   str&lt;x&gt;		    // 写volatile数据</span></span><br><span class="line"><span class="comment">//   dmb ish		// load内存屏障		-- 保证数据一致性(目的就是要看见最新的数据)</span></span><br><span class="line"><span class="comment">//   other codes...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for a final write </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   dmb ishst		// store内存屏障		-- 防止重排序</span></span><br><span class="line"><span class="comment">//   final x = 9;	    // 写final数据</span></span><br><span class="line"><span class="comment">//   dmb ishst		// store内存屏障		-- 防止重排序</span></span><br><span class="line"><span class="comment">// other codes ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结果<ul>
<li>可以看到上述描述中使用内存屏障的技术是非常昂贵的,为了适应对应的使用场景,在java中对于volatile与final不能同时存在,同时volatile的使用场景是读写多,而final是一次性写多次读的场景,对此使用的内存屏障技术也会有所不同</li>
<li>final建议使用为StoreStore而不使用与volatile相同的StoreLoad内存屏障是根据使用场景来的,final实现写一次,那么在创建线程的时候工作内存会copy一份相同的数据作为缓存,不需要读取主内存的数据,同时final的写是在构造器中完成,也就是在构造器中添加内存屏障,也保证了在对象构造器之外不能再对final的数据进行修改的操作</li>
<li>同理,对于static的final数据,是在static代码块实现StoreStore内存屏障,作用和对象构造器类似</li>
</ul>
</li>
</ul>
<h6 id="3-final规范小结"><a href="#3-final规范小结" class="headerlink" title="3. final规范小结"></a>3. final规范小结</h6><blockquote>
<p>Java语言规范</p>
</blockquote>
<ul>
<li>final在构造器中执行赋予值的写操作,因此当线程访问的时候会看到当前final修饰的变量为最新版本的数据</li>
<li>如果在构造器函数中执行final变量的读操作在写操作之后,那么会看到final分配给变量的最新数据,不存在缓存读取</li>
<li>读取共享变量里的final数据,则必须先要访问这个共享变量的引用对象然后再读取final数据</li>
<li>通常static final表示为常量,然而System.in/System.err/System.out也是属于static final,是属于遗留的原因,可通过 System.setIn, System.setOut, and System.setErr来完成赋值操作,java规范中称之为“写保护”</li>
<li>对应部分源码说明如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ciField.cpp</span></span><br><span class="line"><span class="comment">// 源码中注释说明</span></span><br><span class="line"><span class="comment">// Is this field a constant?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Clarification: A field is considered constant if:</span></span><br><span class="line"><span class="comment">//   1. The field is both static and final</span></span><br><span class="line"><span class="comment">//   2. The field is not one of the special static/final</span></span><br><span class="line"><span class="comment">//      non-constant fields.  These are java.lang.System.in</span></span><br><span class="line"><span class="comment">//      and java.lang.System.out.  Abomination.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>JMM规范</p>
</blockquote>
<p>使用final修饰的数据在字节码中显示带有<code>ACC_FINAL</code>的访问标识符,对应访问标示符号的值为<code>0x1000</code></p>
<ul>
<li>使用<code>final class XX</code>表明该Class不能被继承,说明该Class没有子类</li>
<li>类的属性字段被声明为final,表明该字段在对象构造器之外不能被分配值操作</li>
<li>JVM规范中,volatile的访问标识与final的访问标识不能同时出现,也就是说在程序代码中不能同时使用final和volatile修饰同一个变量</li>
<li>方法声明为final,表示该方法不能被覆盖重写</li>
<li>内部类使用final修饰的时候,表示在源代码中标记或隐式结束,也就是final修饰的内部类在生成字节码的时候内部类的标识没有被分配，默认值为0，一般情况下在jvm实现中没有检查内部类属性与类文件的一致性</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程面临的问题小结</title>
    <url>/2020/02/28/inshort/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-多线程上下文切换"><a href="#1-多线程上下文切换" class="headerlink" title="1. 多线程上下文切换"></a>1. 多线程上下文切换</h6><blockquote>
<p>上下文切换</p>
</blockquote>
<p>在单核CPU机器下,也可以支持并发多线程执行代码,这个时候CPU会为每一个线程分配对应的时间片,通过在指定的时间片内执行对应的线程程序代码,时间片一到,线程再继续争抢CPU资源重复上述动作</p>
<blockquote>
<p>上下文切换对并发编程的影响</p>
</blockquote>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu_test.java</span></span><br><span class="line"><span class="comment">// 定义业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">100000000000000L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; count; index ++)&#123;</span><br><span class="line">        a += <span class="number">2</span>;</span><br><span class="line">        b -= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前mac机器配置: 4CPU</span></span><br><span class="line"><span class="comment">// 并发:创建6个线程分别执行上述方法一次</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocurrent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">// t1 - t5</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;Thread-1&quot;</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              meth();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">// ... 重复代码省略 ...</span></span><br><span class="line">      meth();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// t1 - t5 start</span></span><br><span class="line">      t1.start();</span><br><span class="line">     <span class="comment">// ... 重复代码省略 ...</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// t1 - t5 join()</span></span><br><span class="line">      t1.join();</span><br><span class="line">      <span class="comment">// ... 重复代码省略 ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">&quot; spend time : &quot;</span> + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 串行:直接调用6次方法</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Thread[main,5,main] spend time : 4</span></span><br><span class="line">     <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">     meth();</span><br><span class="line">     meth();</span><br><span class="line">     meth();</span><br><span class="line">     meth();</span><br><span class="line">     meth();</span><br><span class="line">     meth();</span><br><span class="line">     <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">     System.out.println(Thread.currentThread() + <span class="string">&quot;  spend time : &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>次数(count)</th>
<th>1w</th>
<th>10w</th>
<th>100w</th>
<th>1000w</th>
<th>1 亿</th>
</tr>
</thead>
<tbody><tr>
<td>串行耗时(ms)</td>
<td>2</td>
<td>5</td>
<td>&lt;10</td>
<td>53</td>
<td>466</td>
</tr>
<tr>
<td>并发耗时(ms)</td>
<td>2</td>
<td>10</td>
<td>10-12</td>
<td>25</td>
<td>166</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20200205150407252.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看上下文切换明细</span><br><span class="line">- linux下使用vmstat/pidstat</span><br><span class="line">- 使用工具Lmbench3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>没有运行java程序前的cs变化<br><img src="https://img-blog.csdnimg.cn/20200205150936630.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>结果分析</p>
<ul>
<li>在count数据不是特别多的情况,串行执行的效率比并发快,因为并发执行需要切换线程上下文</li>
<li>随着次数的增加,串行执行的效率比并发执行效率低,原因是当前线程充分利用CPU核数的资源,利用多个线程在相应的CPU上执行,使得任务被对应的线程消费,在这种情况下,并发线程充分利用CPU空闲的资源完成任务的调度</li>
</ul>
</li>
</ul>
<blockquote>
<p>上下文切换消耗资源的优化方案</p>
</blockquote>
<ul>
<li>设计适当的线程数, 根据CPU核数以及jmeter测试单进程单线程1s执行的并发效率来调整最优的并发QPS</li>
<li><strong>使用线程池技术</strong></li>
<li>协程: 相当于代码段或者是函数式的程序代码,相比于程序代码而言,协程可以在当前线程中段转而执行其他代码片段,<strong>在单线程中来回切换多任务的函数式代码块,不存在上下文切换,也不存在锁,简言之,就是“子程序就是协程的一种特例”</strong></li>
<li>协程伪代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者 - 消费者模型, 每生产一个数据就消费一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(Consumer consumer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> num = RandomUtils.nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">		log.info(<span class="string">&quot;produce num %d&quot;</span>, num);</span><br><span class="line">		Object result = caller.send(consumer, num);</span><br><span class="line">	<span class="comment">// 通知消费者进行消费,当前程序中断挂起,不再继续执行,caller为调度器,协程必须有一个调度器提供子程序切换执行</span></span><br><span class="line">		log.info(<span class="string">&quot;conusmer num return %s&quot;</span>, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		<span class="comment">// get num by caller, 接收从调度器返回的数据,如果没有数据则中断并挂起当前程序</span></span><br><span class="line">		<span class="keyword">int</span> num = caller.receive();</span><br><span class="line">		log.info(<span class="string">&quot;conusmer consuming the num %s&quot;</span>, result);</span><br><span class="line">		result = “consume OK”;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2-线程安全之原子性"><a href="#2-线程安全之原子性" class="headerlink" title="2. 线程安全之原子性"></a>2. 线程安全之原子性</h6><blockquote>
<p>临界区与数据竞争</p>
</blockquote>
<ul>
<li>临界区: 在并发多线程中执行一系列对共享资源的修改操作的代码区域,在该区域下的操作的执行结果会对其他线程产生影响,称该代码区域为临界区</li>
<li>竞态条件: 表示并发多线程执行产生临界区的必要条件,也就是在临界区存在数据竞争,而数据竞争主要条件就是来源于多线程需要对共享资源执行读写操作,简言之就是多线程争夺共享资源的使用</li>
<li>代码示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sahred.java</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 在多线程中对于共享资源存在数据竞争,竞态条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mutil.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">	num ++;		<span class="comment">// 临界区</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>原子性操作与线程安全</p>
</blockquote>
<ul>
<li>原子性操作<ul>
<li>对程序代码指令而言,表示一个步骤;对整体业务逻辑而言,表示一系列步骤并且这一系列步骤在整体业务逻辑中一个是不可被中断, 与其他的业务代码步骤是不可被重排序的</li>
<li>核心特征就是相对整体业务逻辑而言,该一系列步骤要么全部成功,要么全部失败,在整体的业务逻辑保持操作结果的一致性</li>
<li>需要原子性操作的原因,在并发多线程中存在竞态条件,临界区的执行结果会对其他线程产生影响,如果不能保证所有线程看到的操作都是一致的(要么成功然后处理成功的逻辑,要么失败然后处理失败的逻辑),这样才能够保证我们的实际应用业务是可控的,结果是可预期的</li>
</ul>
</li>
<li>线程安全<ul>
<li>是属于一个概念性名词,主要体现线程在并发情况下可能会发生脏读或者是业务逻辑顺序被打乱出现的不可预期的现象</li>
</ul>
</li>
</ul>
<blockquote>
<p>JVM的资源</p>
</blockquote>
<ul>
<li>共享资源(存在线程安全问题)<ul>
<li>在JVM运行数据区中,方法区和堆内存均是属于共享资源数据,存在线程安全问题</li>
</ul>
</li>
<li>线程封闭资源(不存在线程安全问题)<ul>
<li>在当前线程栈中的局部变量.方法参数,抛出异常的处理器对象,由于只在线程栈中自己使用,并没有共享给其他线程,因此这类数据是属于线程安全的,也就是不存在数据竞争的情况</li>
<li>ThreadLocal以及ThreadLocalRandom等存储的数据变量</li>
<li>不可变的变量数据,即使用final修饰的变量数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决线程安全的技术手段</p>
</blockquote>
<p>解决线程安全的问题手段,最主要就是要防止脏读,抑或是顺序被打乱的情况,也就是要保证在整体业务逻辑代码中操作的一致性,那么实现的技术手段 – 通过加锁的方式实现共享资源的原子性问题</p>
<ul>
<li>java加锁方式<ul>
<li><a href="https://blog.csdn.net/wind_602/article/details/104099524">基于底层系统的原子操作原语实现的CAS机制</a></li>
<li><a href="https://blog.csdn.net/wind_602/article/details/104161960">基于AQS方式的加锁方式</a></li>
<li><a href="https://blog.csdn.net/wind_602/article/details/103966182">基于JVM实现的监视器锁对象的同步关键字synchronized</a></li>
</ul>
</li>
</ul>
<h6 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h6><blockquote>
<p>产生原因</p>
</blockquote>
<ul>
<li>多线程相互争抢对方相互持有的资源,由于获取不到资源一直处于挂起状态而无法继续往下执行</li>
<li>伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadA.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lockA)&#123;</span><br><span class="line">		<span class="comment">// ..</span></span><br><span class="line">		<span class="keyword">synchronized</span>(lockB)&#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// threadB.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lockB)&#123;</span><br><span class="line">		<span class="comment">// ..</span></span><br><span class="line">		<span class="keyword">synchronized</span>(lockA)&#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li>可以考虑将线程加入队列中,按照程序指定的逻辑先后执行</li>
<li>使用tryLock(timeout)的方式,一旦超时将自动释放锁资源</li>
<li>其他方案: 在业务代码中如果能够使用单锁解决问题则使用单锁的方式</li>
</ul>
<h6 id="4-机器资源限制"><a href="#4-机器资源限制" class="headerlink" title="4. 机器资源限制"></a>4. 机器资源限制</h6><ul>
<li><p>并发编程环境受限于机器资源的限制</p>
<ul>
<li>比如硬件方面有CPU核数以及CPU的处理读写能力, 网络带宽问题, 磁盘读写速度, 磁盘空间, 内存空间等因素;</li>
<li>软件资源一般是并发线程池的数量,比如tomcat服务的并发线程数, 数据库连接池大小, 网络socket连接数等</li>
</ul>
</li>
<li><p>资源限制导致的问题</p>
<ul>
<li>如果机器的CPU核数较少,比如只有一个的话,在机器启动jvm进程来创建多线程会容易导致线程切换频繁,再加上本身线程切换存在资源调度的性能消耗,容易降低程序执行效率</li>
<li>内存空间不足也会导致创建并发线程个数受限,同时容易造成OOM的错误</li>
<li>业务处理线程数多于数据库连接池数,如果数据库中的sql执行比较快的话,那么会导致程序很多业务进程处于阻塞等待状态,容易引起100%的CPU</li>
</ul>
</li>
<li><p>资源限制解决方案</p>
<ul>
<li>水平扩展, 增加机器实现集群方案来分担机器的压力</li>
<li>适当减少并发线程数量,尽量调整为CPU*2+1的线程数</li>
<li>根据业务所处的场景,对文件并发读写频繁可以选择磁盘IO处理能力较强的机器,网络并发读写频繁可以选择带宽较好的机器等</li>
</ul>
</li>
</ul>
<h6 id="5-可见性问题"><a href="#5-可见性问题" class="headerlink" title="5. 可见性问题"></a>5. 可见性问题</h6><p>参考<a href="https://blog.csdn.net/wind_602/article/details/104041188">Java内存模型之可见性分析</a></p>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型之简要知识与规范梳理</title>
    <url>/2020/02/16/jmm/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-JMM简要知识"><a href="#1-JMM简要知识" class="headerlink" title="1. JMM简要知识"></a>1. JMM简要知识</h6><blockquote>
<p>语义规范</p>
</blockquote>
<ul>
<li>Java编程语言的语义允许编译器和微处理器执行优化，从而与不正确同步的代码进行交互来完成工作.</li>
<li>线程内语义是单线程程序的语义，它允许根据线程内读操作看到的值来完全预测线程的行为;由于单线程内的实现是在其上下文执行的, 可以通过评估线程的实现从而确定执行中的线程t的操作是否合法.</li>
<li>程序遵循线程内语义: 在线程隔离状态下，每个线程的操作必须由该线程的语义控制，但是每个读操作看到的值由内存模型决定.</li>
</ul>
<blockquote>
<p>JMM规范</p>
</blockquote>
<ul>
<li>从数据存储上,对于共享数据的读写操作,JMM会通过线程工作内存以及JVM的堆内存来对数据进行读写操作(类比互联网业务,工作内存类比为redis等缓存,堆内存类比为数据储存载体,如数据库)</li>
<li>从代码优化上,JMM为了提升性能,会针对程序顺序代码进行重排序甚至删除不必要的同步代码</li>
</ul>
<blockquote>
<p>JMM概要</p>
</blockquote>
<ul>
<li>给定程序以及一个检测程序是否合法的执行跟踪,JMM工作原理是检查执行跟踪中的每个读,并根据某些规则检查读观察到的写是否有效</li>
<li>主要保证执行的每个结果与内存模型预期值一致,那么它可以不关心实现者是如何实现程序的行为</li>
<li>内存模型决定在程序的每个点可以读取哪些值。在隔离状态下，每个线程的操作必须由该线程的语义控制，但是每个读操作看到的值由内存模型决定</li>
<li>每次在线程内对变量进行写行为产生一个线程间的动作时,它必须匹配程序顺序中紧随其后的读行为的线程间动作,其中对于线程的读操作行为获取的值是由于JMM决定的值</li>
</ul>
<h6 id="2-JMM与顺序一致性模型"><a href="#2-JMM与顺序一致性模型" class="headerlink" title="2. JMM与顺序一致性模型"></a>2. JMM与顺序一致性模型</h6><blockquote>
<p>程序顺序与顺序一致性</p>
</blockquote>
<ul>
<li><p>程序顺序</p>
<ul>
<li>可描述为线程间所有动作是根据线程内语义执行操作顺序的一个集合</li>
<li>简言之,就是在线程内的操作所见即所得,即程序代码顺序</li>
</ul>
</li>
<li><p>顺序一致性内存模型</p>
<ul>
<li>一个线程所有操作都必须按照程序的顺序来执行</li>
<li>不论线程是否同步,所有线程都只能看到一个单一的操作执行顺序,并且每个操作都必须是原子性操作并立即对其他所有线程可见</li>
</ul>
</li>
<li><p>顺序一致性问题</p>
<ul>
<li>如果内存模型使用一致性模型,那么将会导致编译器和处理器的优化策略变得不合法</li>
</ul>
</li>
</ul>
<blockquote>
<p>JMM在顺序一致性方面的努力</p>
</blockquote>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared.java</span></span><br><span class="line"><span class="keyword">int</span> pwrite = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cwrite = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// producer.java</span></span><br><span class="line"><span class="keyword">int</span> pread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line">run()&#123;</span><br><span class="line">    r1 = <span class="number">20</span>;				<span class="comment">// --- 1</span></span><br><span class="line">	pread = cwrite;			<span class="comment">// --- 2</span></span><br><span class="line">	pwrite = <span class="number">10</span>;			<span class="comment">// --- 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumer.java</span></span><br><span class="line"><span class="keyword">int</span> cread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r2 = <span class="number">0</span>;</span><br><span class="line">run()&#123;</span><br><span class="line">	cread = pwrite;			<span class="comment">// --- 4</span></span><br><span class="line">	r2 = <span class="number">21</span>;				<span class="comment">// --- 5</span></span><br><span class="line">	cwrite = <span class="number">20</span>;			<span class="comment">// --- 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码分析<ul>
<li>基于JMM模型: 由于存在数据竞争,上面的代码执行顺序会在编译器阶段,JMM允许对程序代码进行重排序,输出结果会出现pread = cwrite = 20 与 cread = pwrite = 10的情况</li>
<li>基于一致性内存模型: 将会正常输出,不会出现pread = cwrite = 20 与 cread = pwrite = 10的情况,但是线程之间的顺序会交替执行</li>
</ul>
</li>
<li>加锁方案<ul>
<li>基于JMM模型: 保证输出结果的正常,但是在上述线程内执行的顺序会被重排序</li>
<li>一致性内存模型: 不会打乱顺序,仍然正常结果输出</li>
</ul>
</li>
<li>小结<ul>
<li>在存在数据竞争的条件下,JMM无法保证线程之间的执行顺序,而顺序一致性保证与代码执行的顺序相同,即使线程的执行顺序存在交替执行也不影响单个线程内的执行顺序</li>
<li>单个线程中,JMM仍然会对临界区的执行动作进行重排序,而顺序一致性并没有进行重排,仍然保持与程序代码相同的顺序</li>
</ul>
</li>
</ul>
<h6 id="3-JMM规范梳理"><a href="#3-JMM规范梳理" class="headerlink" title="3. JMM规范梳理"></a>3. JMM规范梳理</h6><blockquote>
<p>共享数据规则</p>
</blockquote>
<ul>
<li>能够被多个线程共享的内存区域称为共享内存或是堆内存</li>
<li>线程共享数据: 所有的对象实例字段,static字段,数组元素等</li>
<li>线程封闭数据: 局部变量,方法参数,异常处理器以及ThreadLocal/ThreadLocalRandom等</li>
</ul>
<blockquote>
<p>线程行为操作规则</p>
</blockquote>
<p><strong>相当于线程行为可以被其他线程看到,也可以检测到其他线程的行为动作,前提是存在数据竞争,程序行为表现如下:</strong></p>
<ul>
<li>可以执行正常的读操作</li>
<li>可以执行正常的写操作</li>
<li>对于同步代码块<ul>
<li>可以执行volatile数据的读取,说明其他线程的写操作当前线程可以“看到”(写操作在线程失效直接读取主内存)</li>
<li>可以执行volatile数据的写,说明变量数据可以对其他线程“可见”</li>
<li>lock锁定监视器</li>
<li>unlock解锁监视器</li>
</ul>
</li>
<li>线程合并执行的第一个和最后一个动作(个人理解为等待多个线程执行子任务之后再一同执行程序后续代码的场景)</li>
<li>启动线程和终止线程</li>
</ul>
<blockquote>
<p>Synchronization原则(能够被感知,可见行为的变化)</p>
</blockquote>
<ul>
<li>监视器m的解锁与监视器m的后续动作加锁操作同步</li>
<li>线程对volatile变量v进行写操作,与任何线程对v的所有后续读操作同步</li>
<li>启动线程的操作与线程执行的第一个动作的操作同步</li>
<li>在线程中对每个属性执行默认值的写入操作与线程的第一个动作操作同步</li>
<li>线程中的最终动作T1 与另一个线程T2中检测到T1已终止的任何动作同步</li>
<li>如果线程T1中断thread T2，则该中断线程T1 将与 任何其他线程（包括T2）确定T2已被中断（通过InterruptedException引发或调用Thread.interrupted 或Thread.isInterrupted）的任何点同步</li>
</ul>
<blockquote>
<p>Happen-Before原则(规范)</p>
</blockquote>
<ul>
<li><p>执行动作之间的happen-before关系</p>
</li>
<li><p>*如果两个动作x和y,我们定义hb(x,y)来描述x happen before y,满足关系有以下情况:**</p>
<ul>
<li>同一个线程中执行动作x和y,在程序顺序上x优先于y,则hb(x,y)</li>
<li>对象构造器代码块的结束happen-before该对象finalizer的开始</li>
<li>如果x动作于接下来的y动作同步,则hb(x,y)</li>
<li>传递性,如果hb(x,y),且hb(y,z),则hb(x,z)</li>
</ul>
</li>
<li><p> happen-before原则</p>
</li>
<li><p>*主要作用于两个的动作存在冲突的执行顺序以及定义数据竞争发生的时机,具体VM实现,遵循以下原则:**</p>
<ul>
<li>线程解锁动作都happen-before该线程加锁之后的后续每个动作</li>
<li>对volatile变量执行写操作happen-before该变量读操作的后续每个动作</li>
<li>调用线程的start()方法happen-before于已开启的线程内的任何一个动作</li>
<li>线程所有动作happen-before于其他任意线程成功从该线程对象上的join()方法返回</li>
<li>程序任何对象的初始化happen-before于程序中任何其他的动作操作行为</li>
</ul>
</li>
<li><p>作用: 遵循上述的原则,意味着有些代码不能进行重排序,有些数据不能被缓存(解决JMM可见性的规范)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型之可见性分析</title>
    <url>/2020/02/19/jmm02/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-JMM模型描述"><a href="#1-JMM模型描述" class="headerlink" title="1. JMM模型描述"></a>1. JMM模型描述</h6><ul>
<li>给定程序以及一个检测程序是否合法的执行跟踪,JMM工作原理是检查执行跟踪中的每个读,并根据某些规则检查读观察到的写是否有效</li>
<li>JMM中可能产生的行为表象现为不论代码是如何实现程序行为,只要保证程序的所有结果执行和JMM预期的结果一致即可</li>
<li>基于上述的第二点,对实现者执行的代码进行转换的实现就比较自由,可以实现操作的重排序甚至删除不必要的同步操作代码</li>
</ul>
<h6 id="2-JMM之数据共享与竞争"><a href="#2-JMM之数据共享与竞争" class="headerlink" title="2. JMM之数据共享与竞争"></a>2. JMM之数据共享与竞争</h6><blockquote>
<p>线程共享与独占区域</p>
</blockquote>
<ul>
<li>线程共享区域: JVM运行数据区中的方法区,堆内存存储的数据变量,存在数据竞争,即数据读写的安全问题</li>
<li>线程独占区域: JVM为每个线程单独创建的私有区域,用于存储当前线程私有的数据变量,不存在数据竞争,比如线程局部变量,ThreadLocal/ThreadLocalRandom等<br><img src="https://img-blog.csdnimg.cn/20200119175041770.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>线程通信产生数据竞争</p>
</blockquote>
<ul>
<li><p>简要的源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constant.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> P = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> C = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// shared.java</span></span><br><span class="line"><span class="keyword">int</span> pwrite = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cwrite = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// producer.java</span></span><br><span class="line"><span class="keyword">int</span> pread = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pread = cwrite; <span class="comment">// 生产者线程需要消费者线程cwrite的数据</span></span><br><span class="line">	pwrite = P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumer.java</span></span><br><span class="line"><span class="keyword">int</span> cread = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cread = pwrite;<span class="comment">// 消费者线程需要生产者线程的pwrite数据</span></span><br><span class="line">	cwrite = C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按正常结果输出的预期值推断,不会产生同时pread == C(20)和cread == P(10)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果反推分析(基于我们看到的代码顺序)</p>
<ul>
<li>如果上述的执行结果成立,那么<code>cwrite = C</code>一定是在<code>pread = cwrite</code>之前执行的;</li>
<li>由于<code>cwrite = C</code>是在<code>cread = pwrite</code>之后执行,所以<code>cread = pwrite</code>一定是在<code>pread = cwrite</code>之前执行的;</li>
<li>也就是<code>cread = pwrite</code>一定是在<code>pwrite = P</code>之前执行的,所以结果是不成立</li>
</ul>
</li>
<li><p>产生问题</p>
<ul>
<li>线程既然存在写操作,那么写操作的数据变量一定会让另一个线程读取到对应写后的数据么?</li>
<li>由于线程本身也有自己的工作内存,因此读取数据变量不一定就是另一个线程写操作之后的数据,此时可能读取到工作内存上的缓存数据(脏数据)</li>
</ul>
</li>
<li><p> 但是基于JMM规范,产生优化后可能的执行代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pread = cwrite; <span class="comment">// 生产者线程需要消费者线程cwrite的数据  --1</span></span><br><span class="line">	pwrite = P;     <span class="comment">// --2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumer.java</span></span><br><span class="line"><span class="keyword">int</span> cread = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cwrite = C;     <span class="comment">// --3</span></span><br><span class="line">	cread = pwrite;<span class="comment">// 消费者线程需要生产者线程的pwrite数据 -4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在上述两个线程中分析</p>
<ul>
<li> 线程在并发下,可能产生执行的顺序为3-1-2-4,也就是同时产生pread == C(20)和cread == P(10)</li>
</ul>
</li>
<li><p>数据竞争</p>
<ul>
<li>当前线程对一个变量执行写操作</li>
<li>同时另一个线程对相同的变量执行读操作</li>
<li>读写操作没有通过同步实现排序</li>
</ul>
</li>
<li><p>产生问题</p>
<ul>
<li>不同线程之间通信会对共享变量的数据产生竞争,在这种情况下,JMM作出重排序的优化会导致输出结果与预期的结果不一致,如果放在实际的业务场景中,将会导致很多无法控制的业务逻辑错误,后果不可想象.</li>
</ul>
</li>
</ul>
<blockquote>
<p>JMM下的并发问题</p>
</blockquote>
<ul>
<li>其一,读取到的共享数据不一定是写操作之后的数据,也就是写操作对读操作不可见(缓存导致)</li>
<li>其二,JMM为了提升性能对代码进行重排序,那么就会导致数据产生的结果和预期的不一致(重排序导致)</li>
</ul>
<h6 id="3-JMM可见性解决方案"><a href="#3-JMM可见性解决方案" class="headerlink" title="3. JMM可见性解决方案"></a>3. JMM可见性解决方案</h6><blockquote>
<p>线程之工作内存</p>
</blockquote>
<ul>
<li><p>JMM抽象之工作内存(线程本地内存)</p>
<ul>
<li>线程栈中的存储的变量,如局部变量,方法参数,异常处理参数等</li>
<li>CPU高速缓存</li>
</ul>
</li>
<li><p>线程,工作内存,JMM与主内存<br><img src="https://img-blog.csdnimg.cn/20200119204201101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上述可知,在JVM运行数据区中,工作内存与主内存是通过JMM模型规范来完成彼此之间的数据交互,因此可以通过JMM定义的内存语义规范来提供数据变量的可见性</p>
</li>
<li><p>基于缓存问题解决方案</p>
<ul>
<li>JMM规范规定使用针对的技术手段时,将强制线程直接绕过工作内存读取主内存的共享数据</li>
<li>常用技术手段:volatile/synchronized/final/具有内存同步的操作指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>重排序</p>
</blockquote>
<ul>
<li><p>遵循规则</p>
<ul>
<li>as-if-serial: 即不管怎么进行重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变.编译器/runtime/处理器都必须遵循as-if-serial语义,也就是说编译器和处理器不会对存在数据依赖关系的操作做重排序</li>
</ul>
</li>
<li><p>重排序的分类</p>
<ul>
<li>编译器重排序: 基于单个线程程序的语义前提下,Java开启server模式(clinet不支持)可以对程序代码进行编译优化</li>
<li>处理器重排序:在没有存在数据依赖的前提下,处理器可以改变机器指令的执行顺序</li>
</ul>
</li>
<li><p>重排序解决方案</p>
<ul>
<li>编译器会根据JMM特定类型(同步代码标志等)禁止进行重排序</li>
<li>在Java编译器生成指令之前插入特定的内存屏障来禁止处理器重排序</li>
</ul>
</li>
<li><p>内存屏障类型: <a href="https://blog.csdn.net/wind_602/article/details/103914263">常见CPU高速缓存与内存屏障</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发线程之Lock应用</title>
    <url>/2020/02/24/lock/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="1-ReentrantLock的基本使用"><a href="#1-ReentrantLock的基本使用" class="headerlink" title="1. ReentrantLock的基本使用"></a>1. ReentrantLock的基本使用</h5><blockquote>
<p>lock使用以及注意事项</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取count数据：&quot;</span> +  count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始写count数据。。。&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;结束写count数据。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// main.java</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	Task task = <span class="keyword">new</span> Task();</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">4</span>; index++)&#123;</span><br><span class="line">	     <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	         <span class="meta">@Override</span></span><br><span class="line">	         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	             lock.lock();</span><br><span class="line">	             <span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//                        dirtyCode();</span></span><br><span class="line">	                 task.write();</span><br><span class="line">	             &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	                 lock.unlock();</span><br><span class="line">	             &#125;</span><br><span class="line">	         &#125;</span><br><span class="line">	     &#125;.start();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0开始写count数据。。。</span><br><span class="line">Thread-0结束写count数据。。。</span><br><span class="line">Thread-3开始写count数据。。。</span><br><span class="line">Thread-3结束写count数据。。。</span><br><span class="line">Thread-2开始写count数据。。。</span><br><span class="line">Thread-2结束写count数据。。。</span><br><span class="line">Thread-1开始写count数据。。。</span><br><span class="line">Thread-1结束写count数据。。。</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在将代码变更如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始写count数据。。。&quot;</span>);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">3</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;结束写count数据。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dirtyCode</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改线程中的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">   		<span class="comment">// lock.lock();  // 这里与上述代码加锁是一致的道理,这里为了演示效果</span></span><br><span class="line">        dirtyCode(task.isFlag());</span><br><span class="line">        lock.lock();		<span class="comment">// 	可以看到我们是要缩小粒度加锁的优化</span></span><br><span class="line">        task.write();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时的执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0开始写count数据。。。</span><br><span class="line">Thread-0结束写count数据。。。</span><br><span class="line">Thread-1开始写count数据。。。</span><br><span class="line">Thread-1结束写count数据。。。</span><br><span class="line">Thread-2开始写count数据。。。</span><br><span class="line">Thread-2结束写count数据。。。</span><br><span class="line">Exception in thread &quot;Thread-3&quot; Exception in thread &quot;Thread-4&quot; java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure></li>
<li><p>分析</p>
<ul>
<li>上述代码会抛出异常但是不是我们预期的算法异常,而是非法监视器状态异常</li>
<li>从代码分析看,执行<code>dirtyCode</code>之后不会再执行加锁操作,但是一定会执行unlock操作,于是我们可以推测是调用unlock的时候出错</li>
<li>查看源码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br></pre></td></tr></table></figure></li>
<li>可以看到原因就是我们当前并没有加锁,当前线程并没有持有独占锁,因此调用unlock会报错</li>
<li>于是代码可以变更为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">	dirtyCode(task.isFlag());</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		task.write();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>lock.lock()</code>比较好的做法是放在try块的外面而不是在里面</li>
</ul>
</li>
</ul>
<h5 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h5><ul>
<li>读锁: 意味着允许并发多线程进行读取操作,但是不能执行写操作</li>
<li>写锁: 意味着仅能一个线程执行写操作,其他线程必须等待</li>
<li>代码示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.java</span></span><br><span class="line"><span class="comment">// 读写方法分别增加时间点输出并添加1s的等待操作</span></span><br><span class="line"><span class="comment">// main.java</span></span><br><span class="line"> 	ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readLock =  readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock =  readWriteLock.writeLock();</span><br><span class="line">    Task task = <span class="keyword">new</span> Task();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                readLock.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    task.read();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    readLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.write();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    writeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>注释掉写操作的线程,执行读操作的线程,执行结果如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214921</span></span><br><span class="line">Thread-<span class="number">9</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214923</span></span><br><span class="line">Thread-<span class="number">8</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214922</span></span><br><span class="line">Thread-<span class="number">7</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214922</span></span><br><span class="line">Thread-<span class="number">6</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214922</span></span><br><span class="line">Thread-<span class="number">5</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214922</span></span><br><span class="line">Thread-<span class="number">4</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214922</span></span><br><span class="line">Thread-<span class="number">3</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214921</span></span><br><span class="line">Thread-<span class="number">2</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214921</span></span><br><span class="line">Thread-<span class="number">1</span>开始读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106214921</span></span><br><span class="line">Thread-<span class="number">8</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">7</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">6</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">9</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">5</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">0</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">4</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215942</span></span><br><span class="line">Thread-<span class="number">1</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215945</span></span><br><span class="line">Thread-<span class="number">2</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215945</span></span><br><span class="line">Thread-<span class="number">3</span>完成读取count数据：<span class="number">0</span>, 时间点：<span class="number">1582106215945</span></span><br></pre></td></tr></table></figure></li>
<li>可以看出,上述读锁可以保证同一个时间点多个线程都持有读锁进行读操作</li>
<li>注释掉写操作的线程,查看输出结果<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>开始写count数, 时间点：<span class="number">1582106322255</span></span><br><span class="line">Thread-<span class="number">0</span>完成写count数, 时间点：<span class="number">1582106323279</span></span><br><span class="line">Thread-<span class="number">1</span>开始写count数, 时间点：<span class="number">1582106323279</span></span><br><span class="line">Thread-<span class="number">1</span>完成写count数, 时间点：<span class="number">1582106324281</span></span><br><span class="line">Thread-<span class="number">2</span>开始写count数, 时间点：<span class="number">1582106324282</span></span><br><span class="line">Thread-<span class="number">2</span>完成写count数, 时间点：<span class="number">1582106325287</span></span><br><span class="line">Thread-<span class="number">3</span>开始写count数, 时间点：<span class="number">1582106325288</span></span><br><span class="line">Thread-<span class="number">3</span>完成写count数, 时间点：<span class="number">1582106326290</span></span><br></pre></td></tr></table></figure></li>
<li>上面可以看出写锁必须是等待当前一个线程执行完成才能释放锁给下一个线程,写锁只能一个线程持有</li>
</ul>
<h5 id="3-锁中断响应操作"><a href="#3-锁中断响应操作" class="headerlink" title="3. 锁中断响应操作"></a>3. 锁中断响应操作</h5><blockquote>
<p>lock()与lockInterruptibly()方法比较</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInterrupt</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取到锁执行了。。。。&quot;</span>);</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁。。。。&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// main.java</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;线程1&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testInterrupt(lock);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行其他操作。。。。&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断，获取锁失败。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;线程2&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testInterrupt(lock);</span><br><span class="line">                System.out.println(<span class="string">&quot;执行其他操作。。。。&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断，获取锁失败。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    TimeUnit.MICROSECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.MICROSECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">    t2.interrupt();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用lock()执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1获取到锁执行了。。。。</span><br><span class="line">线程1释放锁。。。。</span><br><span class="line">线程2获取到锁执行了。。。。</span><br><span class="line">线程1执行其他操作。。。。</span><br><span class="line">线程2释放锁。。。。</span><br><span class="line">线程2被中断，获取锁失败。。。</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lockInterruptibly()执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1获取到锁执行了。。。。</span><br><span class="line">线程2被中断，获取锁失败。。。</span><br><span class="line">线程1释放锁。。。。</span><br><span class="line">线程1执行其他操作。。。。</span><br></pre></td></tr></table></figure></li>
<li><p>分析,使用lock()的时候lock代码块仍然会执行,而主线程已经调用中断,说明没有响应到锁中断</p>
</li>
<li><p>对于使用lockInterruptibly()一旦收到主线程的中断操作,立马响应中断不会再继续往下执行</p>
</li>
</ul>
<h5 id="4-条件锁"><a href="#4-条件锁" class="headerlink" title="4. 条件锁"></a>4. 条件锁</h5><p>使用典型的生产者-消费者模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Condition的条件锁</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">                  <span class="keyword">while</span> (list.size() == size)&#123;</span><br><span class="line">                      <span class="comment">// 说明已经满了</span></span><br><span class="line">                      System.out.println(<span class="string">&quot;数据已经满了。。。&quot;</span>);</span><br><span class="line">                      full.await();</span><br><span class="line">                  &#125;</span><br><span class="line">                  list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                  System.out.println(<span class="string">&quot;生产数据。。。。&quot;</span>);</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                  empty.signalAll();<span class="comment">// 通知消费可以消费数据</span></span><br><span class="line">              &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;.start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">                  <span class="keyword">while</span> (list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                      System.out.println(<span class="string">&quot;数据已经空了&quot;</span>);</span><br><span class="line">                      empty.await();<span class="comment">//当前已经是空数据</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  list.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                  System.out.println(<span class="string">&quot;消费数据。。。&quot;</span>);</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                  full.signalAll();   <span class="comment">// 通知生产者生产数据</span></span><br><span class="line">              &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;.start();</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">数据已经空了</span><br><span class="line">生产数据。。。。</span><br><span class="line">生产数据。。。。</span><br><span class="line">生产数据。。。。</span><br><span class="line">生产数据。。。。</span><br><span class="line">生产数据。。。。</span><br><span class="line">数据已经满了。。。</span><br><span class="line">消费数据。。。</span><br><span class="line">消费数据。。。</span><br><span class="line">消费数据。。。</span><br><span class="line">消费数据。。。</span><br><span class="line">消费数据。。。</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发原子性技术之加锁方式</title>
    <url>/2020/02/26/lock_category/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-锁的分类"><a href="#1-锁的分类" class="headerlink" title="1. 锁的分类"></a>1. 锁的分类</h6><blockquote>
<p>乐观锁与悲观锁</p>
</blockquote>
<ul>
<li>乐观锁:在并发环境下,一般情况认为是属于读多写少的情况,没有数据冲突,当对共享资源发生写操作的时候,会先检测当前版本的数据与先前版本数据是否一致,如果不一致说明有其他线程已经发生写操作,需要重复进行读取然后检测再尝试修改,比如CAS机制,zk最优先通过最新主版本的策略来选举master,数据库根据版本更新数据等</li>
<li>悲观锁:在并发环境下,认为竞争非常激烈,于是在对共享资源发生写操作的时候先加上锁,然后执行临界区代码完成操作再释放锁,其他线程获取相同的锁需要进行等待,处于阻塞状态</li>
<li>乐观锁与悲观锁示例伪代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用java以及数据库的操作方式演示乐观锁与悲观锁</span></span><br><span class="line"><span class="comment">// optimistic.java</span></span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">// cas instance</span></span><br><span class="line">	<span class="keyword">int</span> expected = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> updated = <span class="number">12</span>;</span><br><span class="line">	count.compareAndSet(expected, updated);</span><br><span class="line">	<span class="comment">// db instance</span></span><br><span class="line">	Object row = selectById();</span><br><span class="line">	<span class="comment">// update bussiness data except row version</span></span><br><span class="line">	row.setXX();</span><br><span class="line">	<span class="comment">// update data </span></span><br><span class="line">	updateRowByIdWithVersion(row);</span><br><span class="line">	<span class="comment">// db.execute(&quot;update tb_entity set x1=?,x2=?,version=#&#123;version&#125;+1 where id=#&#123;id&#125; and version=#&#123;version&#125;&quot;, row);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pessimistic.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">// mutex lock</span></span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="comment">// code ..</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// db lock</span></span><br><span class="line">	<span class="comment">// start transaction</span></span><br><span class="line">	db.execute(<span class="string">&quot;select * from tb_entity where id=#&#123;id&#125; for update&quot;</span>);	<span class="comment">// lock</span></span><br><span class="line">	db.execute(<span class="string">&quot;update tb_entity set x1=?,... where id=#&#123;id&#125;&quot;</span>);			<span class="comment">// update</span></span><br><span class="line">	<span class="comment">// commit trasaction;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可重入锁与递归锁</p>
</blockquote>
<ul>
<li>可重入锁: 同一个线程获取到锁对象,同时能够执行拥有该锁的其他同步代码,即递归锁/外部方法调用内部方法,两个方法持有同一把锁</li>
<li>递归锁: 本质也是可重入锁,也就是线程执行当前递归的方法时,由于是同一把锁,因此不会再次获取锁,而是持有锁进行执行方法的递归操作</li>
<li>java实现可重入锁的技术<ul>
<li>ReentrantLock</li>
<li>synchronized<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">run()&#123;</span><br><span class="line">	reentrantLock.lock();</span><br><span class="line">	<span class="comment">// code ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// code ...</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code ...</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// order.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">createOutBoundOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">//Order sharedOrder = new Order();</span></span><br><span class="line">	<span class="keyword">synchronized</span>(sharedOrder)&#123;</span><br><span class="line">		<span class="comment">// create order item</span></span><br><span class="line">		<span class="comment">// get logistics price and caculate the best optimisic algorithm</span></span><br><span class="line">		createOutBoundOrder(orders);</span><br><span class="line">		<span class="comment">// dispatch order towards sys</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>公平锁与非公平锁</p>
</blockquote>
<ul>
<li>公平锁: 在并发环境下多线程争抢锁的顺序,如果是按照队列的先来后到的顺序,则视为公平</li>
<li>非公平锁: 在并发多线程环境下不按照先来后到的顺序,而是强行“插队”的方式获取锁,则视为不公平</li>
<li>场景分析: 如果线程A已经持有锁,这时候线程B获取失败并被挂起,处于阻塞状态,与此同时线程C也来争夺锁也将被挂起阻塞,当线程A执行完同步方法之后释放锁的时候,如果锁是公平的,那么我们期望就是线程B获取锁而线程C仍然处于阻塞状态,如果是非公平锁,那么将线程B/C获取锁的顺序是随机不确定的</li>
<li>java实现公平锁的技术方案</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平锁,会消耗性能</span></span><br><span class="line">ReentrantLock pairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁, 默认为不公平锁,获取锁的方式是随机,不按照线程争抢锁的顺序</span></span><br><span class="line">ReentrantLock unpairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>共享锁(读)与独占锁(写)</p>
</blockquote>
<ul>
<li>共享锁: 也就是所谓的读锁,即给共享资源加上读锁,线程获取该锁的时候只能读取不能进行写操作,同理也可以被其他线程获取,但不能写,共享锁可以被多个线程共同持有</li>
<li>独占锁: 也就是写锁,或者称为排它锁,也就是只能有一个线程拥有该锁,当前给共享资源加上写锁时,当前线程可以进行写操作,但是其他线程要获取锁只能处于等待</li>
<li><strong>简言之,共享锁能为多个线程所持有并只能进行读操作,独占锁只能被单个线程所持有并只能进行单写操作</strong></li>
<li>java实现的读写锁技术</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read_write_lock.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock read = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">final</span> Lock write = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</span><br><span class="line">    	<span class="comment">// 读取操作交替执行,所有读线程都能够获取读锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    read.lock();</span><br><span class="line">                    read();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    read.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 写操作按照获取锁的方式顺序执行,只能在单线程中实现写操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    write.lock();</span><br><span class="line">                    write();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    write.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自旋锁 = CAS无锁 + 循环</p>
</blockquote>
<ul>
<li>自旋锁: 在并发环境下,当一个线程获取锁的时候发现锁已经被其他线程所占有,这时候并没有将该线程挂起而是在可用的CPU资源情况下,不断尝试获取锁的方式,如果成功则获取锁,如果失败则进行尝试,在进行尝试一定次数之后会对当前的并发环境进行分析并采取其他的策略获取锁</li>
<li>在Java中,默认尝试此时为10, 可以通过<code>-XX:PreBlockSpinsh</code>来设置对应的自旋失败次数</li>
<li>不足:消耗CPU资源,容易引起CPU占用资源过高导致机器卡顿甚至处理效率变低</li>
<li>java技术实现的自旋锁方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用CAS无锁 + 循环的方式 -- 自旋锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> valueOffsetValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CAS 硬件原语 ---java语言 无法直接改内存。 曲线通过对象及属性的定位方式</span></span><br><span class="line">            valueOffsetValue = unsafe.objectFieldOffset(LockCASDemo.class.getDeclaredField(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countAdder</span><span class="params">()</span></span>&#123;</span><br><span class="line">     	<span class="comment">// 自增加</span></span><br><span class="line">     	<span class="keyword">int</span> current;</span><br><span class="line">     	<span class="keyword">int</span> value;</span><br><span class="line">     	<span class="keyword">do</span>&#123;</span><br><span class="line">         	current = unsafe.getIntVolatile(<span class="keyword">this</span>, valueOffsetValue); <span class="comment">// 读取当前值</span></span><br><span class="line">         	value = current + <span class="number">1</span>; <span class="comment">// 计算</span></span><br><span class="line">     	&#125;<span class="keyword">while</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffsetValue, current , value));</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分片加锁</p>
</blockquote>
<ul>
<li>分片加锁其实将锁的粒度缩小范围,尤其是在并发情况下,需要对存储容器不断进行读写操作,如果每次都对容器进行加锁,那么锁范围十分大,会大大降低程序执行的效率,因此分片加锁就是针对容器进行划分为若干等分(可以片段)进行加锁,也就是说针对容器某一个等分进行读写操作的时候只针对该部分进行加锁操作,其他部分仍保持无锁的状态,可以大大提升程序CPU利用率,加快程序的执行</li>
<li>分片加锁技术<ul>
<li>java中使用ConcurrentHashMap针对Segment片段进行加锁,每一份Segment存储key-value,通过对Segment进行加锁方式(进一步优化可以处理为读写锁方式)来保证线程安全</li>
<li>在数据库中,可以将一系列的update/delete操作进行行级别加锁,相比表级别的加锁方式,可以提升并发执行效率</li>
</ul>
</li>
</ul>
<blockquote>
<p>jdk锁的细节</p>
</blockquote>
<ul>
<li>锁响应中断: 在并发环境下,当前线程想要获取锁却发现锁已经被其他线程所持有,这时候当前线程就处于阻塞状态,如果当前线程在主线程中被中断,那么此时阻塞的线程收到中断的通知将会结束线程工作,如果不做锁的响应中断处理,那么当前线程仍然会获取锁并执行锁中的同步代码之后释放锁才中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// - java技术伪代码</span></span><br><span class="line"><span class="comment">// business.java</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// code ...</span></span><br><span class="line">	<span class="comment">// 锁响应中断,如果主线程对当前线程进行中断操作,那么当前线程将会直接退出线程</span></span><br><span class="line">	lock.lockInterruptibly();</span><br><span class="line">	<span class="comment">// 如果主线程对当前线程进行中断操作,那么当前线程会继续获取锁之后再进行中断操作</span></span><br><span class="line">	<span class="comment">// lock.lock();</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">// execute core should spent 10s </span></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">10L</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		LOG.error(e);	</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.java</span></span><br><span class="line"><span class="comment">// 伪代码,为了简化代码的编写</span></span><br><span class="line">Thread t1,t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			doBusiness();</span><br><span class="line">			doOthers();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			LOG.error(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">t2.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line"><span class="comment">// 线程2中断</span></span><br><span class="line">t2.interrupt();	</span><br></pre></td></tr></table></figure>

<ul>
<li>分类锁Condition: 用于替代wait/notify方法,wait和notify方法是结合synchronized一起使用,可以令线程等待和唤醒等待线程的集合,而Condition是结合Lock一起使用,能够提供多个等待集合,更精准地控制线程的等待和唤醒(底层使用LockSupport的park和unpark机制)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用线程通信方式</span></span><br><span class="line"> <span class="keyword">final</span> Condition full = reentrantLock.newCondition();</span><br><span class="line"> <span class="keyword">final</span> Condition empty = reentrantLock.newCondition();</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">final</span> ArrayDeque&lt;String&gt; container = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> Thread producer = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 不断生产数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 数据已经满了</span></span><br><span class="line">                <span class="keyword">while</span> (size == container.size())&#123;</span><br><span class="line">                    <span class="comment">// 不再进行生产数据</span></span><br><span class="line">                    full.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据</span></span><br><span class="line">                container.push(<span class="keyword">new</span> String(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce ...&quot;</span>);</span><br><span class="line">                empty.signalAll();<span class="comment">// 通知消费进行消费</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> Thread consumer = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         reentrantLock.lock();</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                 <span class="comment">// 判断数据是否为空</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="number">0</span> == container.size())&#123;</span><br><span class="line">                     empty.await();</span><br><span class="line">                 &#125;</span><br><span class="line">                 String str = container.pop();</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consumer data for :&quot;</span> + str);</span><br><span class="line">                 full.signalAll();  <span class="comment">// 通知生产者生产数据</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             reentrantLock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> producer.start();</span><br><span class="line"></span><br><span class="line"> TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line"> consumer.start();</span><br></pre></td></tr></table></figure>

<h6 id="2-加锁原理"><a href="#2-加锁原理" class="headerlink" title="2. 加锁原理"></a>2. 加锁原理</h6><blockquote>
<p>jdk中加锁的工作原理</p>
</blockquote>
<ul>
<li>基于UnSafe实现的CAS机制,其原理可以参考先前的<a href="https://blog.csdn.net/wind_602/article/details/104099524">CAS机制</a></li>
<li>基于内存屏障实现的synchronized加锁方式,其原理可以参考<a href="https://blog.csdn.net/wind_602/article/details/103873050">原理一</a>,<a href="https://blog.csdn.net/wind_602/article/details/103936767">原理二</a>以及<a href="https://blog.csdn.net/wind_602/article/details/103966182">原理三</a></li>
<li>基于java并发包下的<a href="https://blog.csdn.net/wind_602/article/details/104161960">AbstractQueuedSynchronizer(AQS)实现的锁方式</a></li>
</ul>
<h6 id="3-JVM锁优化技术手段"><a href="#3-JVM锁优化技术手段" class="headerlink" title="3. JVM锁优化技术手段"></a>3. JVM锁优化技术手段</h6><blockquote>
<p>synchronized加锁方式的优化</p>
</blockquote>
<ul>
<li>无锁: 正常的java对象,属于默认的初始化的锁状态</li>
<li>偏向锁: 对象头markword中的hashcode通过CAS替换为当前的ThreadId,同时对象的偏向锁标志为1</li>
<li>轻量级锁: 达到一定的并发量,JVM撤销偏向锁,锁升级为轻量级锁,即在对象头markword中的bitfields通过CAS替换为当前的执行线程栈帧的引用地址,同时栈帧中存储对象头的markword信息</li>
<li>重量级锁(mutex lock): 并发竞争激烈,升级为重量级锁,通过将对象头markword中的bitfields通过CAS替换为当前对象的引用地址,通过JVM优化会通过走“捷径”方式来进行加锁,锁无法降级</li>
<li>参考<a href="https://blog.csdn.net/wind_602/article/details/103966182">synchronized工作原理(三)</a></li>
</ul>
<blockquote>
<p>减少锁持有时间</p>
</blockquote>
<ul>
<li>仅在程序出现线程安全的情况下进行加锁</li>
<li>代码演示减少锁持有时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">// query from user</span></span><br><span class="line">	<span class="comment">// query from order</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">// 保证一致性, 思考: 这里用事务也可以实现同样的效果,事务与锁有什么关系? 后面有时间再写</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="comment">// create order items</span></span><br><span class="line">		<span class="comment">// create orders</span></span><br><span class="line">		<span class="comment">// create outbound orders</span></span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于事务与锁的联系与区别的参考文档<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考mysql文档: https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html</span><br><span class="line">参考美团技术文档: https://tech.meituan.com/2014/08/20/innodb-lock.html</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>锁粗化</p>
</blockquote>
<ul>
<li>在并发条件下,程序获取锁的成本十分昂贵,如果在一块代码中对同一个锁不断地获取和释放,容易导致CPU系统资源被消耗殆尽,严重影响程序在操作系统中的执行效率,也就是说为了保证在并发多线程环境下,要求每个线程尽可能持有锁的时间片段尽可能少,同时能够在完成同步代码之后释放共享资源以便其他线程能够获取锁进行相应的操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁粗化伪代码示例</span></span><br><span class="line">increase()&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.productNum -- ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// send message to mq notice product num have been decreased</span></span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.orderItem ++ ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// shopping cart have add new one product one</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">take()&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; LIMIT_SIZE; index++)&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(queue)&#123;</span><br><span class="line">			queue.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上述看到,其实锁粗化出现的情况很多时候是我们是在指定的业务顺序逻辑进行编写代码造成的,一般情况下对代码的优化我们也需要考虑到两个同步代码中间的其他代码是否不影响执行程序代码的执行结果来进行优化</span></span><br><span class="line">increase()&#123;</span><br><span class="line">	<span class="comment">// 减少锁的获取</span></span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.productNum -- ;</span><br><span class="line">		<span class="keyword">this</span>.orderItem ++ ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// send message to mq notice product num have been decreased</span></span><br><span class="line">	<span class="comment">// shopping cart have add new one product one</span></span><br><span class="line">&#125;</span><br><span class="line">take()&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(queue)&#123;</span><br><span class="line">		<span class="keyword">for</span>(...)&#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JIT编译器优化:如果发现调用的次数过多,JIT会在编译的时候会进行锁粗化的优化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">test1()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> LockOptmistic().test1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别截图JIT编译 i &lt; 10000 &amp; i &lt; 100000  &amp; i &lt; 1000000 对应的效果</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20200211153628607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211153446382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211153124831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>锁消除</p>
</blockquote>
<ul>
<li>也就是在JIT在编译阶段发生对于非共享资源在程序代码进行加锁的处理,那么这个时候JIT识别是非共享资源,这个时候将直接跳过加锁的方式运行程序代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁消除的伪代码</span></span><br><span class="line">execute()&#123;</span><br><span class="line">	<span class="comment">// 线程封闭,属于线程私有的变量,此时非共享资源,加锁没有意义,JIT编译器会自动将锁进行消除</span></span><br><span class="line">	Object object = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;	</span><br><span class="line">	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出现上述的原因很多时候是由于工程师本身在编译不规范造成的,这种并非业务性逻辑错误,可以避免的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JIT Watch查看结果<br><img src="https://img-blog.csdnimg.cn/20200211143531328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>缩小锁的粒度(分片锁)</p>
</blockquote>
<ul>
<li>将一个存储同类数据的对象的容器拆分为更小的“容器”或者是“片段”, 在并发情况下针对小片段进行加锁,提升并发执行效率,降低锁的竞争, 比如ConcurrentHashMap(分片)与HashTable(整块)</li>
<li>注意: 并非分片锁执行效率一定比整块锁的方式执行效率快,只是分片能够降低cpu并发争抢锁的压力,要根据具体业务场景而定</li>
</ul>
<blockquote>
<p>锁分离</p>
</blockquote>
<ul>
<li>可以按照读写功能进行划分为读写锁,即写写互斥,读写互斥,读读共享,也可以按照指定的业务场景来对相应的程序代码设置对应的加锁方式,有效地提升并发执行的处理能力,降低锁之间的竞争,比如读写锁ReadWriteLock</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized基于JVM规范的工作原理(一)</title>
    <url>/2020/03/02/sync01/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-synchronized同步方法"><a href="#1-synchronized同步方法" class="headerlink" title="1. synchronized同步方法"></a>1. synchronized同步方法</h6><blockquote>
<p>synchronized同步方法的字节码还原</p>
</blockquote>
<ul>
<li>java声明的方法在jvm中的结构格式method_info<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">       u2             access_flags;</span><br><span class="line">       u2             name_index;</span><br><span class="line">       u2             descriptor_index;</span><br><span class="line">       u2             attributes_count;</span><br><span class="line">       attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其中关注method_info的access_flags取值<ul>
<li>ACC_SYNCHRONIZED,对应标示值为0x0020,作用是声明为同步方法,在jvm内部包装一个监视器锁被调用</li>
<li>ACC_PUBLIC,对应标示值为0x0001,作用声明方法为public,运行被包外的类公开访问</li>
</ul>
</li>
<li>带synchronized的部分java代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Account.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对应的java代码的字节码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 上述代码的字节码如下</span><br><span class="line">public synchronized void setBalance(double);</span><br><span class="line">    descriptor: (D)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dload_1</span><br><span class="line">         2: putfield      #2                  // Field balance:D</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 20: 0</span><br><span class="line">        line 21: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lcom/xiaokunliu/concurrency/sync/syncmethod/Account;</span><br><span class="line">            0       6     1 balance   D</span><br><span class="line"> ## 从字节码中可以看出在方法添加synchronized关键字,会在编译阶段多产生一个flag,即ACC_SYNCHRONIZED</span><br></pre></td></tr></table></figure>
<blockquote>
<p>synchronized同步方法的本质</p>
</blockquote>
</li>
<li>摘录jvm规范中的原文<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Method-level synchronization is performed implicitly, as part of method invocation and return.</span><br><span class="line">2) A synchronized method is distinguished in the run-time constant pool&#x27;s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. </span><br><span class="line">3) When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. </span><br><span class="line">4) During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method</span><br></pre></td></tr></table></figure></li>
<li>简言概括<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 方法级同步在JVM中是隐式执行的，是作为方法调用和返回的一部分</span><br><span class="line">2) 同步方法在运行时常量池的method_info结构中由ACC_SYNCHRONIZED标志加以区分，该标志由方法调用指令进行检查</span><br><span class="line">3) 执行线程识别到方法中含有ACC_SYNCHRONIZED标志将会获取一个监视器对象然后调用方法,最后而且不论当线程正常执行或是异常退出时将会释放监视器对象</span><br><span class="line">4) 在执行期间,执行线程持有监视器对象,而其他执行线程将无法获取监视器对象,如果方法抛出异常将会释放监视器对象</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2-synchronized同步代码块"><a href="#2-synchronized同步代码块" class="headerlink" title="2. synchronized同步代码块"></a>2. synchronized同步代码块</h6><blockquote>
<p>synchronized同步代码块字节码还原</p>
</blockquote>
<ul>
<li>java同步代码块<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cinema.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTickets1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (controlCinema1)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get controlCinema1 lock, add number is &quot;</span> + number);</span><br><span class="line">            <span class="keyword">this</span>.vacanciesCinema1 += number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>同步代码块对应的字节码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addTickets1(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=5, locals=4, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #3                  // Field controlCinema1:Ljava/lang/Object;</span><br><span class="line">         4: dup</span><br><span class="line">         5: astore_2</span><br><span class="line">        // ========================= //</span><br><span class="line">         6: monitorenter</span><br><span class="line">        // ========================= //</span><br><span class="line">         7: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        10: new           #10                 // class java/lang/StringBuilder</span><br><span class="line">        13: dup</span><br><span class="line">        14: invokespecial #11                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        17: invokestatic  #12                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">        20: invokevirtual #13                 // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">        23: invokevirtual #14                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        26: ldc           #20                 // String  get controlCinema1 lock, add number is</span><br><span class="line">        28: invokevirtual #14                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        31: iload_1</span><br><span class="line">        32: invokevirtual #16                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        35: invokevirtual #17                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        38: invokevirtual #18                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        41: aload_0</span><br><span class="line">        42: dup</span><br><span class="line">        43: getfield      #7                  // Field vacanciesCinema1:J</span><br><span class="line">        46: iload_1</span><br><span class="line">        47: i2l</span><br><span class="line">        48: ladd</span><br><span class="line">        49: putfield      #7                  // Field vacanciesCinema1:J</span><br><span class="line">        52: aload_2</span><br><span class="line">        // ========================= //</span><br><span class="line">        53: monitorexit</span><br><span class="line">        // ========================= //</span><br><span class="line">        54: goto          62</span><br><span class="line">        57: astore_3</span><br><span class="line">        58: aload_2</span><br><span class="line">        // ========================= //</span><br><span class="line">        59: monitorexit</span><br><span class="line">        // ========================= //</span><br><span class="line">        60: aload_3</span><br><span class="line">        61: athrow</span><br><span class="line">        62: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             7    54    57   any</span><br><span class="line">            57    60    57   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 42: 0</span><br><span class="line">        line 43: 7</span><br><span class="line">        line 44: 41</span><br><span class="line">        line 45: 52</span><br><span class="line">        line 46: 62</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      63     0  this   Lcom/xiaokunliu/concurrency/sync/syncAttribute/Cinema;</span><br><span class="line">            0      63     1 number   I</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 57</span><br><span class="line">          locals = [ class com/xiaokunliu/concurrency/sync/syncAttribute/Cinema, int, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br></pre></td></tr></table></figure></li>
<li>字节码解读<ul>
<li>jvm通过monitorenter来完成加锁的操作</li>
<li>53行的monitorexit之后是go语句到62行,属于程序正常退出释放锁的操作</li>
<li>59行的monitorexit之后是athrow的字节码指令,表示当程序异常的时候释放锁的操作</li>
<li>monitorenter和monitorexit支持编译指令来实现同步指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>synchronized同步代码块的工作原理</p>
</blockquote>
<ul>
<li>引入jvm规范原语<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Synchronization of sequences of instructions is typically used to encode the synchronized block of the Java programming language. </span><br><span class="line">2) The Java Virtual Machine supplies the monitorenter and monitorexit instructions to support such language constructs. </span><br><span class="line">3) Proper implementation of synchronized blocks requires cooperation from a compiler targeting the Java Virtual Machine</span><br></pre></td></tr></table></figure></li>
<li>简言概括之<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 指令序列的同步通常用于java程序中的同步代码块</span><br><span class="line">2) jvm支持在编译阶段执行同步指令</span><br><span class="line">3) 同步块的实现需要java编译器的支持</span><br></pre></td></tr></table></figure>
<h6 id="3-synchronized工作原理小结"><a href="#3-synchronized工作原理小结" class="headerlink" title="3. synchronized工作原理小结"></a>3. synchronized工作原理小结</h6><blockquote>
<p>结构化锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构化锁定是这样一种情况:在方法调用期间，给定监视器上的每个出口与该监视器上的前一个入口匹配。</span><br><span class="line">由于不能保证提交给Java虚拟机的所有代码都将执行结构化锁定，所以允许Java虚拟机的实现，</span><br></pre></td></tr></table></figure></li>
<li>jvm通过以下规则保证结构化锁定:<ul>
<li>不论方法是正常还是异常退出,jvm必须保证线程对监视器入口(monitorenter)的执行次数与对监视器出口(monitorexit)的执行次数相等</li>
<li>在方法调用期间,线程对监视器执行的出口次数(monitorexit)不可能超过对监视器入口的执行次数(monitorenter)</li>
</ul>
</li>
</ul>
<blockquote>
<p>工作原理本质</p>
</blockquote>
<ul>
<li>synchronized的实现是通过jvm的监视器的入口和出口来实现的</li>
<li>synchronized同步方法是隐式实现(编译阶段仅看到同步标志)</li>
<li>synchronized同步代码块是显示实现(编译阶段可见)</li>
</ul>
<blockquote>
<p>注意点</p>
</blockquote>
<ul>
<li>jvm通过一个单一的同步结构:监视器来支持方法和方法中的指令序列的同步</li>
<li>使用synchronized同步代码块不论程序是正常完成还是异常退出都会自动释放锁</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized基于内存语义的工作原理(二)</title>
    <url>/2020/03/04/sync02/</url>
    <content><![CDATA[<span id="more"></span>
<p>基于<a href="https://blog.csdn.net/wind_602/article/details/103873050"><strong>工作原理一</strong></a>可知同步关键字底层是基于JVM操作监视器的同步指令原语monitorenter和monitorexit来实现,这次将会通过抽象的内存语义来说明侧面说明加锁和解锁的方式</p>
<h6 id="1-工作内存与主内存"><a href="#1-工作内存与主内存" class="headerlink" title="1. 工作内存与主内存"></a>1. 工作内存与主内存</h6><blockquote>
<p>定义</p>
</blockquote>
<ul>
<li>主内存: 一般就是计算机操作系统上的物理内存,简言之,即使一般我们所说的计算机的内存含义</li>
<li>工作内存: 基于JMM(Java内存模型)规范规定,线程使用的变量将会把主内存的数据变量复制到自己线程栈的工作空间</li>
</ul>
<blockquote>
<p>线程工作内存与主内存的读写示意图</p>
</blockquote>
<p><strong>前面已经有介绍到<a href="https://blog.csdn.net/wind_602/article/details/103914263">CPU高速缓存的知识点</a>,以下是CPU简单的架构图以及工作内存与主内存的读写流程</strong><br><img src="https://img-blog.csdnimg.cn/20200111152758566.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上述我们可以看到,CPU中包含L1-L3的Cache,线程每次读写都需要先经过CPU高速缓存,这样便会产生数据缓存的不一致,前面已经有讲到CPU厂商针对这类问题做了改进,运用缓存一致性来达到最终数据的一致性,那么此时如果有一个需求是强一致性,即使是很短的时间内,我也需要保证写数据之后立马看到写数据成功后的效果,这时候怎么办呢?在JMM规范中为了解决这类内存共享的数据在不同线程不可见的问题,就制定一种规范来强制java程序中的线程直接跳过CPU高速缓存数据去读取主内存的数据,这就是解决内存数据的不可见的一种手段.</p>
<h6 id="2-synchronized的代码演示"><a href="#2-synchronized的代码演示" class="headerlink" title="2. synchronized的代码演示"></a>2. synchronized的代码演示</h6><ul>
<li>场景： 现在有一个共享变量sharedVar，thread-1执行写操作需要耗时500ms，而有一个线程thread-2由于网络原因延迟读操作耗时600ms，另一个线程thread-3正常读操作</li>
<li>期望的场景是希望写数据之后其他线程也知道数据已经发生改变了,需要读取最新的数据<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync2memory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync2memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer sharedVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        testForReadWrite();</span><br><span class="line"><span class="comment">//        testForReadWriteWithSync();</span></span><br><span class="line"> 		TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;finish the thread task,the final sharedVar %s ....\n&quot;</span>, sharedVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForReadWriteWithSync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">// modify the sharedVar</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500L</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (sharedVar)&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%s modify the shared var ...\n&quot;</span>, <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">                        sharedVar = <span class="number">20</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// network delay</span></span><br><span class="line">                   TimeUnit.MICROSECONDS.sleep(<span class="number">600L</span>);</span><br><span class="line">                   <span class="keyword">synchronized</span> (sharedVar)&#123;</span><br><span class="line">                       System.out.printf(<span class="string">&quot;%s read the shared var %s \n&quot;</span>, <span class="string">&quot;thread-2&quot;</span>, sharedVar);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (sharedVar)&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%s read the shared var %s \n&quot;</span>,  <span class="string">&quot;thread-3&quot;</span>, sharedVar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForReadWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">// modify the sharedVar</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500L</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s modify the shared var ...\n&quot;</span>, <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">                    sharedVar = <span class="number">20</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">// network delay</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">600L</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s read the shared var %s \n&quot;</span>, <span class="string">&quot;thread-2&quot;</span>, sharedVar);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s read the shared var %s \n&quot;</span>, <span class="string">&quot;thread-3&quot;</span> , sharedVar);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//thread1-3 start and join ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没有加synchronized方式的执行产生的一种结果(多次运行)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 	执行结果如下</span><br><span class="line">thread-3 read the shared var 10 </span><br><span class="line">thread-1 modify the shared var to 20  ...</span><br><span class="line">thread-2 read the shared var 10 </span><br><span class="line">finish the thread task,the final sharedVar 20 ....</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line">## 分析</span><br><span class="line">线程3正常执行,并且还没有在发生写操作之前就已经读取数据,属于正常输出</span><br><span class="line">线程1执行写操作耗时500ms并将数据进行修改同步到主内存中</span><br><span class="line">线程2由于网络延迟600ms,但是此时写操作已经完成,这时候读取出来的数据是属于脏数据,并不正确,因此线程2读取是其还没有被刷新的工作内存数据</span><br><span class="line">最后看到执行的结果输出是写操作之后的数据,说明了CPU最终会保证缓存数据的一致性</span><br><span class="line">最后的最后,这里仅仅是阐述上述问题,上述运行结果也可能发生thread-2会读取到正常的数据,只是在上述编码情况我们是无法保证线程2一定可以读取到正确的数据</span><br></pre></td></tr></table></figure></li>
<li>添加synchronized方式的执行结果(多次执行)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 多次执行结果如下:</span><br><span class="line">thread-3 read the shared var 10 </span><br><span class="line">thread-1 modify the shared var ...</span><br><span class="line">thread-2 read the shared var 20 </span><br><span class="line">finish the thread task,the final sharedVar 20 ....</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line">## 分析</span><br><span class="line">线程1执行写操作之后,我们可以看到线程2获取到的数据是线程1执行写操作之后的数据,现在程序可以保证线程2读取的数据是正常的</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="3-synchronized内存语义的理解"><a href="#3-synchronized内存语义的理解" class="headerlink" title="3. synchronized内存语义的理解"></a>3. synchronized内存语义的理解</h6><blockquote>
<p>内存语义小结</p>
</blockquote>
<ul>
<li>基于上述代码的执行结果可以看出,我们使用synchronized内使用的变量从线程的工作内存中清除或者称为失效,此时该变量就不会从工作内存中进行读取数据,而是直接从主内存中读取数据,从而保证缓存数据的强一致性</li>
<li>由此可知道,synchronized从内存语义上可以解决共享变量的内存可见性问题</li>
<li>从另一个角度而言,使用synchronized相当于jvm获取monitorenter的指令,此时会将该共享变量的缓存失效直接从主内存中加载数据到锁块的内存中,同时在进行monitorexit操作的指令时会将锁块的共享变量数据刷新到主内存中<blockquote>
<p>synchronized不足</p>
</blockquote>
</li>
<li>使用monitor的方式是属于metux lock的方式(重量级锁),会降低程序的性能(响应时间可能会变慢,相当于利用性能来换取数据的强一致性问题)</li>
<li>另外一个就是线程是由CPU进行调度,来回切换线程会带来额外的调度开销</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized的工作原理(三)</title>
    <url>/2020/03/06/sync03/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-synchronized的锁存储以及锁分类"><a href="#1-synchronized的锁存储以及锁分类" class="headerlink" title="1. synchronized的锁存储以及锁分类"></a>1. synchronized的锁存储以及锁分类</h6><blockquote>
<p>synchronized的存储位置: 对象MarkWork</p>
</blockquote>
<ul>
<li>JVM的ObjectHeader信息<ul>
<li>MarkWord: hashcode(哈希code) + age(分代年龄age) + biased_lock(偏向锁标志) + lock (锁标志)</li>
<li>Class Metadata Address(类元信息地址)</li>
<li>Array Length: 如果对象是一个数组类型,则存储数组长度</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200114151521308.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>MarkWord信息<br><img src="https://img-blog.csdnimg.cn/20200114151647395.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>JVM中synchronized使用的锁</p>
<ul>
<li>无锁: 严格意义上应该说是正常对象,包含hashcode + 分代年龄age + 无偏向锁标志 + 锁状态标志</li>
<li>轻量级锁: 栈记录的地址 + 锁状态</li>
<li>监视器锁: 对象/监视器地址 + 锁状态</li>
<li>GC标志: GC链接地址等 + 锁状态</li>
<li>偏向锁(JVM提供的): 当前执行的线程ID +支持偏向锁标记的epoch + 分代年龄age + 偏向锁标志 + 锁状态</li>
</ul>
</li>
<li><p>JVM源码关于MarkWord的说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// markWord.hpp</span></span><br><span class="line"><span class="comment">//  32 bits,32bit的MarkWord存储信息如下:</span></span><br><span class="line"><span class="comment">//  hash:25bit ---------------&gt;| age:4bit       biased_lock:1bit lock:2bit (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:23bit epoch:2bit age:4bit       biased_lock:1bit lock:2bit (biased object)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  64 bits, 64bit的MarkWord存储的信息信息如下</span></span><br><span class="line"><span class="comment">//  unused:25bit hash:31bit --&gt;| unused_gap:1   age:4bit    biased_lock:1bit lock:2bit (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54bit epoch:2bit unused_gap:1   age:4bit    biased_lock:1bit lock:2bit (biased object)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM底层代码定义的状态锁的值</span></span><br><span class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br><span class="line"><span class="comment">//                                               not valid at any other time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程持有偏向锁</span></span><br><span class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名偏向锁,说明当前线程不持有偏向锁,但是对象已被其他线程设置为偏向锁</span></span><br><span class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>jvm底层使用的锁</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码定义的锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span>			// 轻量级锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicObjectLock</span>   // 对象<span class="title">or</span>监视器锁</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>synchronized的锁细节问题说明</p>
</blockquote>
<ul>
<li>偏向锁: JVM创建对象如果没有发生竞争,则默认开启偏向锁,即偏向锁标志+无锁状态,如果创建对象多次(JVM经过统计)之后发现处于竞争状态将会关闭偏向锁,这是在JVM底层实现的,在JVM源码中显示为BiasedLock</li>
<li>轻量级锁:JVM启动并创建线程的时候,会在栈帧中为线程分配内存栈空间信息,此时线程栈会开辟一个锁记录(Lock Record)空间,并且会将锁定对象的mark word复制到锁记录空间中,jvm称锁记录的mark word为displaced_mark_word,线程将通过CAS完成对象的mark word复制操作,成功则获得锁,失败表示有其他锁竞争,将会通过自旋锁的方式获取(不断CAS循环获取)</li>
<li>重量级锁:如果上述的轻量级锁自旋一定次数之后仍然获取锁失败,便会升级称为重量级锁,使用重量级锁的时候锁将无法降级,这时候jvm提供使用快速获取锁的方式来实现,比如quick_enter/reenter/complete_exit,直接绕过slow-path的路径,jvm称重量级锁为heavy weight monitor</li>
</ul>
<h6 id="2-synchronized加锁原理"><a href="#2-synchronized加锁原理" class="headerlink" title="2. synchronized加锁原理"></a>2. synchronized加锁原理</h6><blockquote>
<p>synchronized的enter加锁源码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronizer.hpp</span></span><br><span class="line"><span class="comment">// This is the &quot;slow path&quot; version of monitor enter and exit.</span></span><br><span class="line"><span class="comment">// &quot;slow path&quot;: 理解为缓慢路径,也就是jvm会通过当前方法检测对象是否处于竞争状态来确定锁的升级,以便于加快程序的性能(体现在响应时间和吞吐量)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁具体实现:synchronizer.cpp</span></span><br><span class="line"><span class="comment">// 校验是否开启偏向锁,默认是开启偏向锁的设置</span></span><br><span class="line"><span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// 撤销偏向锁操作</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">    <span class="comment">// Java线程执行存在竞争,将当前的obj的markword设置为非偏向锁状态</span></span><br><span class="line">      BiasedLocking::<span class="built_in">revoke</span>(obj, THREAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// is_at_safepoint: 程序的所有Java用户线程都处于停止或者阻塞状态,除了在VM线程和本地执行的Java线程可执行</span></span><br><span class="line">    <span class="comment">// 阻塞所有Java线程,安全撤销偏向锁</span></span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  markWord mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark.<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (mark.<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">    <span class="comment">// 设置为轻量级锁</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="comment">// CAS自旋锁,如果失败将升级为重量级别锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark == <span class="built_in">obj</span>()-&gt;<span class="built_in">cas_set_mark</span>(markWord::<span class="built_in">from_pointer</span>(lock), mark)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark.<span class="built_in">has_locker</span>() &amp;&amp;</span><br><span class="line">             THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark.<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="comment">// 锁升级失败,也就是不需要升级锁,表示当前线程已经获取锁了</span></span><br><span class="line">    <span class="comment">// 不需要再获取相同的锁,相当于重入锁/锁消除,直接设置对应的线程栈帧的displaced_mark_word为null</span></span><br><span class="line">    <span class="built_in">assert</span>(lock != mark.<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>().<span class="built_in">value</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(markWord::<span class="built_in">from_pointer</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unused_mark : it is only used to be stored into BasicLock as the indicator that the lock is using heavyweight monitor</span></span><br><span class="line">  <span class="comment">// 升级为重量级锁</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markWord::<span class="built_in">unused_mark</span>());</span><br><span class="line">  <span class="comment">// 锁升级的原因为: inflate_cause_monitor_enter,线程发生竞争争抢锁</span></span><br><span class="line">  <span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>(), inflate_cause_monitor_enter)-&gt;<span class="built_in">enter</span>(THREAD);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized偏向锁的加锁与撤销流程</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200115103837344.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>synchronized锁升级流程(轻量级锁升级到重量级锁过程)</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200115102655297.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="3-synchronized解锁过程"><a href="#3-synchronized解锁过程" class="headerlink" title="3.synchronized解锁过程"></a>3.synchronized解锁过程</h6><blockquote>
<p>synchronized的exit源码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronizer.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(oop obj, BasicLock* lock, Thread* THREAD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现:synchronized.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于偏向锁的处理,撤销操作是加锁的过程,这里仅仅是对偏向锁存在的验证</span></span><br><span class="line">  <span class="comment">// 省略对应代码 .... </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对markword的状态进行诊断判读,没有任何其他工作,</span></span><br><span class="line">  <span class="comment">// 省略代码 .....</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放轻量级锁,本质上就是一个逆向恢复markword的过程</span></span><br><span class="line">  <span class="keyword">if</span> (mark == markWord::<span class="built_in">from_pointer</span>(lock)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(dhw.<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;<span class="built_in">cas_set_mark</span>(dhw, mark) == mark) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放重量级锁,需要通过slow path的方式进行释放锁</span></span><br><span class="line">  <span class="comment">// We have to take the slow-path of possible inflation and then exit.</span></span><br><span class="line">  <span class="built_in">inflate</span>(THREAD, object, inflate_cause_vm_internal)-&gt;<span class="built_in">exit</span>(<span class="literal">true</span>, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized解锁的流程</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200115105113844.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="4-小结-JVM对synchronized的优化策略"><a href="#4-小结-JVM对synchronized的优化策略" class="headerlink" title="4. 小结:JVM对synchronized的优化策略"></a>4. 小结:JVM对synchronized的优化策略</h6><blockquote>
<p>锁优化目的</p>
</blockquote>
<ul>
<li>提升响应时间</li>
<li>增加程序的吞吐量</li>
<li>基于上述代码中,jvm底层代码存在缓慢路径加锁,说明也存在更快速地加锁方式,避免更多的加锁处理流程,提供锁升级的方式来走“<strong>捷径</strong>”调用加锁方法</li>
</ul>
<blockquote>
<p>优化手段</p>
</blockquote>
<ul>
<li>使用偏向锁,如果使用资源没有存在竞争状态,那么将开启偏向锁的方式进行加锁,通过上述可以看到偏向锁的流程,并无需消耗过多的资源,仅操作使用资源的markword信息,适用于单线程或者是并发量不多的场景下</li>
<li>轻量级锁:如果使用资源存在竞争状态(有一定的并发基础),那么jvm底层就会关闭偏向锁的设置,开启使用轻量级锁,通过将在线程已经开启Lock Record记录使用资源对象的markword信息,同时将markword的bitfields设置为栈帧引用地址,但是轻量级锁会出现CAS自旋消耗CPU资源,使用轻量级锁可以在并发条件下提升响应速度</li>
<li>重量级锁:线程不自旋转,不消耗CPU资源,jvm底层同时在锁升级之后会直接使用重量级锁对应的加锁和解锁方式,也就是走“捷径”方式调用,但是会阻塞线程</li>
<li>自旋锁: 可以看到这个是在使用CAS对使用资源进行循环compare and set的操作,主要是为了防止线程在操作系统底层产生阻塞,采用消耗CPU的方式来不断对使用资源进行CAS操作,但是会存在一些问题,一个是什么时候获取锁是一个未知数,在jvm底层会通过计数器来设置上限,达到上限之后会采用重量级锁的方式进行加锁;另一个就是ABA的问题(就是线程无法知道使用资源是否被变更,无法辨别前后的使用资源是否一致)</li>
<li>锁消除:在VM进行JIT编译时,会通过上下文的扫描来消除不存在共享资源竞争的锁,在上述的锁升级失败代码中,就是不允许对相同的锁进行加锁操作</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程synchronized使用</title>
    <url>/2020/03/12/sync_used/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-synchronized-同步方法"><a href="#1-synchronized-同步方法" class="headerlink" title="1. synchronized 同步方法"></a>1. synchronized 同步方法</h6><ul>
<li>作用在实例化方法上,监视器锁对象为当前实例对象this</li>
<li>作用在静态方法上,监视器锁对象为当前Class对象</li>
<li>不论线程执行同步代码正常完成抑或是异常退出的时候,将会自动释放监视器锁</li>
<li>同步实例方法产生的效果:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 控制当前方法只能有一个线程执行，其他线程只能处于阻塞状态</span><br><span class="line">2. 换言之,每个使用synchronized关键字声明的方法都是处于一个临界区，而Java只允许执行对象的一个临界区</span><br></pre></td></tr></table></figure></li>
<li>同步静态方法产生的效果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 静态方法同步仅保证声明为static且使用的监视器锁为当前类对象时只有一个线程执行,其他线程处于阻塞状态</span><br><span class="line">2. 需要注意的一点是,对于共享资源,如果同时存在于同一个类声明的static和非static的方法,将无法保证共享数据的安全性,因为实例方法和静态方法的监视器锁对象不同,无法达到预期效果</span><br></pre></td></tr></table></figure></li>
<li>实例方法示例(主要演示同步方法)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Account.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = balance;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp+=amount;</span><br><span class="line">        balance=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tmp=balance;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-=amount;</span><br><span class="line">        balance=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bank.java</span></span><br><span class="line"><span class="comment">// 实现Runnable接口,run方法负责循环100次调用subtractAmount方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Company.java</span></span><br><span class="line"><span class="comment">// 实现Runnable接口,run方法负责循环100次调用addAmount方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setBalance(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Company company = <span class="keyword">new</span> Company(account);</span><br><span class="line">        Thread companyThread = <span class="keyword">new</span> Thread(company);</span><br><span class="line"></span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank(account);</span><br><span class="line">        Thread bankThread = <span class="keyword">new</span> Thread(bank);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Account : Initial Balance: %f\n&quot;</span>,account.getBalance());</span><br><span class="line"><span class="comment">//        Start the threads</span></span><br><span class="line">        companyThread.start();</span><br><span class="line">        bankThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始进行转账操作，使用join，也就是等待join的线程执行完成之后才进行下一步操作</span></span><br><span class="line">            companyThread.join();</span><br><span class="line">            bankThread.join();</span><br><span class="line">            <span class="comment">// 结束转账操作可以进行下一步的操作，</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;Account : Final Balance: %f\n&quot;</span>,account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行结果<br><img src="https://img-blog.csdnimg.cn/20200107100012147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>扩展<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上述的同步代码也可以替换为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// not shared data operation</span></span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="comment">// balance operation</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// not shared data operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="2-synchronized同步代码块"><a href="#2-synchronized同步代码块" class="headerlink" title="2. synchronized同步代码块"></a>2. synchronized同步代码块</h6><ul>
<li>作用在同步代码块上,做到尽可能在方法中仅针对共享变量进行同步加锁的操作</li>
<li>同步块的锁监视器对象可以为this/当前Class的对象/类实例属性/类对象属性等等,只需要保证在同步代码块的监视器是唯一的即可</li>
<li>不论程序正常执行还是异常退出将会自动释放监视器锁</li>
<li>代码示例(主要演示同步块)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cinema.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> vacanciesCinema1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> vacanciesCinema2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过锁类实例的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object controlCinema1, controlCinema2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.controlCinema1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">this</span>.controlCinema2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">this</span>.vacanciesCinema1 = <span class="number">20L</span>;</span><br><span class="line">        <span class="keyword">this</span>.vacanciesCinema2 = <span class="number">20L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sellTickets1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (controlCinema1)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get controlCinema1 lock, execute sellTickets1 vacanciesCinema1 number &quot;</span> + number);</span><br><span class="line">            <span class="keyword">if</span> (number &lt; <span class="keyword">this</span>.vacanciesCinema1)&#123;</span><br><span class="line">                <span class="keyword">this</span>.vacanciesCinema1 -= number;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sellTickets2</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (controlCinema2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get controlCinema2 lock, execute sellTickets2 vacanciesCinema2 number &quot;</span> + number);</span><br><span class="line">            <span class="keyword">if</span> (number &lt; <span class="keyword">this</span>.vacanciesCinema2)&#123;</span><br><span class="line">                <span class="keyword">this</span>.vacanciesCinema2 -= number;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅对应sellTickets1有同步效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTickets1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (controlCinema1)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get controlCinema1 lock, add number is &quot;</span> + number);</span><br><span class="line">            <span class="keyword">this</span>.vacanciesCinema1 += number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅对应sellTickets2有同步效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTickets2</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (controlCinema2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get controlCinema2 lock, add number is &quot;</span> + number);</span><br><span class="line">            <span class="keyword">this</span>.vacanciesCinema2 += number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get方法....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明TicketOffice实现Runnable接口,run方法随机调用上述带有synchronized关键字的方法</span></span><br><span class="line"><span class="comment">// 代码省略 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Cinema cinema = <span class="keyword">new</span> Cinema();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于操作的锁分别只针对vacanciesCinema1, vacanciesCinema2</span></span><br><span class="line">        <span class="comment">// 获取controlCinema1 lock 只能操作vacanciesCinema1</span></span><br><span class="line">        <span class="comment">// 获取controlCinema2 lock 只能操作vacanciesCinema2</span></span><br><span class="line">        TicketOffice ticketOffice1 = <span class="keyword">new</span> TicketOffice(cinema);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ticketOffice1);</span><br><span class="line"></span><br><span class="line">        TicketOffice2 ticketOffice2 = <span class="keyword">new</span> TicketOffice2(cinema);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ticketOffice2);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程1和线程2 执行完成，因此需要加入join方法</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;room1 number is &quot;</span> + cinema.getVacanciesCinema1());</span><br><span class="line">        System.out.println(<span class="string">&quot;room2 number is &quot;</span> + cinema.getVacanciesCinema2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="3-线程通信"><a href="#3-线程通信" class="headerlink" title="3. 线程通信"></a>3. 线程通信</h6><blockquote>
<p>与线程wait()/notify()/notifyAll()的使用</p>
</blockquote>
<ul>
<li>q1: 为什么需要使用监视器锁来完成线程通信?</li>
<li>q2: 代码中使用while而不使用if的原因是什么?</li>
<li>q3: wait与notify在代码中分别起到的作用是什么?</li>
<li>代码示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EventStorage.java</span></span><br><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO write your logic code</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = <span class="number">10</span>;</span><br><span class="line">        storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 思考:使用while而不使用if的原因是什么?</span></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storage.offer(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.printf(<span class="string">&quot;Set: %d \n&quot;</span>, storage.size());</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//// 思考:使用while而不使用if的原因是什么?</span></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Get size: %d, get value: %s \n&quot;</span>, storage.size() , storage.poll());</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer.java</span></span><br><span class="line"><span class="comment">// 负责循环100次调用EventStorage的get方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer.java</span></span><br><span class="line"><span class="comment">// 负责循环100次调用EventStorage的set方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO write your logic code</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventStorage eventStorage = <span class="keyword">new</span> EventStorage();</span><br><span class="line"></span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(eventStorage));</span><br><span class="line">        Thread consumerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(eventStorage));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line"></span><br><span class="line">        producerThread.join();</span><br><span class="line">        consumerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;done !!! &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>正常执行结果</strong></p>
</blockquote>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200107102203945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>q1: 需要使用监视器锁完成通信原因</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将上述的代码的synchronized去掉</span></span><br><span class="line"><span class="comment">// 执行main方法</span></span><br><span class="line"><span class="comment">// 执行结果如下</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200108105104581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>结论: 调用wait方法之前需要通过synchronized来添加监视器锁完成线程通信,否则会抛出异常:Exception in thread “Thread-1” java.lang.IllegalMonitorStateException</strong></p>
<blockquote>
<p><strong>q2: 代码中使用while而不使用if的原因是什么?</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将while更改为if</span></span><br><span class="line"><span class="comment">// 执行main方法</span></span><br><span class="line"><span class="comment">// 执行结果如下</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200108111809398.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200108111843366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>原因分析<ul>
<li>从代码中我们想要的效果是当队列满了之后才通知消费者进行消费,队列为空的时候才让生产者进行生产数据,但是上述结果并没有等待队列全满就开始进行消费</li>
<li>从执行结果看,使用if一次性条件判断无法保证队列完全为空或者为满的情况才进行消费,因此需要在调用wait方法的时候需在while循环中不断检查队列的情况</li>
</ul>
</li>
</ul>
<blockquote>
<p>q3: 针对上述情况对wait以及notify进行小结</p>
</blockquote>
<ul>
<li>wait方法<ul>
<li>当前线程是通过共享变量调用wait方法,并且调用该线程的时候将会被挂起阻塞</li>
<li>其他线程调用该共享变量的notify/notifyAll方法时将有机会重新获取锁</li>
<li>同时如果其他线程执行过程中调用当前线程的中断方法也会退出有机会重新获取锁</li>
<li>wait方法调用之前必须先获得监视器进行加锁,否则会抛出异常错误</li>
</ul>
</li>
<li>notify方法<ul>
<li>notify调用必须是在wait方法之后调用,因为只有当线程获取到监视器锁之后才可以调用notify进行唤醒</li>
<li>调用notify唤醒的线程需要和其他线程进行竞争获取监视器锁,之后才能返回调用的wait方法并继续往下执行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程核心方法简介</title>
    <url>/2020/03/16/thread_method/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="1-线程终止"><a href="#1-线程终止" class="headerlink" title="1. 线程终止"></a>1. 线程终止</h5><blockquote>
<p>基于可见性的volatile实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义任务线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;query data ....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;query data done ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;writing data done ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行main方法</span></span><br><span class="line"> 	<span class="keyword">final</span> VolatileTask task = <span class="keyword">new</span> VolatileTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             task.read();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"></span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             task.write();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">query data ....</span><br><span class="line">query data ....</span><br><span class="line">query data ....</span><br><span class="line">writing data done ....</span><br><span class="line">query data done ....</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>上述执行的结果属于线程执行正常结束</li>
<li>上述是在client模式下执行,没有执行重排序操作,在JMM规范中,volatile保持可见性,在字节码层面,volatile带有修饰符ACC_VOLATILE,在JVM规范中有声明为没有缓存,也就是直接从主内存读取数据,因此在另一个线程可以读取到flag的最新值</li>
</ul>
</li>
</ul>
<blockquote>
<p>stop方法以及存在的问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;time=%s,i=%d, j=%d%n&quot;</span>, System.currentTimeMillis(), i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line">	Task task = <span class="keyword">new</span> Task();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">     t1.stop();</span><br><span class="line"></span><br><span class="line">     task.output();</span><br><span class="line">     <span class="keyword">while</span> (t1.isAlive())&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 保证线程已经终止</span></span><br><span class="line">     task.output();</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 线程未终止</span><br><span class="line">time=1582099251750,i=1, j=0</span><br><span class="line">// 线程已终止</span><br><span class="line">time=1582099251769,i=1, j=0</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>根据上述执行的结果,执行stop方法无法保证数据达到我们预期值,即j=1</li>
<li>其次也可以看出stop方法调用执行之后对线程是无法预测的,也就是说线程在执行的过程中突然收到停止的方法“蒙圈”了,无法捕获到异常信息</li>
<li>最后一点就是在同步代码中结束的时候,stop方法直接退出并没有将同步代码完全执行完</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用interrupt方法中断线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task 代码不变</span></span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line">	Task task = <span class="keyword">new</span> Task();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">     t1.start();</span><br><span class="line"></span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">     t1.interrupt();</span><br><span class="line"></span><br><span class="line">     task.output();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (t1.isAlive())&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 保证线程已经终止</span></span><br><span class="line">     task.output();</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">	at com.xiaokunliu.homework.thread.base.methods.Task.run(ThreadStop.java:87)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">time=1582099560454,i=1, j=0</span><br><span class="line">time=1582099560475,i=1, j=1</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>可以看出,上述执行interrupt方法之后,会在线程中抛出中断异常,线程可以进行捕获处理</li>
<li>其次中断操作能够保证同步操作中的代码能够被执行,从代码中也可以知道是因为可以处理中断异常,因此在实际开发过程中线程可以业务策略进行处理保证数据是正常可预期的</li>
</ul>
</li>
</ul>
<h6 id="2-线程join方法"><a href="#2-线程join方法" class="headerlink" title="2. 线程join方法"></a>2. 线程join方法</h6><blockquote>
<p>join的场景</p>
</blockquote>
<p>假设现在有一个业务场景是查询直播信息,而查询直播信息需要几个步骤完成,一个是获取用户的频道信息,二是查询是否在推荐直播位置中,三是该直播是否正在直播,上述三个接口分别是在基础组,应用组和直播组开发团队进行维护,这个时候为了完成需求,我需要通过接口的方式进行分别调用然后汇聚再返回,此时我们可以开三个线程,一个是处理用户频道查询,一个是查询是否在推荐位中,一个是查询是否正在直播的状态,于是有以下代码(伪代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main方法</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// get user channel </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// get user recommand lives</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// get user get live status</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是处理汇总的数据方式,因此必须等待上述执行完成</span></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">t3.join();</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<ul>
<li>join方法就是在当前线程调用join方法的线程中的任务执行完成之后再进行下一步的操作</li>
<li>其次基于上述的应用场景,还可以使用CountDownLatch或者是Future/Callable抑或是join/fork框架实现</li>
</ul>
</li>
</ul>
<h5 id="3-线程的yeild方法"><a href="#3-线程的yeild方法" class="headerlink" title="3. 线程的yeild方法"></a>3. 线程的yeild方法</h5><blockquote>
<p>yeild定义与理解</p>
</blockquote>
<p>yield是属于一个由static native 修饰的底层实现机制,它的作用是一个“不完全让出CPU资源的权利”来调度线程<br><strong>现在有一个应用场景: 假设执行一个耗时且不重要的A任务需要10s,而执行一个紧急不耗时的B任务需要1s,那么这个时候当启动A线程的时候,在A线程中调用yield()方法来告诉CPU说我当前执行的任务不是很重要但是比较耗时,可以适当让出CPU资源优先给其他紧急处理任务的线程执行</strong><br><strong>类比于一个生活场景就是去看医生,医生可能会在会诊一个普通病人的时候突然遇到重症病人,需要紧急优先处理的场景</strong></p>
<blockquote>
<p>yeild示例代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;线程1&quot;</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="comment">// 执行完成需要2s</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行重要的事情&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(<span class="string">&quot;线程2&quot;</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">                  <span class="comment">// 让给执行重要的线程优先执行，当前为不重要且耗时操作</span></span><br><span class="line">                  Thread.yield();</span><br><span class="line">                  TimeUnit.SECONDS.sleep(<span class="number">12L</span>);</span><br><span class="line">                  System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行不重要的事情。。。&quot;</span>);</span><br><span class="line">              &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证t2 先执行</span></span><br><span class="line">      t2.start();</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      t2.join();</span><br><span class="line">      t1.join();</span><br><span class="line">      System.out.println(<span class="string">&quot;执行完成。。。&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1执行重要的事情</span><br><span class="line">线程2执行不重要的事情。。。</span><br><span class="line">执行完成。。。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之线程池原理</title>
    <url>/2020/03/18/thread_pool/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-线程池作用"><a href="#1-线程池作用" class="headerlink" title="1. 线程池作用"></a>1. 线程池作用</h6><blockquote>
<p>使用背景</p>
</blockquote>
<ul>
<li>在并发大量异步任务处理程序中,每执行一个任务就需要创建一个线程,同时任务执行完毕之后需要将线程销毁.我们知道JVM创建线程的时候需要为其分配线程栈空间以及一些初始化操作,同时销毁的过程需要回收线程栈空间并由gc释放资源,期间都需要耗费一定的时间,因此一个任务的最终执行时间=创建线程newTime + 程序执行excuteTime + 线程销毁的gcTime,如果期间newTime+gcTime &gt;  excuteTime,那么这时候执行任务创建线程在程序中就显得十分不划算</li>
<li>线程执行需要JVM分配线程栈空间,需要从系统内存申请,如果创建的线程过多,那么就容易导致内存空间不够用导致内存溢出,默认的线程栈空间大小是1M</li>
<li>线程是由操作系统的CPU进行调度,因此并发多线程执行时CPU需要分配时间片并发执行线程,也就是线程并发执行是需要来回切换CPU的context,严重影响性能</li>
<li>并发环境下,如果创建的线程很多,增加对线程的维护和管理的困难</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<ul>
<li>运用资源重复利用的思维,我们建立一个“池”的概念,多任务异步执行通过线程池实现线程复用,利用池化技术来分配和管理线程的使用,避免线程频繁创建和销毁消耗更多的时间,<strong>提高并发执行效率</strong></li>
<li>其次,<strong>通过线程池我们可以控制线程的数量,可以根据指定的策略来管理线程</strong>,比如任务过多,线程处理不过来,可以分配新的线程,当线程数量达到上限时,可以自定义策略管理任务,要么是放入阻塞队列中等待线程消费完成再继续,要么直接丢弃任务,相比单个线程处理方式,灵活性更大,也容易管理</li>
<li><strong>最后,由于池可回收线程资源,能够降低资源消耗</strong></li>
</ul>
<h6 id="2-线程池相关API"><a href="#2-线程池相关API" class="headerlink" title="2. 线程池相关API"></a>2. 线程池相关API</h6><blockquote>
<p>线程池接口API</p>
</blockquote>
<ul>
<li><p>线程池核心接口与实现类类图<br><img src="https://img-blog.csdnimg.cn/20200205220103135.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>Executor &amp; ExecutorService接口核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executor.java</span></span><br><span class="line"><span class="comment">// 从线程池中分配一个线程执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;		</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecutorService.java</span></span><br><span class="line"><span class="comment">// 关闭线程池,会将已提交的任务执行完毕再关闭线程池,不接受新的提交任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;					</span><br><span class="line"><span class="comment">// 立即关闭,不论是否有任务正在执行还是已提交未执行,都立即退出jvm不再执行,返回已提交未执行的任务</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池是否关闭</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池调用shutdown()后,所有任务是否已经执行完成</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 不论是线程中断,超时还是线程池shutdown()发生,将会阻塞知道所有任务执行完成</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 提交Callable任务返回Future,用于获取Callable执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">// 提交Runable任务,并返回Future对象,同时将执行结果传入result</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"><span class="comment">// 提交提交Runable任务,并返回Future对象,执行结果为null</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task)</span><br><span class="line"><span class="comment">// 执行一系列的任务,并返回对应的Future集合对象,同时Future包含task的执行结果</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 执行一系列任务,其中任意一个执行成功将返回Future对象并取消其他任务的执行,Future包含成功执行task的结果</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口ScheduledExecutorService核心方法(可选择)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要用于处理定时任务</span></span><br><span class="line"><span class="comment">//ScheduledExecutorService.java</span></span><br><span class="line"><span class="comment">// 创建并执行一个一次性定时任务,指定在 delay&amp;unit(时长+时间单位) 时间点将会执行</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 下面两个方法主要是创建并执行一个周期性任务,如果发生异常会退出程序</span></span></span><br><span class="line"><span class="function"><span class="comment">// 区别在于</span></span></span><br><span class="line"><span class="function"><span class="comment">// scheduleAtFixedRate执行周期任务之后,如果任务超过指定的周期时间,下一个任务会立刻执行不会等待</span></span></span><br><span class="line"><span class="function"><span class="comment">// scheduleWithFixedDelay执行任务超过周期时间,仍然会等待delay时间再进行下一个任务的执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable command,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">long</span> initialDelay,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">long</span> period,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  TimeUnit unit)</span></span>;  </span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                   <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                                   TimeUnit unit);                                                                               </span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池工具类API</p>
</blockquote>
<ul>
<li><p>线程池与线程池工具类类图关系<br><img src="https://img-blog.csdnimg.cn/20200206105559185.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>根据类图可以将线程池划分为定时和非定时</p>
<ul>
<li>非定时线程池实现类: ThreadPoolExecutor / ForkJoinPool /  FinalizableDelegatedExecutorService</li>
<li>定时线程池实现类:  ScheduledThreadPoolExecutor /  DelegatedScheduledExecutorService</li>
</ul>
</li>
<li><p>线程池工具类Executors创建线程池的核心方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors.java</span></span><br><span class="line"><span class="comment">// 创建一个基于无界的链表阻塞队列(LinkedBlockingQueue)且为固定线程数为nThreads的线程池</span></span><br><span class="line"><span class="comment">// 无界: 队列没有指定容器大小,可以不断添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个基于无界的同步队列(SynchronousQueue)且线程数无限制(0 - Integer.MAX_VALUE)的线程池</span></span><br><span class="line"><span class="comment">// 1.该线程池线程空闲时间为60s,超时将销毁线程,适用于耗时较小的异步任务</span></span><br><span class="line"><span class="comment">// 2.不存储数据的同步队列(最多只有一个元素的队列),仅作为缓存作用,也就是等待内部创建工作线程完成之后就立即交由线程进行消费</span></span><br><span class="line"><span class="comment">// 3.适用于处理任务但是不确定线程个数的场景,同时为了防止不断创建线程造成CPU资源消耗过多,一般会添加对应的线程最大数而不是Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个基于延迟的无界任务队列且能够执行定时任务的线程池</span></span><br><span class="line"><span class="comment">// 线程池的数量corePoolSize - Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个基于延迟的无界任务队列,能够执行定时任务且只有一个线程的线程池</span></span></span><br><span class="line"><span class="function"><span class="comment">// 当该线程池中的线程被中断或者异常退出的时候,线程池会新创建一个线程继续执行后续的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Executors包含的组件<ul>
<li><strong>接口ThreadFactory实现类</strong>,借助内部定义的默认工厂类创建线程,并为当前线程池中的线程命名比较规范的线程名称,有默认线程工厂以及带有ACC控制权限的线程工厂</li>
<li><strong>代理线程池类</strong>,负责创建线程池,即将实现ExecutorService的线程池包装起来代理其完成相应的方法实现,具体实现类FinalizableDelegatedExecutorService是重写父类方法finalize以便gc调用回收线程池,DelegatedScheduledExecutorService是实现定时功能</li>
<li><strong>实现Callable接口的任务类</strong>,RunnableAdapter主要实现处理任务task的执行结果返回给主线程,PrivilegedCallable以及PrivilegedCallableUsingCurrentClassLoader增加ACC控制权限设置来执行任务</li>
</ul>
</li>
</ul>
<h6 id="3-线程池原理"><a href="#3-线程池原理" class="headerlink" title="3. 线程池原理"></a>3. 线程池原理</h6><blockquote>
<p>线程池核心类ThreadPoolExecutor</p>
</blockquote>
<ul>
<li><p>ThreadPoolExecutor类图<br><img src="https://img-blog.csdnimg.cn/20200205230637844.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>ThreadPoolExecutor类下核心组件</p>
<ul>
<li>工作线程Worker:包装一个线程以及任务的工作线程,在没有任务的时候处于等待,可以循环任务,并且实现AQS接口,从类图中可以看出具备独占锁的功能</li>
<li>ThreadFactory:用于创建线程的工厂类,并且为线程池中的每个线程分配更有意义的名称</li>
<li>任务接口Runnable: 每个任务必须实现的接口,以便于工作线程调度任务的执行</li>
<li>任务队列BlockingQueue: 用于存放没有处理的任务,相当于缓冲作用</li>
<li>拒绝处理策略RejectedExecutionHandler: 对不满足线程池执行条件的任务采取指定的处理策略</li>
</ul>
</li>
<li><p>RejectedExecutionHandler策略</p>
<ul>
<li>CallerRunsPolicy: 只用获取当前拒绝的任务的线程且线程是活跃状态的时候来执行任务,如果当前线程池已经被关闭将不会执行</li>
<li>AbortPolicy: 直接抛出异常, 告知当前的任务已经无法加入到阻塞队列中</li>
<li>DiscardPolicy: 不做任何处理,空方法,直接将任务丢弃,不执行</li>
<li>DiscardOldestPolicy: 移除队列中最靠前的一个任务,并执行当前拒绝的任务</li>
</ul>
</li>
<li><p>ThreadPoolExecutor 构造方法代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadPoolExecutor构造方法参数说明</p>
<ul>
<li>corePoolSize: 线程池保持活跃的线程数</li>
<li>maximumPoolSize: 线程池可创建最大的线程数,<strong>如果队列为无界队列,则maximumPoolSize没有效果</strong></li>
<li>keepAliveTime: 线程池中的线程保持活跃的时长, <strong>如果超过时长, 并且线程池中的线程个数比核心线程数多,那么空闲的线程将会被回收</strong></li>
<li>unit: keepAliveTime的时间单位</li>
<li>threadFactory: 借助线程工厂类创建线程</li>
<li>handler: 当线程池中的队列已经满&amp;线程数达到最大值,此时添加的新任务将采取handler策略进行处理</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程池执行流程</p>
</blockquote>
<ul>
<li><p>ThreadPoolExecutor核心方法代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ctl 高三位表示线程池状态,低(Integer.SIZE - 3)位表示线程个数,也就是ctl = 线程状态 + 线程个数</span></span><br><span class="line">	<span class="comment">// 获取当前池的状态和线程个数的组合值</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当前线程的个数是否小于核心线程数</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">     	 <span class="comment">// 创建新的线程执行任务,会通过加锁的方式保存工作线程,如果成功则执行任务</span></span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断当前线程池的状态是否为Running,是则将任务加入阻塞队列中,说明上述的corePool不够用</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">         	 <span class="comment">// 线程池已经shutdown并且不接受当前的任务,交由指定的策略处理</span></span><br><span class="line">             reject(command);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">         	<span class="comment">// 线程池已经没有线程,由于任务已经加入阻塞队列,这里只需要新创建一个线程</span></span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 队列满,从线程池中创建新线程后处理任务,如果创建失败则执行策略</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor内部执行示意图<br><img src="https://img-blog.csdnimg.cn/20200206122007466.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>ThreadPoolExecutor示意图说明</p>
<ul>
<li>主线程提交任务给线程池之后,线程池的corePool未满则创建线程执行任务(1,2)</li>
<li>若corePool已经满了,则将任务提交到阻塞队列中(3)</li>
<li>任务添加到阻塞队列之后将会进行双重检测,如果线程池关闭,则移除当前任务并执行拒绝策略处理任务返回主线程中,若线程池未关闭,再次检测corePool的线程个数,如果没有线程则创建新的线程但不执行任务(4.1&amp;4.2)</li>
<li>若队列已经满了,在创建新线程过程中会检测队列容量,corePool和maxPool的数量,如果满足&lt; max就会创建新线程并执行任务,否则说明已经达到maxPool,创建失败并将任务移除到拒绝策略执行返回给主线程(5,6)</li>
<li>对于非corePool下的线程,若存在空闲线程超过单位未unit的keepalive的时间,将销毁线程</li>
<li>同时对于corePool下的空闲线程,将会从阻塞队列中获取任务并执行任务</li>
<li>从线程创建流程知道,添加的工作线程将由一个基于HashSet的集合来维护,只有添加到set成功之后才会执行任务,如果检测到工作线程已经是启动过了,将不会再次添加到set集合中</li>
</ul>
</li>
<li><p>execute核心执行流程<br><img src="https://img-blog.csdnimg.cn/20200206113502986.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>execute核心流程小结</p>
<ul>
<li>如果当前线程池中的线程数num &lt; corePoolSize, 则创建新线程执行任务,需要获取全局锁</li>
<li>如果当前线程池中的线程数num &gt;= corePoolSize, 则将任务加入BlockingQueue中</li>
<li>如果BlockingQueue已经满且线程数num &lt; maximumPoolSize, 那么创建新的线程来执行任务,需要获取全局锁</li>
<li>如果BlockingQueue已经满且线程数num &gt;= maximumPoolSize,新加入的任务将交由指定handler策略处理,默认采取的策略是被拒绝</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程池状态</p>
</blockquote>
<ul>
<li><p>状态代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储线程池状态以及工作线程个数(RUNNING, 0)</span></span><br><span class="line"><span class="comment">// rs表示状态,wc表示工作线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 状态存储在对应数值的高三位</span></span><br><span class="line"><span class="comment">// 接收新任务并能处理队列里的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 不再接收新任务但能处理队列里的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	</span><br><span class="line"><span class="comment">// 将会在处理任务过程被中断,不再接收和处理队列的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;	</span><br><span class="line"><span class="comment">// 所有任务已经执行完毕,工作线程个数为0且在调用terminated()之前的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// terminated()执行之后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 获取当前线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取当前线程池的工作线程个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态变化图<br><img src="https://img-blog.csdnimg.cn/20200206142711916.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h6 id="4-线程池监控"><a href="#4-线程池监控" class="headerlink" title="4. 线程池监控"></a>4. 线程池监控</h6><ul>
<li><p>getLargestPoolSize(): 返回核心线程池中当前最大的线程数,与workers的集合大小一致,表示当前线程池中的线程数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line">addWorker(Runnable firstTask, <span class="keyword">boolean</span> core)&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">	<span class="comment">// 自旋检测线程个数与队列容量,corePool,maxPool的比较</span></span><br><span class="line">	mainLock.lock();</span><br><span class="line">	<span class="keyword">int</span> s = workers.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">        largestPoolSize = s;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getPoolSize(): 返回当前线程池状态不为TERMINATED(&gt;=TIDYING)时的线程数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">         <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">         <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span></span><br><span class="line">             : workers.size();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getActiveCount(): 获取当前正在处理任务的线程数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">        	<span class="comment">// worker是基于AQS实现的,内部启动执行任务的时候会加锁</span></span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getTaskCount(): 获取线程池中所有的任务,包括已经执行完成的任务+正在执行的任务+在阻塞队列中未执行的任务个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">long</span> n = completedTaskCount;	<span class="comment">// 线程池执行完成的任务个数</span></span><br><span class="line">         <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">             n += w.completedTasks;   <span class="comment">// 当前工作线程执行完成的任务个数</span></span><br><span class="line">             <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                 ++n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getCompletedTaskCount(): 获取当前线程池中已经完成的任务个数(线程池完成的任务 + 工作线程完成的任务)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">         <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">             n += w.completedTasks;</span><br><span class="line">         <span class="keyword">return</span> n;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile工作原理</title>
    <url>/2020/03/20/volatile/</url>
    <content><![CDATA[<span id="more"></span>
<p>在前文中已经讲解到volatile的使用以及原子性的问题,volatile修饰的变量可以实现线程对变量的写操作能够让其他线程“看到”当前最新的变量数据值,从内存语义上而言,相当于告诉线程读取当前变量要从主内存中读取,对此,现将继续前文的volatile继续深入原理分析.</p>
<h6 id="1-volatile作用与使用场景"><a href="#1-volatile作用与使用场景" class="headerlink" title="1. volatile作用与使用场景"></a>1. volatile作用与使用场景</h6><blockquote>
<p>volatile规则与作用</p>
</blockquote>
<ul>
<li>基于Happen-Before的原则,对volatile变量执行写操作happen-before该变量读操作的后续每个动作</li>
<li>另外,基于内存语义,我们可以知道volatile读取的数据变量可以立马“看到”volatile在另一个线程写入的最新值,同时遵循先写后读的顺序规则</li>
<li>对于声明volatile变量的单步的操作具有原子性</li>
<li>还有一点就是volatile底层处理器是<strong>使用内存屏障的机制来强制工作内存失效,从而消除处理器的重排序</strong></li>
</ul>
<blockquote>
<p>使用volatile的场景</p>
</blockquote>
<ul>
<li>当定义的数据变量需要与其他CPU寄存器需要进行数据交互的时候,即在多核CPU的机器下需要声明为volatile,从而保证数据是可见的</li>
<li>当数据存储在主内存(JMM中定义的共享内存)时,由于主内存中并没有存在锁的保护,并且依赖于内存的访问顺序,使用volatile的开销会比lock更“廉价”</li>
</ul>
<h6 id="2-volatile内存语义"><a href="#2-volatile内存语义" class="headerlink" title="2. volatile内存语义"></a>2. volatile内存语义</h6><blockquote>
<p>部分源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared.java</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">producer()&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    finised = <span class="keyword">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;have finished product done ....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">consumer()&#123;</span><br><span class="line">   <span class="keyword">while</span> (!finised)&#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;have consume product done &quot;</span> + full);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// producer.java</span></span><br><span class="line"><span class="comment">// 代码仅做演示,忽略其他因素</span></span><br><span class="line">run()&#123;</span><br><span class="line">	producer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumer.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">	consumer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于上述代码内存演示图</p>
</blockquote>
<ul>
<li><p>代码初始化过程,将数据复制到工作内存中<br><img src="https://img-blog.csdnimg.cn/20200123110749810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>生产者开始对数据进行写操作,基于volatile语义可以看到写操作之后是刷新到主内存中<br><img src="https://img-blog.csdnimg.cn/20200123112223315.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>运行结果</p>
<ul>
<li>使用volatile修饰的消费者线程退出循环完成程序的正常执行</li>
<li>不使用volatile修饰的消费者线程由于读取工作内存的数据将会处于不断循环中,没有退出程序</li>
</ul>
</li>
<li><p>基于上述的内存分析,我们也许会存在一个问题</p>
<ul>
<li>消费者线程在读取的时候看到finshed是volatile修饰为什么工作缓存会失效?</li>
<li>也就是接下来要说明的内存屏障,内存语义的实现机制</li>
</ul>
</li>
</ul>
<h6 id="3-volatile内存屏障实现"><a href="#3-volatile内存屏障实现" class="headerlink" title="3. volatile内存屏障实现"></a>3. volatile内存屏障实现</h6><p>内存屏障是处理器层面进行的,因此这里直接查阅jvm下的cpu架构源码对volaitle的内存屏障进行说明</p>
<blockquote>
<p>关于ARM(指令集机器指令)参考说明</p>
</blockquote>
<ul>
<li>dmb: Data Memory Barrier</li>
<li>ish:  DMB operation only applies to the inner shareable domain.</li>
<li>ishld: DMB operation that waits only for loads to complete, and only applies to the inner shareable domain.</li>
<li>参考文档: <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802b/CIHGHHIE.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802b/CIHGHHIE.html</a></li>
</ul>
<blockquote>
<p>JVM中的aarch64架构处理器对volatile的内存屏障说明</p>
</blockquote>
<ul>
<li><p><code>ldar&lt;x&gt;</code> 表示volatile的读指令, <code>stlr&lt;x&gt;</code> 表示volatile的写指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely</span></span><br><span class="line"><span class="comment">// use to implement volatile reads and writes. For a volatile read</span></span><br><span class="line"><span class="comment">// we simply need</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   ldar&lt;x&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// and for a volatile write we need</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   stlr&lt;x&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读写屏障流程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读屏障</span></span><br><span class="line"><span class="comment">// Alternatively, we can implement them by pairing a normal</span></span><br><span class="line"><span class="comment">// load/store with a memory barrier. For a volatile read we need</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   ldr&lt;x&gt;			// 读取volatile数据</span></span><br><span class="line"><span class="comment">//   dmb ishld		// 内存屏障</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 写屏障	</span></span><br><span class="line"><span class="comment">// for a volatile write</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   dmb ish		// 内存屏障</span></span><br><span class="line"><span class="comment">//   str&lt;x&gt;		    // 写volatile数据</span></span><br><span class="line"><span class="comment">//   dmb ish		// 内存屏障</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读写屏障伪代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.java</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//threadA write </span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">// ...code start ...</span></span><br><span class="line">	j = <span class="number">9</span>;</span><br><span class="line">	<span class="comment">// ... code end ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadB read</span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="comment">// ... code start ...</span></span><br><span class="line">	a = j;</span><br><span class="line">	a ++;</span><br><span class="line">	<span class="comment">// ... code end ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对上述的读写转换为aarch伪指令如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写屏障</span></span><br><span class="line"><span class="function">threadA <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//... code start ...</span></span><br><span class="line">	dmb ish			<span class="comment">// 防止上面代码与写volatile代码重排</span></span><br><span class="line">	str&lt;i&gt;			<span class="comment">// j = 9,由于是写屏障,所以会使缓存失效,并更新到主内存中</span></span><br><span class="line">	dmb ish			<span class="comment">// 防止下面代码与写volatile代码重排</span></span><br><span class="line">	<span class="comment">//... code end ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读屏障</span></span><br><span class="line"><span class="function">threadB <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// ... code start ...</span></span><br><span class="line">	ldr&lt;x&gt;			<span class="comment">// 读取j的数据</span></span><br><span class="line">	dmb ishld		<span class="comment">// 内存屏障,防止与下面的a++重排序</span></span><br><span class="line">	a++;</span><br><span class="line">	<span class="comment">// ... code end ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果分析</p>
<ul>
<li>对于重排序目的无非就是要将一些读操作优先处理或者说是本地CPU能够不依赖于主内存处理的任务先处理</li>
<li>因此,对于volatile的写操作,增加内存屏障一个是防止重排序,为什么可以防止重排序,主要是内存屏障强制CPU将当前的缓存失效,直接从主内存中读取数据,CPU就无需因为性能的问题再去重排序</li>
<li>同理,对于volatile的读操作,增加内存屏障,也就是需要从主内存中获取数据进行下一步的操作,也无需再进行重排序</li>
</ul>
</li>
</ul>
<h6 id="4-volatile工作原理小结"><a href="#4-volatile工作原理小结" class="headerlink" title="4. volatile工作原理小结"></a>4. volatile工作原理小结</h6><blockquote>
<p>问题思考</p>
</blockquote>
<p>就是前文说明有一个-server服务端模式,编译器会对代码进行重排序,而这里说的volatile因为内存屏障而没有重排序不会矛盾?<br>重排序有编译器重排序,也有CPU处理器重排序,内存屏障是在CPU层面进行的,也就是说使用volatile修饰的变量仍然会在编译阶段导致代码重排,但是字节码转换为机器码的时候会识别有带volatile的修饰,因此会增加内存屏障来防止处理器进行重排序,两者并不矛盾</p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>volatile变量的写操作将会使得当前本地缓存(线程/CPU等工作内存)失效,直接刷新数据到主内存(堆内存)中</li>
<li>volatile变量的读操作将会使得当前本地缓存失效并从主内存中重新加载读取数据</li>
<li>volatile的内存语义是基于内存屏障的机制实现,因此读取的数据可以保证写入的数据是最新的</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>关键字volatile的使用与原子性问题</title>
    <url>/2020/03/24/volatile_used/</url>
    <content><![CDATA[<span id="more"></span>
<h6 id="1-volatile的使用"><a href="#1-volatile的使用" class="headerlink" title="1. volatile的使用"></a>1. volatile的使用</h6><blockquote>
<p>java源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileUsedClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sharedVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// modify the sharedVar,write first</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500L</span>);</span><br><span class="line">                    sharedVar = <span class="number">20</span>;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s modify the shared var to %s  ...\n&quot;</span>, <span class="string">&quot;thread-1&quot;</span>, sharedVar);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// read the value,read for the last</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">505L</span>);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s read the shared var %s \n&quot;</span>, <span class="string">&quot;thread-2&quot;</span>, sharedVar);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;finish the thread task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端模式-client</p>
</blockquote>
<ul>
<li>不加volatile的执行结果(多次执行)<br><img src="https://img-blog.csdnimg.cn/2020012210205840.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200122102554675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>加volatile的执行结果(多次)<br><img src="https://img-blog.csdnimg.cn/20200122102337750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200122102504544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>结果分析<ul>
<li>在源代码中是添加时间休眠主要是保证先写后读的逻辑</li>
<li>从运行结果可以看出,虽然时间片很短,读线程的数据仍然是本地缓存的数据,并没有从主内存中读取值</li>
<li>添加volatile关键字之后,可以看到读线程的数据正是写线程之后的数据,也就是写读数据是一致的</li>
</ul>
</li>
</ul>
<blockquote>
<p>服务端模式,-server</p>
</blockquote>
<ul>
<li>不带volatile执行结果(多次)<br><img src="https://img-blog.csdnimg.cn/20200122103655136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020012210402446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>带volatile执行结果(多次)<br><img src="https://img-blog.csdnimg.cn/20200122104120365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>结果分析<ul>
<li>不带volatile修饰与客户端执行效果一致</li>
<li>但是使用server模式带有volatile的方式却出现了数据不一致的情况,为什么?</li>
<li>原因在于-server模式会在编译成字节码的时候进行代码重排序导致的,主要用于优化程序提升执行效率</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>clinet模式是jdk执行的默认配置,可用于测试环境或者本地开发</li>
<li>server模式一般用于生产环境,目的是开启server模式的时候编译器会针对OS系统情况做一些优化操作</li>
<li>参考: <a href="https://javapapers.com/core-java/jvm-server-vs-client-mode/">JVM server vs Client Mode</a></li>
</ul>
<h6 id="2-原子性问题"><a href="#2-原子性问题" class="headerlink" title="2. 原子性问题"></a>2. 原子性问题</h6><p><strong>说明: 以下运行环境是使用-client模式进行,排除重排序的干扰</strong></p>
<blockquote>
<p>Java中的原子性</p>
</blockquote>
<ul>
<li>参考文档: <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html</a></li>
<li>文档对于原子性的说明如下:<ul>
<li>除了long和double类型之外,引用变量与大多数的原始数据类型都具备读写操作的原子性</li>
<li>所有使用volatile修饰的变量都具备读写操作的原子性</li>
</ul>
</li>
<li>分析<ul>
<li>针对64bit的数据类型,主要与处理器(32bit/64bit)有关,在32bit处理器上,JVM会将64bit的long/double划分为两个32bit的写操作,并不具备原子性(数据的读写主要是通过处理器总线与主内存进行传递)</li>
<li>基于Happen-Before原则,对于volatile的变量读取总是可以“看到”任何一个线程对该volatile变量的最后写入,因此在临界区代码的执行是具备原子性,即使是long或是double类型</li>
</ul>
</li>
</ul>
<blockquote>
<p>volatile修饰单个变量的自增或自减是不具备原子性</p>
</blockquote>
<ul>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 部分代码,在上述的写线程进行修改</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// modify the sharedVar</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500L</span>);</span><br><span class="line">                    sharedVar ++;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s modify the shared var with atomic %s  ...\n&quot;</span>, <span class="string">&quot;thread-1&quot;</span>, sharedVar);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行结果<br><img src="https://img-blog.csdnimg.cn/20200122115720973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>字节码显示<ul>
<li><p>sharedVar = 20L显示的字节码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L3</span><br><span class="line">   LINENUMBER 102 L3</span><br><span class="line">   BIPUSH 20		// 压入线程的操作数栈</span><br><span class="line">   INVOKESTATIC com/xiaokunliu/blogs/thread/volatile2code/VolatileUsedClass.access$002 (I)I    //实例化并加载sharedVar并压入操作数栈,说明完成赋值操作</span><br><span class="line">   POP   // 弹出数据</span><br><span class="line">   L4</span><br></pre></td></tr></table></figure></li>
<li><p>sharedVar ++ 显示的字节码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L3</span><br><span class="line">   LINENUMBER 27 L3</span><br><span class="line">   INVOKESTATIC com/xiaokunliu/blogs/thread/volatile2code/VolatileUsedClass.access$000 ()I  // 实例化并加载sharedVar并压入操作数栈</span><br><span class="line">   ICONST_1    // 将常量 1 压入线程操作数栈总</span><br><span class="line">   IADD            // 执行sharedVar+1</span><br><span class="line">   INVOKESTATIC com/xiaokunliu/blogs/thread/volatile2code/VolatileUsedClass.access$002 (I)I  // 重新实力化加载sharedVar,说明完成赋值操作</span><br><span class="line">   POP</span><br><span class="line">  L4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>运行分析: <ul>
<li>通过字节码可知,sharedVar ++;相比单纯赋值操作增加了一个添加的动作</li>
<li>也就整体代码块存在在并发多线程下交替执行的两个操作,不具备原子性,volatile在这里是保证代码刷新到主内存,对于sharedVar = const 是具备原子性的</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用volatile小结</p>
</blockquote>
<ul>
<li>对变量进行写操作的时候可以通过volatile来实现对其他线程的可见,同样在单步指令操作中是具备原子性,针对long或者double也起到具备原子性的作用</li>
<li>对于需要用volatile修饰的变量来完成一系列的非单步操作运算是无法保证原子性,必须借助lock的方式来实现代码块的原子性</li>
</ul>
]]></content>
      <categories>
        <category>cocurrent</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式共识问题</title>
    <url>/2020/05/27/byzantine/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="分布式共识问题"><a href="#分布式共识问题" class="headerlink" title="分布式共识问题"></a>分布式共识问题</h2><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/title.jpg"></p>
<p>在讲述分布式的共识问题之前,我们先了解下什么是拜占庭将军问题, 其次从拜占庭将军问题来认识什么是分布式共识问题,与分布式一致性的区分在哪里?然后推演分布式共识问题产生的原因以及解决共识问题的策略算法有哪些,对应的适用场景有哪些?接下来我们可以带着疑问来逐步揭开上述问题的本质.另外这里要先说明一点,<strong>这里讲述的服务节点不可用包含网络超时/服务节点出现故障/网络通信被伪造等情况.</strong></p>
<h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><h4 id="拜占庭一般性问题"><a href="#拜占庭一般性问题" class="headerlink" title="拜占庭一般性问题"></a>拜占庭一般性问题</h4><ul>
<li>拜占庭军队中的每一个师都有自己的将军,并且由该将军负责指挥作战</li>
<li>现在拜占庭军队中的将军存在一些叛徒,将军们可以通过信使进行相互沟通作战方案</li>
<li>现在对拜占庭军队要求是:</li>
</ul>
<blockquote>
<ol>
<li><p>所有忠实的将军都能够采取相同的作战计划.</p>
</li>
<li><p>少数叛徒不会使忠诚的将军们采取错误的计划从而导致最终的作战失败.</p>
</li>
</ol>
</blockquote>
<h4 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h4><ul>
<li>所有忠诚的将军都得到同样的信息，他们将以某种方式得到同样的决定</li>
<li>一个忠诚的将军发出的信息应该被所有其他忠诚的将军所采用</li>
</ul>
<h4 id="什么是拜占庭将军问题"><a href="#什么是拜占庭将军问题" class="headerlink" title="什么是拜占庭将军问题"></a>什么是拜占庭将军问题</h4><p>基于上述的问题的理解,假设现在拜占庭军队中有三个师,每个师都有自己的将军,现在要准备开始作战计划攻打城池,现在需要满足上述讲到的要求,即保证每个师的忠诚将军都能够采取相同的作战计划以防止被叛徒信息误导采取错误的决定.此时需要每个师派发行使进行通信协商,同时为了保证协商存在可靠性,即下面的半数投票的可靠性.</p>
<h5 id="少数服从多数的投票可靠性"><a href="#少数服从多数的投票可靠性" class="headerlink" title="少数服从多数的投票可靠性"></a>少数服从多数的投票可靠性</h5><ul>
<li>每个师的将军可以发表自己对作战方案的计划,并通过信使通知其他师的将军们</li>
<li>其次,每个师的将军接收到其他师的将军们的作战方案时候,采取默认少数服从多数的方案作为作战方案执行.</li>
</ul>
<p>这个时候我们可以看到,每一个师的将军都能够提供方案,说明是具备作战的指挥权的,相对地,其他师的将军就作为副官,负责执行作战方案.于是对于一个拜占庭将军问题可以进行以下归纳.</p>
<h5 id="拜占庭将军问题-1"><a href="#拜占庭将军问题-1" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h5><p>我们可以将问题进行简化为一系列由一个指挥官和多个副官组成的问题,即拜占庭将军问题:</p>
<ul>
<li>如果所有的副官都是忠诚的,那么他们必然遵循相同的作战命令</li>
<li>如果指挥官是忠诚的,那么所有忠实的副官也都会遵循其所发出的命令</li>
</ul>
<p>简而言之,拜占庭将军问题就是如何在可能存在有叛徒的情况下,采取合适的通信机制来保证忠诚的将军能够达成共识采取一致的作战计划.</p>
<h5 id="不可能的结果"><a href="#不可能的结果" class="headerlink" title="不可能的结果"></a>不可能的结果</h5><p>如果忠实于将军的将军少于或等于2/3，则不存在解决方案.</p>
<h3 id="分布式共识问题-1"><a href="#分布式共识问题-1" class="headerlink" title="分布式共识问题"></a>分布式共识问题</h3><h4 id="什么是分布式共识问题"><a href="#什么是分布式共识问题" class="headerlink" title="什么是分布式共识问题"></a>什么是分布式共识问题</h4><p>基于拜占庭将军问题的分析,我们将其翻译为分布式系统相关的术语,并对其进行阐述如下:</p>
<ul>
<li>拜占庭将军: 即分布式系统的服务节点</li>
<li>忠诚的拜占庭将军: 即分布式系统服务正常运作的服务节点</li>
<li>叛变的拜占庭将军: 出现故障并发送误导信息的服务节点</li>
<li>信使被杀: 服务节点之间出现通信故障,导致信息丢失</li>
<li>信使被间谍替换: 服务节点进行网络通信过程中信息被黑客攻击,通信存在劫持以及信息伪造</li>
</ul>
<p>而分布式共识问题就是在分布式系统中,我们要如何保证系统服务节点之间的通信接收到的消息指令都是可靠且一致的.</p>
<h4 id="分布式共识与一致性区分"><a href="#分布式共识与一致性区分" class="headerlink" title="分布式共识与一致性区分"></a>分布式共识与一致性区分</h4><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/distibuted_cons.jpg"></p>
<p>在讲述分布式的共识与一致性之前,我们先来看下上述的图解,用户发起请求向分布式系统集群服务请求资源然后服务资源给予响应,这个时候我们考虑以下的场景:</p>
<ul>
<li>首先,用户A先发起一个事务操作的请求到集群服务,这个时候集群服务接收到事务操作请求,这个时候问题来了,集群服务存储节点谁来负责处理事务请求的操作,进行事务操作之后数据如何同步到各个服务节点上,即集群服务节点如何对事务请求操作达成共识.</li>
<li>其次,用户B发起一个非事务的读取请求到集群服务中,此时读取到数据应当是A进行事务操作之后最新的数据,也就是集群服务节点需要保证给到用户B的数据是最新修改的数据,即服务节点的一致性问题.</li>
</ul>
<p>从上述可以看到,对于分布式系统的共识与一致性问题其实关注的点不一样的,即:</p>
<ul>
<li>分布式共识问题:回归到事务请求操作的思考层面,就拿扣减库存的分布式事务为例,它必须保证并发的原子性操作,那么此时我们就需要对共享资源进行加锁互斥保证集群中只有一个节点能够进行事务操作;其次当服务节点完成事务操作之后,还需要进行数据同步到冗余服务节点上,那么进行事务操作的服务节点必须向集群其他节点发起数据同步操作并等待响应(是不是类似于上述的拜占庭将军问题);另外关于分布式共识还包含通过原子组播的方式处理进程对消息传递的顺序一致性.</li>
<li>分布式一致性: 通过上述的查询请求操作,即对于集群冗余服务的数据副本之间对外表现的数据是一致的,类似于JDK中的valotile机制,保证在多核CPU处理器上读取到数据是最新修改的.(后续再单独说明分布式的一致性)</li>
</ul>
<p>分布式共识问题,即为了达到共识,每个进程都提出自己的提议（propose）,最终通过共识算法,所有正确运行的进程决定（decide）相同的值,如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_problem.jpg"></p>
<p>在上面的图示可以看出,不同的进程p0,p1,p2以及p3分别输入一个数据值,然后通过执行程序来处理并交换输入值,保证最终输出的数据值都是一致的.即不同进程的输入值通过自身相同的一套程序进行交换处理输入数据并最终都输出一致的数据v.</p>
<h4 id="分布式共识特性"><a href="#分布式共识特性" class="headerlink" title="分布式共识特性"></a>分布式共识特性</h4><p>摘录分布式共识的英文阐述如下:</p>
<blockquote>
<ol>
<li>Termination: Every non-faulty process must eventually decide</li>
<li>Agreement: The final decision of every non-faulty process must be identical</li>
<li>Validity: If every non-faulty process begins with the same initial value v, then their final decision must be v</li>
</ol>
</blockquote>
<ul>
<li>终止: 每个非故障的进程最终必须作出提案的决策</li>
<li>协议: 每一个非故障的进程最终作出的提案决策都必须是一致的</li>
<li>有效性: 如果每一个非故障的进程均以相同的初始化值v作为提案的输入,那么最终提案决策的输出都必须为v.</li>
</ul>
<p>对于分布式共识应用场景有:</p>
<ul>
<li>集群服务节点的Master/Leader选举策略</li>
<li>集群服务节点进程加锁资源互斥</li>
<li>集群中某一个服务节点故障的判定策略</li>
<li>时钟相位同步问题</li>
<li>ATC服务(Air Traffic Control): 空中交管控制系统,即所有的在空飞机都看到画面都是一致的(Air traffic control system: all aircrafts must have the same view)</li>
</ul>
<p>关于ATC可以参考:<a href="https://science.howstuffworks.com/transport/flight/modern/air-traffic-control.htm">https://science.howstuffworks.com/transport/flight/modern/air-traffic-control.htm</a></p>
<h3 id="共识问题推演"><a href="#共识问题推演" class="headerlink" title="共识问题推演"></a>共识问题推演</h3><h4 id="问题推演"><a href="#问题推演" class="headerlink" title="问题推演"></a>问题推演</h4><p>基于拜占庭将军问题,现假设有三个军队的将军,现在准备拟定攻城的计划,三个将军对此进行各自拟定计划(进攻或者是撤退的策略)并由信使负责消息的传递,最终通过“少数服从多数”原则来决定最终的决策方案.</p>
<h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><ul>
<li>三个军的将军都是忠诚的,那么对于发出进攻或者是撤退的策略最终应当是一致的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_normal.jpg"></p>
<p>A将军此时发起决策提案为进攻,对于B和C正常接收到的信息是进攻;B将军发起的决策提案为撤退,对于A和C正常接收到的信息为撤退,C将军发起的决策提案为进攻,那么这个时候对于A和B看到的提案为进攻,这个时候我们分别思考A,B,C三位将军接收到的提案为:</p>
<p>A将军: 自己进攻的提案 + B将军的撤退提案 + C将军的攻击提案,因此最终决定进攻.</p>
<p>B将军:自己撤退的提案 + A将军的进攻提案 + C将军的进攻提案,因此最终决定也是进攻.</p>
<p>C将军: 自己进攻的提案 + B将军的撤退提案 + A将军的进攻提案,因此最终决定也是进攻.</p>
<p>但是这个时候我们需要看到上述决策成功需要满足要求:</p>
<blockquote>
<p>1.所有的将军都是忠诚的<br>2.在上述的半数投票过程中,需要满足参与投票的将军个数为2n+1,不然无法决定投票结果.</p>
</blockquote>
<h5 id="二忠一叛问题"><a href="#二忠一叛问题" class="headerlink" title="二忠一叛问题"></a>二忠一叛问题</h5><p>如果三个将军中有一个将军出现问题,那么此时的情况又被变成如下的情况:</p>
<blockquote>
<p>1.其中一个将军为叛徒<br>2.其中一个将军的信使被间谍替换<br>3.其中一个将军的信使中途被杀</p>
</blockquote>
<ul>
<li>如果其中一个将军为叛徒抑或是C将军的信使被间谍替换,假设为C将军叛变,那么此时产生的情况如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_pantu.jpg"></p>
<p>A将军: 自己进攻的提案 + B将军的撤退提案 + C将军的攻击提案,因此最终决定进攻.</p>
<p>B将军:自己撤退的提案 + A将军的进攻提案 + C将军的撤退提案,因此最终决定是撤退.</p>
<p>C将军: 因为自己本身是叛军,当然在战场上肯定也是撤退</p>
<p>这个时候三位将军采取最终方案是不一致的,这样会导致A将军直接受到伏击被敌军歼灭;</p>
<ul>
<li>如果C将军的信是中途被截杀,那么此时产生的情况如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_cancel.jpg"></p>
<p>A将军: 只接收到B将军的撤退提案 + 自己攻击的提案, 这个时候是无法进行决策</p>
<p>B将军: 只接收到A将军的攻击提案 + 自己撤退的提案, 这个时候也无法进行决策</p>
<p>C将军: 接收到A将军的攻击提案 + 自己的攻击提案 + B将军的撤退提案,采取攻击提案.</p>
<p>这个时候可以看到A,B,C三位将军最后做决策的时候将无法保证最终的提案一致性而采取相同的行动. </p>
<h5 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h5><p>通过上述的分析,我们将其转化为分布式系统集群三个服务节点A,B,C之间可能存在的问题如下:</p>
<p>当向分布式系统集群服务发起事务操作请求的时候,如果这个时候存在服务节点发生故障(信使被截杀)抑或是服务节点在消息通信过程被劫持,整个集群服务节点将无法对当前的事务请求操作采取一致性的行动.</p>
<h4 id="口头消息的解决方案"><a href="#口头消息的解决方案" class="headerlink" title="口头消息的解决方案"></a>口头消息的解决方案</h4><h5 id="无签名的口头消息要求以及含义"><a href="#无签名的口头消息要求以及含义" class="headerlink" title="无签名的口头消息要求以及含义"></a>无签名的口头消息要求以及含义</h5><ul>
<li>A1:每个服务节点发送的每条消息都能够被正确接收</li>
</ul>
<blockquote>
<p>1.连接两个服务节点之间的通信介质的故障与服务节点发生的故障是无法区分的.如超时网络不通/服务节点宕机均为不可用等均视为服务节点不可用<br>2.如果出现线路故障表示分布式系统中的集群服务节点多了一个不可用的服务节点.</p>
</blockquote>
<ul>
<li>A2:集群服务节点知道消息发送者的信息</li>
</ul>
<blockquote>
<p>不需要通过网络交换就能知道消息发送者的信息</p>
</blockquote>
<ul>
<li>A3:能够检测到集群其他服务节点的心跳</li>
</ul>
<blockquote>
<p>需要有超时机制</p>
</blockquote>
<h5 id="口头消息的算法"><a href="#口头消息的算法" class="headerlink" title="口头消息的算法"></a>口头消息的算法</h5><blockquote>
<p>算法定义</p>
</blockquote>
<p>基于上述的假设,现有一个算法函数major满足fn=(V1,V2,…Vn-1),该函数表示集群服务节点中每个节点一个提案值vi,fn表示集群中vi占过半投票对应的提案值v,而口头消息解决算法有一个前提条件,那就是必须是集群服务节点不可用的个数m必须满足m&lt;n/3,(n为当前集群服务节点的总数),也就是集群服务节点总数n最小值为n=3m+1.而对于算法的描述存在两种选择如下:</p>
<ul>
<li>如果v的提案值存在那么就执行提案值v的动作,否则采取默认的行为(撤退)</li>
<li>其次,假设vi 为上述(V1,V2,…Vn-1)一系列有序的集合数据的中位数,那么就执行vi的提案</li>
</ul>
<blockquote>
<p>算法描述</p>
</blockquote>
<p>现对于3m+1的集群服务节点选举一个具备指挥权的服务节点作为leader,其他节点作为replicate,这个时候存在以下两种情况</p>
<p>当m=0时,即不存在服务节点不可用时,其算法执行的策略为:</p>
<ul>
<li>leader节点向每个replicate节点发送其提案指令v</li>
<li>所有replicate节点接收到其提案指令v的消息时执行,如果没有收到执行默认的“撤退”行为.</li>
</ul>
<p>当m&gt;0时,其执行的算法如下:</p>
<ul>
<li>leader节点向每个replicate节点发送其提案指令v</li>
<li>所有replicate节点接收到提案指令v的消息时作为执行命令的提案vi,如果没有收到消息则把默认的“撤退”行为作为其执行的提案vi,并此时的服务节点作为一个新的leader向其他n-2个服务节点(自己节点以及上一个leader节点)发起提案vi</li>
<li>对于replicate节点(V1,V2,…Vn-1),假设当前服务节点为V1,那么V1节点在经过上述步骤2的操作之后,也会接收到其他服务节点(V2,V3,…Vn-1)节点的消息提案,分别设置对应值为v2,v3,…vn-1,其中每一个节点发送过来的提案值都是采取上一步的动作,除了其中的不可用的服务节点.</li>
</ul>
<p>经过上述的算法,对于存在m个不可用或者是不可靠的服务节点,需要经过m+1次的递归发起提案请求,同时可以递归推导得出O(m)调用(n-1)次递归独立执行O(m-1).</p>
<h5 id="口头消息解决方案分析"><a href="#口头消息解决方案分析" class="headerlink" title="口头消息解决方案分析"></a>口头消息解决方案分析</h5><p>基于上述的分析,如果仅有上述的集群服务的3个节点,基于口信消息的方案是无法解决拜占庭将军问题的,现分析如下:</p>
<ul>
<li>现在我们从服务集群中选举一个节点作为具备指挥权的服务节点,比如服务节点A</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_fail.jpg"></p>
<p>对于上述集群服务节点A,B,C节点中,对于B而言不论A是叛变还是C是叛变的,都无法作出决策,说明信消息要达到交互的一致性在集群中只有3个服务节点要是无法做到.</p>
<p>基于此,我们需要将军队多划出一个独立军队,产生一个新的指挥官,而A,B,C作为副官,负责执行提案策略.这个时候基于上述的算法就有以下情况.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_success.jpg"></p>
<p>从上述可以看出,如果是C将军为叛变将,最后不论结果如何,指挥官以及A和B将军会采取进攻的策略;而如果是指挥官是叛变的话,那么对于A,B,C三位将军最终得出的结果是采取撤退的策略,不论是哪种结果对于忠诚的将士而言最终采取的行动是一致的.</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>对于我们分布式互联网而言,一般在企业内部的集群机器而言,由于对外存在防火墙以及安全的网关校验,因此对于企业服务内部都是采取当前的算法策略来解决我们集群服务选举,进程互斥以及分布式事务等问题提供解决方案的思路.对于口信消息的算法,一般用于系统容错故障但不存在恶意攻击的服务节点,即CFT算法,这个场景可能会丢失消息,或者有消息重复,或者是顺序一致性处理等场景,其对应的常用算法有Paxos算法、Raft算法、ZAB协议.</p>
<h4 id="签名消息的解决方案"><a href="#签名消息的解决方案" class="headerlink" title="签名消息的解决方案"></a>签名消息的解决方案</h4><p>这个时候我们发现上述的解决方案需要在原有的集群服务中增加一个leader节点作为整个集群具备指挥权的服务节点.那么是否可以考虑不需要进行加服务节点就能够解决服务节点之间的共识问题呢?这个时候就需要运用到我们的签名消息解决方案.</p>
<h5 id="实现签名消息的要求以及含义"><a href="#实现签名消息的要求以及含义" class="headerlink" title="实现签名消息的要求以及含义"></a>实现签名消息的要求以及含义</h5><ul>
<li>A4: 基于上述无签名消息的要求以及含义基础上,需要满足以下条件:</li>
</ul>
<blockquote>
<p>1.集群服务节点之间的消息通信无法被伪造,任何被伪造的消息都能够被检测出来<br>2.每一个服务节点都能够核实消息签名的真实身份.</p>
</blockquote>
<h5 id="消息签名的算法"><a href="#消息签名的算法" class="headerlink" title="消息签名的算法"></a>消息签名的算法</h5><blockquote>
<p>算法要求</p>
</blockquote>
<p>基于上述A1-A4的假设要求,如果存在m个不可用的服务节点,那么整个集群的服务节点必须是不少于m+2,否则无法得到问题的解决.该算法为空洞.</p>
<blockquote>
<p>算法的定义</p>
</blockquote>
<p>我们定义一个函数fn=choice(V)表示有序的集合中存在签名的消息元素v,如果集合中只有一条消息元素v,那么fn=v.</p>
<ul>
<li>如果集合V中仅包含一个元素v,则choice(V)=v</li>
<li>如果集合为空,那么执行默认的“撤退”行为,即choice(V)=RETREAT.</li>
</ul>
<blockquote>
<p>算法描述</p>
</blockquote>
<p>在该算法中,指挥权的服务节点向其他服务节点发送一个按照一定规则签名的消息到其他服务节点中,其他服务节点接收到消息之后将其签名添加到有序的签名消息中并进行发送到其他服务节点中,其他服务节点以此类推.如果存在服务节点“叛变”,必须有效地接收签名的消息,并对签名消息生成多份副本,然后再将这些副本进行签名然后发送到其他节点中.最后不论副本是如何得到,其中单条签名的消息要么是被通过副本拷贝要么是与单条签名一致并正确分发过来的消息.</p>
<ul>
<li>指挥权的服务节点对消息进行签名并发送到各个服务节点</li>
<li>对于每一个接收签名消息的服务节点<ul>
<li>如果服务节点从指挥节点接收以v:0的签名消息并且还没有接收到其他签名消息的时候,那么对于当前节点i设置选择提案值为choice(V)=v,并且以消息<code>v:0:i</code>的形式发送到其他非指挥权的服务节点上.</li>
<li>如果服务节点接收到消息形如<code>v:0:j1...:jk</code>并且v并不在集合V中,那么对于当前的服务节点将会把v添加到集合V中并当<code>k&lt;m</code>的时候将以消息为v:0j1…:jk<code>:i</code>的形式发送到其他服务节点,否则将以消息为`v:0:j1…:jk的形式发送到其他服务节点上.</li>
</ul>
</li>
<li>最后对于每一个服务节点i,如果没有接收到更多签名消息的时候,服务节点将会遵循选举从有序的集合V中获取提案v并执行.</li>
</ul>
<h5 id="消息签名算法分析"><a href="#消息签名算法分析" class="headerlink" title="消息签名算法分析"></a>消息签名算法分析</h5><p>基于上述的算法,我们仍然用拜占庭将军为例子进行分析如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/byzantine/cons_02.jpg"></p>
<ul>
<li>在左侧图中,由A将军发起进攻指令,B和C将军均收到A将军发出的指令,如果C将军为叛军,那么必然会篡改消息并进行签名发送给B将军,B将军识别到C将军发送的消息是伪造的,于是直接丢弃C将军的指令,最后执行进攻指令.</li>
<li>如果A将军为叛军,此时分别向B和C发送不同的指令,B和C将军接收到消息并存储在一个有序的集合中,即B存储[进攻, 撤退],C存储[撤退,进攻],根据上述的算法,集合中是有序的,那么对于B和C存储的集合指令也应当是有序且一致的,即均为[进攻,撤退]或者是[撤退,进攻]这样的有序集合,然后按照一定的选举策略(比如选举中间值)执行对应的指令,这样也保证了B和C交互的一致性.</li>
</ul>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>最后关于消息签名的算法,从上面我们可以看到是去中心化的一个分布式系统架构服务,因此对于公网环境下执行事务型操作可以考虑使用消息签名的算法,最大优势在于去中心化.</p>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论基础</title>
    <url>/2020/06/08/cap/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="分布式理论基础"><a href="#分布式理论基础" class="headerlink" title="分布式理论基础"></a>分布式理论基础</h3><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/title.jpg"></p>
<p>在这一篇中主要讲述分布式基础理论知识,其中包含CAP定理,ACID以,BASE理论以及一致性协议分析.有了CAP定理的基础,能够帮助我们在根据业务特点进行分区容错一致性模型设计中提供解决问题的方向以及架构设计方案的设计与落地实现.同时需要区分数据库ACID的AC与我们的分布式AC存在的联系与差异,其次,在分布式网络中,为避免节点故障抑或是网络延迟等问题导致系统服务出现大量的不可用问题,那么对于BASE理论实现的技术方案有哪些.最后讲述分布式系统中数据的一致性问题.</p>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><h5 id="网络分区容错-Partition-tolerance"><a href="#网络分区容错-Partition-tolerance" class="headerlink" title="网络分区容错(Partition tolerance)"></a>网络分区容错(Partition tolerance)</h5><ul>
<li>网络连通性</li>
</ul>
<blockquote>
<p>服务节点之间的网络通信正常</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/network_connected.jpg"></p>
<p>在上述可以看到,服务A集群与冗余服务A1与A2节点形成一个对外闭环的集群,同理服务B也构成一个闭环集群.此时发起一个请求操作,需要通过服务A与服务B进行协作,在服务B节点正常运作情况下,这个时候的分布式网络是处于连通状态,服务A与服务B之间能够进行正常网络通信完成数据协作.</p>
<ul>
<li>网络分区</li>
</ul>
<blockquote>
<p>服务节点之间的网络通信发生中断或者是延迟响应出现短时间的中断.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/network_partition.jpg"></p>
<p>在上述的图中,一个请求操作需要通过服务节点A与服务节点B完成协作,但是如果服务B没有做集群部署,此时服务节点B发生故障或者是网络延迟,那么这个时候服务节点A与服务节点B之间将无法进行通信,此时服务A将与服务B失去联系,即服务节点之间发生网络通信中断而产生网络分区,此时服务A节点与服务B节点被划分为彼此独立互不相连的节点服务,即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/network_parition2.jpg"></p>
<ul>
<li>分区容错</li>
</ul>
<blockquote>
<p>服务节点之间的网络通信能够通过容错处理手段来保证服务节点之间互通.</p>
</blockquote>
<p>为了保证上述的服务A与服务B能够正常通信,即使服务B节点发生故障,也可以通过集群服务B的其他节点B1或者是B2来继续为服务A提供服务,以保证服务A节点能够正常完成请求操作的处理.而对于这种情况称为分区容错,在分布式环境中,节点故障与网络延迟是无法避免的,因此为了保证我们的分布式系统服务能够正常运作,那么在进行架构设计的时候就需要做到满足CAP定理中的分区容错(Partition Tolerance)</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/network_tolenrace.jpg"></p>
<h5 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h5><blockquote>
<p>客户端每次发起的读取请求,不论是访问分布式集群中的哪个节点,都能够读取到最新的一份写入数据.</p>
</blockquote>
<p>分布式一致性的理解如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/consistency.jpg"></p>
<p>在上述发起一个事务操作请求的时候,集群的服务A接收事务请求操作<code>v=v1</code>的处理,此时服务A需要并未将数据同步到冗余服务节点A1以及A2,而此时向集群A服务发起读取请求操作,此时由于负责集群服务的均衡处理将请求转发到服务A1,但是此时存储数据v的服务节点A1并未从服务A同步到最新的数据v,从而导致发起读请求操作的客户端读取到数据v结果不一致.这个时候就需要要求服务节点A接收到数据状态变更也需要向集群服务中的冗余服务节点发起数据同步操作,保证其他冗余服务节点与服务节点A数据的一致性.也就是说分布式系统的一致性需要保证在有状态的服务节点下数据的读取是最新写入的.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/consistency2.jpg"></p>
<p>而对于数据在分布式环境进行同步操作的时候,会存在以下两个核心问题:</p>
<ul>
<li>节点发生故障如何保证读取的数据是一致性的,即存在节点故障问题</li>
<li>节点之间需要通过网络进行数据同步,即存在网络延迟问题</li>
</ul>
<h5 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性(Availability)"></a>可用性(Availability)</h5><blockquote>
<p>要实现可用性,需要牺牲数据的一致性,也就是无法保证数据看到都是最新的一份.</p>
</blockquote>
<p>我们先来思考分布式系统中哪些地方会存在不可用的情况:</p>
<ul>
<li>单节点故障导致服务的不可用.</li>
<li>服务与服务之间调用依赖,被调用方服务发生故障,调用方服务也会发生故障导致不可用.</li>
<li>当发起一个事务请求操作通过服务A来调用服务B的时候,此时服务节点B需要同步数据到其他冗余服务节点B1以及B2,如果此时有读取请求的操作来访问服务节点A,为了保证看到的数据是最新的,这个时候由于B1或者B2节点未完成数据同步但是要保证数据读取最新这个时候会导致服务A出现短暂的不可用,或者称为同步等待数据返回.</li>
</ul>
<p>通过上述我们看到,节点故障我们可以通过分区容错解决,也就说在分布式系统设计中分区容错与可用性是可以并存的,而服务调用方发生故障导致不可用,也可以认为是分区容错的一种手段,只不过是在应用层次通过过载保护或者是降级进行控制;然而对于后者,我们看到要保证数据的一致性,读取请求需要进行同步等待服务节点完成数据的同步操作之后再进行返回,那么在这个等待的时间窗口内,对于客户端而言,读取请求资源的操作出现短时间内的不可用.</p>
<p>由此可知,在我们的分布式环境下,为了保证节点与节点之间的正常通信,即保证分布式系统服务节点的网络连通性,我们必须要满足分区容错这一特性,但是对于RDBMS系统而言,比如MySQL或者是Oracle的关系型数据库,这类传统的关系型数据库由于设计的初衷都不是考虑分布式系统设计,而是保证一致性以及系统可用,尤其是事务操作的一致性,读写实时性抑或是复杂SQL的多表查询,放到分布式系统中实现要更为复杂.于是才有了分布式数据库,比如MongoDB满足CP原则,而CouchDB满足AP原则.同时对于关系型数据库,比如MySQL,我们会通过冗余服务复制来满足分布式系统设计的AP抑或是通过CP + AP的方式实现分库分表的集群.</p>
<p>CAP定理应用如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/cap.png"></p>
<p>因此,当我们在思考分布式系统设计的时候,需要基于CAP定理从业务数据层面去思考我们的架构设计方案.</p>
<h4 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h4><h5 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h5><ul>
<li>原子性(Atomicity)</li>
</ul>
<p>是指一个数据库操作的事务不可分割的工作单位,要么操作成功,要么操作失败.</p>
<ul>
<li>一致性(Consistency)</li>
</ul>
<p>一致性是指事务开启之前以及开启之后数据库的完整性约束没有被破坏.</p>
<ul>
<li>隔离性(Isolation)</li>
</ul>
<p>多个事务并发访问的时候,两个事务之间彼此相互独立并且互不影响,一个事务不应该影响其他事务运行效果.</p>
<ul>
<li>持久化(Durability)</li>
</ul>
<p>意味着在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</p>
<ul>
<li>分布式系统如何保证事务的ACID</li>
</ul>
<p>当我们了解到一个操作具备ACID特性的时候,我们基本上可以认为完成了一个事务操作,而在分布式系统中,实现一个满足ACID的请求操作需要考虑到网络以及节点故障问题等问题,于是就需要通过分布式事务协议来保证完成一个具备ACID特性的请求操作.</p>
<h5 id="2PC事务协议"><a href="#2PC事务协议" class="headerlink" title="2PC事务协议"></a>2PC事务协议</h5><ul>
<li>工作原理</li>
</ul>
<p>分为投票阶段以及提交阶段,集群服务节点扮演角色有协调者(Coordinator)以及事务的参与者(Cohort).</p>
<p>其工作流程如下:</p>
<blockquote>
<p>投票阶段</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_vote01.jpg"></p>
<p>首先向集群服务节点发起一个事务请求操作,即<code>v=v1</code>,这个时候集群服务选举一个协调者来负责接收事务请求的操作,并由协调者统一指挥相应的事务操作.这个时候接收到事务请求之后协调者将向集群服务各个参与事务的节点发起<code>v=v1</code>操作请求,询问是否允许进行操作.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_vote02.jpg"></p>
<p>这个时候服务集群参与者的节点接收到协调者的操作请求,并在执行当前的操作请求的时候进行undo以及redo的日志记录,通过undo日志实现回滚,redo日志实现持久化,最后将响应结果返回给协调者.</p>
<blockquote>
<p>提交阶段 - 成功提交</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_commit01.jpg"></p>
<p>协调者接收到参与者节点进行事务执行操作准备的响应,根据参与者节点的响应结果,为了保证事务的ACID特性,如果所有的参与者节点都允许进行事务<code>v=v1</code>的请求操作时,那么这个时候协调者就会向各个参与者节点服务发起commit的请求并等待各个参与者节点事务操作结果的响应.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_commit02.jpg"></p>
<p>参与者接收到协调者的提交请求之后,这个时候每个参与者节点就可以正常完成单点机器的事务操作,即满足事务ACID的特性,完成事务操作之后每个参与者节点都会向协调者发起事务操作结果的响应.这个时候协调者接收到事务操作响应的结果并向客户端给予事务操作成功的响应.</p>
<blockquote>
<p>提交阶段 - 失败提交</p>
</blockquote>
<ul>
<li>参与者3因网络原因导致超时未响应</li>
<li>参与者3拒绝<code>v=v1</code>的请求操作</li>
</ul>
<p>对于实现分布式事务的ACID,要保证数据的强一致性,因此只要其中有一个参与者节点在进行事务投票阶段发生上述问题,这个时候协调者会视为abort,则协调者下一步将会发起abort的回滚操作,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_rollback01.jpg"></p>
<p>协调者根据参与者节点给予的响应结果作出abort的回滚策略,此时向各个参与者节点发起abort的回滚操作,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_rollback01-1.jpg"></p>
<p>这个时候参与者节点接收到事务回滚操作,将原先保存的undo数据进行恢复,然后将回滚的操作结果响应给协调者,协调者接收到所有残月者节点回滚的响应结果,向客户端发起事务操作失败的响应结果.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_rollback02.jpg"></p>
<blockquote>
<p>2PC产生阻塞</p>
</blockquote>
<ul>
<li>协调者发起请求的时候会等待参与者的响应结果</li>
<li>参与者接收到协调者发起的请求并给予响应此时也处于等待状态,等待提交redo或者回滚undo</li>
<li>此时参与者接收到应答指令执行相应的操作之后,协调者会继续处于等待参与者处理的结果响应</li>
<li>同时,既然是分布式系统,必然离不开网络服务之间的通讯以及机器节点的故障问题,因而如果协调者产生不可用,此时所有的参与者将会一直处于阻塞状态</li>
</ul>
<blockquote>
<p>2PC产生数据不一致</p>
</blockquote>
<ul>
<li>当协调者向参与者发起提交或者是回滚操作的时候,其中有一个参与者服务节点产生不可用的情况,这个时候参与者节点将无法接收到提交或者回滚信息,那么这个时候就会产生数据不一致.</li>
</ul>
<blockquote>
<p>2PC的整体流程总结</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/2pc_flow.jpg"></p>
<h5 id="3PC事务协议"><a href="#3PC事务协议" class="headerlink" title="3PC事务协议"></a>3PC事务协议</h5><p>在实际应用场景中,3PC的使用场景并不多,大部分是基于2pc的实现来完成分布式事务,甚至是为了保证数据的强一致性会采取TCC的事务协议来完成,对于3PC现简单阐述如下.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/3pc_flow.jpg"></p>
<blockquote>
<p>3PC提交过程说明</p>
</blockquote>
<ul>
<li><p>协调者服务节点发起事务请求给到参与者节点询问是否允许事务请求提交</p>
</li>
<li><p>参与者节点接收到事务请求提交之后将当前数据记录到undo日志中,以便于后续请求的超时或者是无响应进行事务的回滚,这个时候记录undo日志之后返回给协调者告知请求提交的结果</p>
</li>
<li><p>协调者此时如果没有接收到参与者的请求提交响应回复抑或是拒绝请求提交将终止当前操作不再继续下一步;如果收到允许请求提交操作,则会向参与者节点发起预提交请求到参与者节点中</p>
</li>
<li><p>参与者节点如果没有接收到预提交的请求抑或是网络延迟中断,那么就会将上次的undo日志进行数据回复并丢弃当前的事务操作;如果能正确接收到预提交的请求操作,那么这个时候会将更新的数据记录到redo日志中,以便于后续进行持久化.</p>
</li>
<li><p>对于协调者而言,如果正确接收到预提交请求的ACK响应,那么这个时候将会执行请求提交到参与者节点;如果没有接收到ACK的响应抑或是网络超时问题,将会直接丢弃当前的事务操作.</p>
</li>
<li><p>而对于第三阶段的确认提交,参与者节点不论是网络中断还是超时抑或是正常接收到doCommit的提交请求操作,那么这个时候都会执行redo日志进行持久化操作并响应给协调者节点告知当前事务操作完成并且已经提交.</p>
</li>
</ul>
<blockquote>
<p>3PC存在的数据不一致问题</p>
</blockquote>
<p>通过上述的流程分析,我们很容易得出,3PC的事务协议提交阶段存在的数据不一致主要体现在:</p>
<p>在协调者进行预提交阶段,协调者服务节点向参与者节点发起预提交请求,其中向参与者集群服务节点已成功发起预提交请求,但是这个时候协调者服务节点发生故障导致不可用,那么就会导致参与者节点服务部分没有收到预提交的请求,这个时候这部分参与者节点由于没有收到preCommit请求而进行undo日志的回滚.</p>
<h5 id="TCC事务协议"><a href="#TCC事务协议" class="headerlink" title="TCC事务协议"></a>TCC事务协议</h5><blockquote>
<p>TCC定义</p>
</blockquote>
<p>TCC,即Try(预留资源)-Confirm(确认操作)-Cancel(撤销操作),其核心流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/tcc_flow.jpg"></p>
<blockquote>
<p>TCC原理分析</p>
</blockquote>
<ul>
<li>在主服务节点注册一个确认以及撤销的操作,然后在主服务节点开启事务执行资源的锁定并预留可用的资源,然后提交消息分发到各个子服务节点中</li>
<li>子服务节点接收到主服务节点的事务操作消息,这个时候子服务也将自己对应的资源进行锁定,同时也将可用的资源预留出来以便于提升并发操作的性能,然后向主服务节点推送操作结果的消息为Success或者是Fail</li>
<li>主服务节点根据各个子服务节点操作结果的反馈,如果存在一个子服务节点的Fail反馈,那么就执行撤销回滚操作并将锁定的资源回收到资源池中来保证整个分布式事务的ACID,如果返回都是Success,那么就执行确认操作释放锁定资源.最后将操作结果以消息的形式分发到各个子服务节点上</li>
<li>子服务节点接收到主服务节点的事务确认或者回滚消息,也将执行相应的确认或者是回滚操作,如果是回滚操作,那么同样也将锁定的资源回收到资源池中,如果是执行确认操作,那么就释放资源.</li>
</ul>
<p>可以看到TCC是建立在业务基础上来保证分散的服务节点的事务一致性,实现相对比2PC更为复杂些.</p>
<blockquote>
<p>TCC各个服务节点运作</p>
</blockquote>
<p>以一个送礼下单为例展开,现有一个订单服务,礼物服务以及用户积分服务.如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/tcc_tx.jpg"></p>
<p>订单服务可以认为是一个主服务,主要负责订单状态的更新,而礼物服务以及积分服务作为一个子服务,负责更新礼物库存以及积分信息.于是对于一个TCC的操作流程可以分解为如下几个步骤:</p>
<ul>
<li>订单服务接收到送礼下单的请求,那么这个时候订单服务将会创建一个订单并设置当前的订单状态为PENDING以便于提升并发性能查询而并非出于创建订单的阻塞等待状态,同时分发消息到礼物服务以及积分服务.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/tcc_s1.jpg"></p>
<ul>
<li>礼物服务以及积分服务分别收到订单服务发出的事务操作请求命令,这个时候礼物服务以及积分服务分别记录redo以及undo日志,redo可以理解为可用资源提供外界查询以实现并发访问的性能,undo锁定使用的资源以便于回滚,这里的redo可以是对应的数据库变更数据的记录,undo日志记录变更的数据以及当前为锁定状态.然后将操作结果返回给订单服务节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/tcc_s2.jpg"></p>
<ul>
<li>订单服务节点更新返回的子服务消息结果,如果都是操作成功,那么这个时候就执行确认操作,订单服务将订单状态更新为FINISHED,并将消息分发到各个服务节点,如果存在一个节点操作失败,则执行更新状态为REJECTED,并下发回滚操作的消息.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/base/tcc_s3.jpg"></p>
<p>基于上述的认知之后,我们要实现一个基于TCC的分布式事务,如果在没有使用开源产品的场景下,最简单的方式是可以基于MQ的方式来实现可靠消息的生产与消费从而实现我们的分布式事务协议TCC.</p>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><blockquote>
<p>BASE理论定义</p>
</blockquote>
<p>BASE是Basically Available(基本可用),Soft Sate(软状态)以及Eventual Consistency(最终一致性)三个短语的缩写.</p>
<ul>
<li>基本可用:可能是部分功能不可用或者是因网络原因响应时间延迟导致延迟的时间段内不可用</li>
<li>软状态:集群服务节点在进行数据同步期间数据的过渡状态.比如一个事务操作前为v1,进行事务操作后为v2,节点服务之间数据由v1转变为v2的状态为过渡状态.</li>
<li>最终一致性:经过系统内部服务之间的运行协作,最终服务节点表现在业务上抑或是集群leader选举或者是数据上等最终保持一致性</li>
</ul>
<blockquote>
<p>数据一致性模型</p>
</blockquote>
<ul>
<li>线性一致性(强一致性): 不论是在集群服务哪个节点,看到的数据最终都是一致性.</li>
<li>顺序一致性(弱一致性): 集群服务节点的数据变动以及操作顺序保持一致.</li>
<li>最终一致性(弱一致性): 集群的所有服务节点最终都会呈现数据的一致性</li>
</ul>
<blockquote>
<p>基本可用策略</p>
</blockquote>
<ul>
<li><p>流量削峰:应对高并发量冲击,可以从以下几个方面来考虑问题,一个是错开时间段;一个是限流+错开时间段,比如预约抢购;一个是在边缘节点抑或是负责均衡器做流控;一个是在应用程序中基于MQ消息队列来做缓冲;一个是在底层数据库表采取分区表,不够再进行分库分表设计.</p>
</li>
<li><p>延迟响应: 比如在进行购票的时候,我们会提交购票请求然后需要进入系统的排队等候,等待请求被处理.</p>
</li>
<li><p>降级: 一个是当被调用的服务依赖不可用时,为了服务调用者节点时可用的,需要加入异常处理的降级操作;又或者是在负载均衡器中发现后端服务不可用的时候可以采取降级返回错误提示等</p>
</li>
<li><p>过载保护: 在抢购或者是秒杀系统中,可以考虑在nginx中进行限流然后将超出的流量直接放回抢购失败;抑或是在应用服务中的线程池中将任务添加到阻塞队列中,如果队列满了可以考虑直接丢弃任务策略.</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 有状态与无状态服务</span><br><span class="line">https://nordicapis.com/defining-stateful-vs-stateless-web-services/</span><br><span class="line"></span><br><span class="line">## CAP定理</span><br><span class="line">https://dzone.com/articles/understanding-the-cap-theorem</span><br><span class="line">https://dzone.com/articles/quick-notes-what-cap-theorem</span><br></pre></td></tr></table></figure>

<p>最后关于一致性的详细分析留到下一篇文章中.</p>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性</title>
    <url>/2020/06/24/consistency/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h3><p>在讲述分布式一致性的时候,我们需要明确以下两件事情,其一是分布式事务与一致性的区分,事务的隔离主要是为了避免由于并发执行事务而产生的竞争条件,而分布式一致性主要是为了在遇到延迟和错误时协调副本的状态.两者的关注点并不相同;其二是分布式一致性与分布式共识问题,分布式一致性可以理解为“所有的服务节点看到的数据都是相同的状态”,而分布式共识问题可以理解为“所有的服务节点最终作出相同的决定值/策略”.但是分布式一致性又和上述的事务与共识问题存在着联系,也就是说当我们完成一个分布式事务抑或是服务节点达成共识之后就需要考虑一致性问题.因此对于一致性的讨论离不开共识问题的解决(事务也可以算共识问题的一个子域),因此文章会结合共识问题与一致性展开讨论.</p>
<h4 id="分布式一致性简述"><a href="#分布式一致性简述" class="headerlink" title="分布式一致性简述"></a>分布式一致性简述</h4><ul>
<li>复制延迟问题</li>
</ul>
<p>在一个存储的主从服务架构中,如果此时向主节点发起写请求操作成功之后,在主节点通过binlog进行从服务节点数据同步过程,这个时候主服务节点与从服务节点上看到的数据是不一致的,因为写请求的操作是在不同的时间点到达的,因此不论采取的存储服务是使用哪种架构方案(单leader复制架构/多leader复制架构/无leader复制架构)都会产生短暂时间内的数据的一致性.</p>
<ul>
<li>一致性保证</li>
</ul>
<p>大部分副本存储层系统都采取最终一致性,即在主节点进行数据同步过程中,期间如果有读取请求落地到从服务节点中,那么这个时候会将读取请求线程挂起并等待主从数据同步完成,当同步完成之后将当前的读取请求线程唤醒以保证当前读取请求服务是读取到最新的一份写入数据.换言之,就是当前的网络发生故障但是最终是可以修复的情况下,存储层服务节点会出现短暂的数据不一致,对于最终一致性有一个更好的名称,即收敛(convergence),因为我们期望存储层的服务节点最终收敛到相同的数据值.</p>
<h4 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在上述的一个数据存储层架构中,主服务节点进行数据同步的时候会产生复制延迟导致从服务节点出现短暂的数据不一致性.那是否存在这样的解决方案,即如果数据库能够给对于读取请求服务的客户端程序而言只有一个数据副本的错觉,那么这个时候对于读取数据的客户端就能够实时读取到一份最新的数据而不需要关心复制延迟的问题?</p>
<h5 id="解决方案的核心思想"><a href="#解决方案的核心思想" class="headerlink" title="解决方案的核心思想"></a>解决方案的核心思想</h5><p>要实现上述的需求,在分布式系统中有一个解决方案就是通过线性一致性(也可称为原子一致性/强一致性/直接一致性/外部一致性),其基本思想就是使系统看起来好像只有一个副本,并且对它的所有操作都具备原子性,有了这个保证,即使实际上有很多的数据副本应用程序也不需要再担心复制延迟的问题.</p>
<h5 id="线性一致性分析"><a href="#线性一致性分析" class="headerlink" title="线性一致性分析"></a>线性一致性分析</h5><blockquote>
<p>非一致性的系统模型</p>
</blockquote>
<ul>
<li>由于网络延迟问题产生数据不一致</li>
</ul>
<p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/consistency/consistency.jpg"></p>
<ul>
<li>数据库强一致性分析</li>
</ul>
<p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/consistency/isoluation_consistency.jpg"></p>
<p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/consistency/isoluation_consistency2.jpg"></p>
<p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/consistency/isoluation_consistency3.jpg"></p>
<blockquote>
<p>串行化与强一致性区分</p>
</blockquote>
<ul>
<li>串行化</li>
</ul>
<ul>
<li>强一致性</li>
</ul>
<h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><p>分布事件的执行顺序一致性问题</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><h4 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h4><h5 id="有状态服务"><a href="#有状态服务" class="headerlink" title="有状态服务"></a>有状态服务</h5><h5 id="无状态服务"><a href="#无状态服务" class="headerlink" title="无状态服务"></a>无状态服务</h5>]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式技术小结</title>
    <url>/2021/05/02/distributed/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="宏观角度-分布式设计目标"><a href="#宏观角度-分布式设计目标" class="headerlink" title="宏观角度 - 分布式设计目标"></a>宏观角度 - 分布式设计目标</h3><h4 id="分布式设计的目标"><a href="#分布式设计的目标" class="headerlink" title="分布式设计的目标"></a>分布式设计的目标</h4><p>从宏观上思考,设计分布式系统的目标是实现系统的高性能以及高可用,而实现上述的分布式目标也会引入新的问题,即分布式技术实现的难点.<br><img src="https://xiaokunliu.github.io/2020/05/10/distributed01/" alt="分布式概要设计1"><br><img src="https://xiaokunliu.github.io/2020/05/14/distributed02/" alt="分布式概要设计2"></p>
<h3 id="微观角度-分布式实践技术"><a href="#微观角度-分布式实践技术" class="headerlink" title="微观角度 - 分布式实践技术"></a>微观角度 - 分布式实践技术</h3><h4 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h4><ul>
<li><p>核心理论：CAP理论 &amp; BASE理论 &amp; 全局时钟 &amp; 逻辑时钟</p>
</li>
<li><p>事务相关：ACID &amp;&amp; 2PC &amp; 3PC &amp; TCC<br><img src="https://xiaokunliu.github.io/2020/06/08/cap/" alt="分布式核心理论"></p>
</li>
<li><p>分布式一致性问题<br><img src="https://xiaokunliu.github.io/2020/06/24/consistency/" alt="一致性问题"></p>
</li>
<li><p>一致性</p>
<ul>
<li>强一致性</li>
<li>弱一致性(BASE理论 &amp; 全局时钟 &amp; 逻辑时钟)</li>
</ul>
</li>
</ul>
<h4 id="分布式协议与算法"><a href="#分布式协议与算法" class="headerlink" title="分布式协议与算法"></a>分布式协议与算法</h4><ul>
<li><p>共识问题<br><img src="https://xiaokunliu.github.io/2020/05/27/byzantine/" alt="共识算法"></p>
</li>
<li><p>Paxos算法<br><img src="https://xiaokunliu.github.io/2020/07/04/paxos/" alt="Paxos算法"></p>
</li>
<li><p>Raft算法<br><img src="https://xiaokunliu.github.io/2020/07/24/raft/" alt="Raft算法简述"><br><img src="https://xiaokunliu.github.io/2020/08/24/raft02/" alt="Raft补充"></p>
</li>
<li><p>一致性Hash算法<br><img src="https://xiaokunliu.github.io/2020/10/01/single_consistence/" alt="单节点hash算法"></p>
</li>
<li><p>Quorum机制</p>
</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul>
<li>理论相关：XA，2PC，3PC，TCC协议，Seta事务以及MQ事务实现BASE最终一致性</li>
<li>锁机制以及分布式锁的原理</li>
<li>全局ID设计</li>
</ul>
<h4 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h4><ul>
<li>RPC通信机制以及原理</li>
<li>http1 &amp; http1.1 &amp; http2</li>
<li>gRPC通信机制</li>
</ul>
<h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4><ul>
<li>配置中心</li>
<li>注册中心</li>
<li>服务协调者</li>
<li>链路追踪</li>
<li>服务网关</li>
</ul>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4>]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构设计概要总结(上)</title>
    <url>/2020/05/10/distributed01/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="分布式架构设计总结"><a href="#分布式架构设计总结" class="headerlink" title="分布式架构设计总结"></a>分布式架构设计总结</h3><h4 id="架构的演进"><a href="#架构的演进" class="headerlink" title="架构的演进"></a>架构的演进</h4><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch01.jpg"></p>
<h4 id="分布式架构设计目标与实现"><a href="#分布式架构设计目标与实现" class="headerlink" title="分布式架构设计目标与实现"></a>分布式架构设计目标与实现</h4><h5 id="分布式架构设计的目标"><a href="#分布式架构设计的目标" class="headerlink" title="分布式架构设计的目标"></a>分布式架构设计的目标</h5><p>使用分布式系统主要有两方面原因:</p>
<ul>
<li>增大系统容量: 我们的业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，我们需要多台机器才能应对大规模的应用场景。所以，我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构.</li>
<li>加强系统可用。我们的业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性. </li>
</ul>
<p>也就是说实现分布式要实现上述两个目标,即保证系统的高性能(增加系统的吞吐量以及快速地响应时间)以及系统的高可用(故障容错处理机制)</p>
<h5 id="分布式架构设计技术手段"><a href="#分布式架构设计技术手段" class="headerlink" title="分布式架构设计技术手段"></a>分布式架构设计技术手段</h5><blockquote>
<p>提升系统容量的技术手段</p>
</blockquote>
<ul>
<li><strong>集群技术</strong>: 通过水平扩展业务处理能力来提升系统的并发处理能力.</li>
<li><strong>缓存设计</strong>: 在我们的上述服务进行水平抑或是垂直扩展的时候,这个时候我们的业务吞吐量也会增加,这个时候会把所有的流量压力打到数据存储系统上,为了缓解数据存储系统的压力,这个时候我们会考虑将数据进行冷热划分,对于热点数据集中在缓存系统服务以降低我们的数据存储压力.对于缓存的设计存在以下三种模式:其一是Cache Aside更新模式,即失效 - 命中 - 更新策略;其二是Read/Write Through更新模式,即缓存更新对应用程序透明,对于应用程序而言只有一个数据存储操作,由cache负载更新数据操作;其三是Write Back模型,类似于Linux下的Page Cache算法,应用程序直接将数据更新到cache中,有cache异步批量更新到数据库中.</li>
<li><strong>垂直拆分业务(服务化设计)</strong>: 当我们的一个服务节点承担复杂繁多的业务服务的时候,必然会影响到我们业务处理的能力,为了提升我们的并发处理能力,为了提升我们的系统并发能力,可以考虑将我们的业务进行垂直拆分,于是就有了一个请求的处理需要多个服务之间进行协作完成.</li>
<li><strong>数据镜像与分区(读写分离/分库分表)</strong>: 尽管使用缓存可以缓解我们的服务压力,但是仍然无法从根源上缓解流量对数据存储的压力,于是我们一方面会做读写分离,做主从集群,主节点负责处理事务的数据写入,从节点数据负责数据的读取;另一方面为了提升单库单表的并发能力,这个时候我们也是借助分而治之的设计思想,采取分库分表的思路来缓解我们单库单表的流量压力.</li>
<li><strong>借助MQ中间件实现异步处理</strong>: 可以通过中间件技术实现异步处理,对流量进行削峰缓冲,进一步提高了程序的并发处理能力以及系统的稳定性.</li>
<li><strong>数据异构设计</strong>: 将同一个业务数据按照业务需求的用途划分为不同的数据仓库存储以适用相应的业务需求场景,比如对于爬虫的聚合资讯数据来源存在很多不确定的因素,我们可以通过MQ的方式接收数据变更并将数据持久化存储到ES存储的引擎中,抑或是查询一个用户的订单信息,如果按照订单表的订单ID进行拆分,则需要聚合多张表才能返回相应的聚合数据,这个时候可以采取按照用户维度来进行异构一个与用户相关的订单数据仓库的策略(存在数据冗余,但是提升读取性能).</li>
</ul>
<p>简而言之,实现分布式高性能的技术主要利用分而治之的设计思想,同时随着业务的发展与架构的演进,引入了服务化的架构设计方案,缓存技术以及更为底层的性能优化.</p>
<blockquote>
<p>实现高可用技术手段</p>
</blockquote>
<p>分布式架构设计同时还需要具备另一个很重要的目标就是服务高可用,纵然我们的服务性能再好,如果无法保证服务节点的可用性,那么性能再提高也于事无补,于是我们还需要关注分布式中高可用的技术手段,即如下:</p>
<ul>
<li><strong>服务冗余与负载均衡技术</strong>: 从集群角度上思考,我们需要考虑集群是流量如何分担到集群服务的节点,集群服务节点出现异常或者不可用的时候流量如何切换,这个时候我们就需要考虑到负载均衡技术来帮助我们实现流量分发的调度,对服务节点采取心跳检测以及当服务节点异常采取重试与流量切换重新调度分配可用服务节点来避免单点故障问题,简而言之服务的高可用可以是服务冗余与负载均衡技术来避免单点故障,实现故障自动的恢复.</li>
<li><strong>隔离技术</strong>: 为了防止故障蔓延到其他服务节点,我们通常会采取隔离技术来隔离拆分的业务服务,每个业务服务分别各自独立部署,在分布式系统设计中,一般会服务的种类或者是用户来进行隔离.</li>
<li><strong>降级与限流技术</strong>:当系统承担的并发流量服务压力十分庞大的时候,这个时候我们需要采取保护措施,通过降级或者限流的技术来停用部分业务服务或者是拒绝部分用户的请求操作以确保整个系统不会被流量冲垮导致整体不可用. </li>
<li><strong>超时重试与熔断</strong>: 在服务化架构设计中,为了防止服务产生雪崩,需要在调用服务加入超时重试以及熔断机制,避免将错误蔓延到其他服务导致整个系统服务不可用.从而缩小部分服务.</li>
<li><strong>高可用架构设计</strong>: 利用服务冗余来避免单点故障,比如多租户隔离,灾备多活抑或是数据副本保证一致性,高可用不仅是的服务集群的高可用,还有就是中间件实现高可用设计.</li>
<li><strong>高可用的运维</strong>:实现devops的CI或者CD的持续集成计划任务,能够构建执行自动化测试,实现灰度发布部署以及线上系统的自动化控制.</li>
<li><strong>缓存的高可用</strong>:对于缓存系统也需要采用集群高可用的方式来避免单点故障以及实现故障恢复,同时对于缓存系统要实现高可用,需要注意以下几个问题:<ol>
<li>一个是缓存穿透,即对于不存在的数据缓存始终都是没有命中会直接将流量打到数据存储层上.</li>
<li>一个是缓存雪崩,即在某一个时刻,所有的缓存都失效过期,这个时候流量都会打到数据存储层,很容易引起数据存储层的并发性能问题</li>
<li>最后一个是缓存击穿,即针对某一个热点缓存在某一个时间点存在并发访问量请求并且当前时间点缓存时间已经过期需要刷新缓存,这样也会将流量打到数据存层上.<br>因此对于缓存的高可用不仅需要避免单点故障,同时还需要具备容错能力,比如增加布隆过滤器来控制缓存穿透,根据不同的业务场景可以采取随机时间段的缓存时间来避免同一个时间点缓存失效以及对于具备热点的共享资源缓存操作,需要借助中间件的协调者来管理和控制我们的应用服务的操作避免缓存击穿的产生.</li>
</ol>
</li>
<li><strong>服务化架构的高可用技术</strong>: 对于垂直拆分的业务我们将会对其做成业务的服务化设计,这个时候对于服务化架构的设计,我们需要解决服务与服务之间的通信,同时随着服务越来越多,服务依赖越来越多以及调用链路也会越来越频繁,同时服务为了避免单点故障,会引入服务集群,那么这个时候我们就需要对我们系统的不同服务集群进行管理,于是我们需要减轻我们的服务维护管理等繁琐工作,就有了服务治理(服务通信RPC/服务版本管理与维护/服务注册与发现/服务容错处理/服务安全控制/服务部署与指标监控等).</li>
</ul>
<h4 id="分布式面临难点"><a href="#分布式面临难点" class="headerlink" title="分布式面临难点"></a>分布式面临难点</h4><p>基于上述的认知,我们认识到分布式架构设计基本是围绕着提升系统容量以及保证系统的高可用展开,但是也引入一些问题:</p>
<ul>
<li>服务治理: 服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。</li>
<li>架构软件管理: 服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。</li>
<li>DevOps: 分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</li>
<li>自动化运维: 有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</li>
<li>资源调度管理: 应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</li>
<li>整体架构监控:如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</li>
<li>流量控制: 最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch02.jpg"></p>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构设计概要总结(下)</title>
    <url>/2020/05/14/distributed02/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="分布式架构概要总结"><a href="#分布式架构概要总结" class="headerlink" title="分布式架构概要总结"></a>分布式架构概要总结</h3><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch00.jpg"><br>在互联网企业中，经常离不开的术语就是分布式架构和微服务相关的词汇，如果让你来设计一个分布式系统，你会以什么样的维度去构思我们的分布式系统呢？<br>首先，我们需要明白为什么需要分布式系统，它的实现目标是什么；其次当我们对分布式目标清晰之后，那么我们实现可以从目标的维度思考可采取的技术手段有哪些；<br>接着我们对技术栈知识有了一个基本认知之后，这个时候又要要求我们思考架构设计的不仅是全局宏观的技术栈视野，还要具备全局的业务服务视野来思考并落地我们的分布式架构的设计。<br>因此对于分布式架构的学习是一个漫长的过程，先要清楚目标，然后弄明白实现目标的技术方案,，最后结合我们的技术栈与业务体系从宏观以及微观上去思考并落地我们的分布式架构设计。</p>
<h4 id="构建分布式的原因"><a href="#构建分布式的原因" class="headerlink" title="构建分布式的原因"></a>构建分布式的原因</h4><h5 id="业务架构的演进"><a href="#业务架构的演进" class="headerlink" title="业务架构的演进"></a>业务架构的演进</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch01.jpg"></p>
<p>在上图简单以时间线为准，粗略描述了我们系统架构随着业务的需求考量以及业务的发展，系统承担的并发量也将逐步提升，这就要求我们的系统架构需要开始思考如何利用现有的资源来解决。<br>我们目前急需处理并发请求的服务.而思考的方向可以从我们已有的计算机知识体系中找到答案。比如：</p>
<ul>
<li>对于并发问题，我们知道处理共享资源可以通过加锁的方式来保证我们的线程安全，那么在有限的资源下又要如何提升我们的并发量，于是我们很容易想到hashmap是如何处理线程安全的，对此我们就会考虑到一个设计思想，那就是分而治之的策略，即是否可以将共享资源拆分成多份来缓解我们的压力,即集群.</li>
<li>这个时候我们的流量压力通过集群分担到各个应用中，但是此时对数据库的压力反而增加了，于是我们会想到使用缓存策略来缓解我们的压力，对于缓存架构，我们也可以采用CPU高速缓存的策略来对我们现有的服务进行改进。</li>
<li>另外,随着业务的增长以及需求不断地调整变化，有时候为了提升我们的查询性能，还需要以不同的维度重新构建数据库表结构。比如订单服务，可以以用户维护进行数据异构产生用户与订单服务的数据库表结构来提升我们的查询性能。其实对于这种数据异构在编程设计中也是有体现的，比如表单的业务 bean 与数据库存储的业务 bean 多少存在一些冗余但可能是类型或者是状态显示不同，目的当然是简化便于理解。</li>
<li>随着业务不断扩大，团队人员也在增加，考虑到快速交付产品需求，我们可以划分团队负责不同的业务线，于是便有了服务的垂直拆分，也就是我们的服务化架构，在分布式架构设计中引入服务化架构是我们根据团队以及业务进行拆分的结果，目的是为了更快速交付，同时也是为了更为专注业务开发的落地实现。</li>
</ul>
<p>引入性能技术的优化方案之后，这个时候我们从另外一个视角来看，即一个置身于互联网大环境下的项目系统,我们需要保证分布式系统服务的高可用。</p>
<h5 id="构建分布式系统的两个核心因素"><a href="#构建分布式系统的两个核心因素" class="headerlink" title="构建分布式系统的两个核心因素"></a>构建分布式系统的两个核心因素</h5><p>对此，一个分布式系统服务需要具备以下两个因素：</p>
<ul>
<li>增大系统容量: 我们的业务量越来越大，而要能应对越来越大的业务量，采取分而治之的设计思想，通过进行水平或是垂直拆分业务系统，让其变成一个分布式的架构。</li>
<li>保证系统服务的高可用: 为了增大系统容量，我们将业务进行拆分，彼此独立，但是每一块业务线都有其重要意义。因此我们就需要保证每一块业务线的服务不能存在单点故障，这样整个系统不会因为单点服务出故障而导致业务服务系统不可用，所以需要通过做节点冗余系统以消除单点故障，从而提高系统的可用性。 </li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们使用分布式的设计来源于”分而治之”的思想，从整个系统架构上看，构建分布式架构的原因就是要扛住互联网海量并发请求处理以及在此基础上保证我们的系统服务具备高可用，抑或是允许一小部分服务不可用。</p>
<h4 id="分布式术语"><a href="#分布式术语" class="headerlink" title="分布式术语"></a>分布式术语</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h5><p>可以是操作系统上的一个进程服务，也可以是分布式系统中一组提供处理逻辑的程序并能够独立部署运作，在整个分布式系统中与其他服务协作也可以独立完成业务的请求处理操作。</p>
<h5 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h5><p>在分布式系统中，为了提升服务的并发处理能力，部署多个节点来提供相同的一组业务服务操作，这多个提供服务的节点组成一个集群。</p>
<h5 id="副本"><a href="#副本" class="headerlink" title="副本"></a><strong>副本</strong></h5><p>在分布式系统中提供数据抑或是服务的冗余来保证系统的高可用，数据副本是指在不同的节点上持久化存储一份相同的数据，服务副本是指在不同的节点上部署一套或一组提供相同业务处理逻辑的服务，一般形成主从来保证服务节点的高可用。</p>
<h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a><strong>中间件</strong></h5><p>独立于应用服务，位于操作系统之上的一套为集群节点服务解决问题的通用方案的组件，简化开发人员的工作，让开发者更专注于业务上的开发。<br>比如服务与服务之间通过消息中间件实现异步通信，实现服务解耦；<br>为了加速数据访问速度,我们引入缓存中间件，为应用层与存储层提供一个缓存的过程，避免所有相同的数据查询操作的流量都落地到数据存储层；<br>同时我们还看到接入层节点抑或是网关服务节点要实现高可用保证，需要引入负载均衡中间件实现高可用；<br>再或者应用层与实现分片的数据存储层进行数据交互，为简化开发以及查询匹配等因素引入数据库中间件，从而对于应用层仍然可以透明地实现对数据存储的CRUD等操作，而无须关系数据匹配以及一致性等问题。</p>
<h5 id="SOA与微服务架构"><a href="#SOA与微服务架构" class="headerlink" title="SOA与微服务架构"></a><strong>SOA与微服务架构</strong></h5><p>SOA为面向服务的架构，是属于一种设计方法，每个服务之间都相互独立且通过网络进行服务调用来完成一次复杂的业务请求操作；<br>微服务架构是在SOA的基础上演进而来，强调组件化与服务化，每个组件提供独立的服务可以实现可伸缩性的扩展。可以独立开发，设计，部署与优化而不影响微服务中其他的组件。</p>
<h5 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a><strong>分布式协调</strong></h5><p>其一分布式的多个服务节点之间的业务处理逻辑仍然需要保证与单体架构执行的业务逻辑处理顺序一致，即保证服务节点处理业务请的逻辑具备有序性；<br>其二是对于共享资源的争用，在单体架构中我们通过加锁的方式来保证并发处理共享资源的安全性，同理对于分布式的多服务节点对共享资源进行事务操作的时候我们也需要协调各个服务节点的并发控制，保证系统服务中的共享资源的事务操作具备原子性以及数据一致性。<br>因此，<strong>对于分布式协调我们可以理解一个是协调服务节点来保证业务处理的有序性，一个是协调服务节点来保证并发操作共享资源的原子性以及数据的一致性。</strong></p>
<h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a><strong>服务治理</strong></h5><p>对于服务治理的理解，我们需要切换一个维度，此时应该从分布式服务化的架构设计上来看待问题，那么服务与服务之间的通信流程如下：<br>服务启动并注册到注册中心 - 调用方从注册中心获取被调用方的服务列表 - 调用方通过负责均衡的方式选择服务 - 调用选择的服务,此时通过网络传输的方式传递消息 - 被调用方接收到消息并执行调用返回，<br>这里涉及到业务拆分成独立服务，服务注册，服务发现，服务依赖以及服务调用链等关系，服务治理就是需要将服务之间的依赖与调用链全部梳理出来统一存储和管理，这样子我们就能够针对各个服务进行分析与优化等操作。</p>
<h5 id="DevOps-amp-自动化运维"><a href="#DevOps-amp-自动化运维" class="headerlink" title="DevOps&amp;自动化运维"></a><strong>DevOps&amp;自动化运维</strong></h5><p>利用CI/CD等持续集成工具来完成一系列业务服务的发布流程，即代码review后提交 - 测试-单元测试-打包-集成测试-UI测试-测试环境发布部署服务-预生产灰度发布服务-真是发布部署服务等一系列流程可以称为DevOps全流程，这对于我们做服务化架构能够实现快速迭代开发；<br>有了DevOps之后，我们就可以针对我们的业务服务进行自动伸缩，故障转移，配置管理，状态管理等一系列自动化运维工作。</p>
<h4 id="分布式技术"><a href="#分布式技术" class="headerlink" title="分布式技术"></a>分布式技术</h4><h5 id="架构的高性能"><a href="#架构的高性能" class="headerlink" title="架构的高性能"></a>架构的高性能</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch03.jpg"></p>
<p>这里引入网名左耳朵耗子讲解分布式高性能相关的技术，我觉得已经很好地诠释了分布式高性能技术栈，对于高性能方面，自己也基于上述的基础上做一些补充:</p>
<blockquote>
<p>集群与负载均衡</p>
</blockquote>
<p>通过水平扩展业务处理能力来提升系统的并发处理能力。</p>
<blockquote>
<p>缓存设计</p>
</blockquote>
<p>在我们的上述服务进行水平抑或是垂直扩展的时候，这个时候我们的业务吞吐量也会增加，这个时候会把所有的流量压力打到数据存储系统上，为了缓解数据存储系统的压力，这个时候我们会考虑将数据进行冷热划分，对于热点数据集中在缓存系统服务以降低我们的数据存储压力。<br>对于缓存的设计存在以下三种模式:</p>
<ul>
<li>其一是Cache Aside更新模式，即失效 - 命中 - 更新策略；</li>
<li>其二是Read/Write Through更新模式，即缓存更新对应用程序透明，对于应用程序而言只有一个数据存储操作，由cache负载更新数据操作；</li>
<li>其三是Write Back模型，类似于Linux下的Page Cache算法，应用程序直接将数据更新到cache中，有cache异步批量更新到数据库中。</li>
</ul>
<blockquote>
<p>垂直拆分业务(服务化设计)</p>
</blockquote>
<p>当我们的一个服务节点承担复杂繁多的业务服务的时候，必然会影响到我们业务处理的能力，为了提升我们的并发处理能力，为了提升我们的系统并发能力，可以考虑将我们的业务进行垂直拆分，于是就有了一个请求的处理需要多个服务之间进行协作完成。</p>
<blockquote>
<p>数据镜像与分区(读写分离/分库分表)</p>
</blockquote>
<p>尽管使用缓存可以缓解我们的服务压力，但是仍然无法从根源上缓解流量对数据存储的压力，于是我们一方面会做读写分离，做主从集群，主节点负责处理事务的数据写入，从节点数据负责数据的读取；<br>另一方面为了提升单库单表的并发能力，这个时候我们也是借助分而治之的设计思想，采取分库分表的思路来缓解我们单库单表的流量压力。</p>
<blockquote>
<p>借助MQ中间件实现异步处理</p>
</blockquote>
<p>可以通过中间件技术实现异步处理，对流量进行削峰缓冲，进一步提高了程序的并发处理能力以及系统的稳定性。</p>
<blockquote>
<p>数据异构设计</p>
</blockquote>
<p>将同一个业务数据按照业务需求的用途划分为不同的数据仓库存储以适用相应的业务需求场景，<br>比如对于爬虫的聚合资讯数据来源存在很多不确定的因素，我们可以通过MQ的方式接收数据变更并将数据持久化存储到ES存储的引擎中；<br>抑或是查询一个用户的订单信息，如果按照订单表的订单ID进行拆分，则需要聚合多张表才能返回相应的聚合数据，这个时候可以采取按照用户维度来进行异构一个与用户相关的订单数据仓库的策略(存在数据冗余,但是提升读取性能)。</p>
<h5 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch04.jpg"></p>
<p>同样地,这里也是引入网名左耳朵耗子讲解分布式高可用相关的技术，在此基础自己也做以下的一些补充:</p>
<blockquote>
<p>服务冗余与负载均衡技术</p>
</blockquote>
<p>从集群角度上思考，我们需要考虑集群是流量如何分担到集群服务的节点，集群服务节点出现异常或者不可用的时候流量如何切换，这个时候我们就需要考虑到负载均衡技术来帮助我们实现流量分发的调度，对服务节点采取心跳检测以及当服务节点异常采取重试与流量切换重新调度分配可用服务节点来避免单点故障问题，简而言之服务的高可用可以是服务冗余与负载均衡技术来避免单点故障，实现故障自动的恢复。</p>
<blockquote>
<p>隔离技术</p>
</blockquote>
<p>为了防止故障蔓延到其他服务节点，我们通常会采取隔离技术来隔离拆分的业务服务，每个业务服务分别各自独立部署，在分布式系统设计中，一般会服务的种类或者是用户来进行隔离。</p>
<blockquote>
<p>降级与限流技术</p>
</blockquote>
<p>当系统承担的并发流量服务压力十分庞大的时候，这个时候我们需要采取保护措施，通过降级或者限流的技术来停用部分业务服务或者是拒绝部分用户的请求操作以确保整个系统不会被流量冲垮导致整体不可用。</p>
<blockquote>
<p>超时重试与熔断</p>
</blockquote>
<p>在服务化架构设计中，为了防止服务产生雪崩，需要在调用服务加入超时重试以及熔断机制，避免将错误蔓延到其他服务导致整个系统服务不可用。从而缩小部分服务。</p>
<blockquote>
<p>高可用架构设计</p>
</blockquote>
<p>利用服务冗余来避免单点故障，比如多租户隔离，灾备多活抑或是数据副本保证一致性，高可用不仅是的服务集群的高可用，还有就是中间件实现高可用设计。</p>
<blockquote>
<p>高可用的运维</p>
</blockquote>
<p>实现devops的CI或者CD的持续集成计划任务，能够构建执行自动化测试，实现灰度发布部署以及线上系统的自动化控制。</p>
<blockquote>
<p>缓存的高可用</p>
</blockquote>
<p>对于缓存系统也需要采用集群高可用的方式来避免单点故障以及实现故障恢复，同时对于缓存系统要实现高可用，需要注意以下几个问题:</p>
<ul>
<li>缓存穿透：即对于不存在的数据缓存始终都是没有命中会直接将流量打到数据存储层上。</li>
<li>缓存雪崩：即在某一个时刻，所有的缓存都失效过期，这个时候流量都会打到数据存储层，很容易引起数据存储层的并发性能问题。</li>
<li>缓存击穿：即针对某一个热点缓存在某一个时间点存在并发访问量请求并且当前时间点缓存时间已经过期需要刷新缓存，这样也会将流量打到数据存层上。<br>因此对于缓存的高可用不仅需要避免单点故障，同时还需要具备容错能力，比如增加布隆过滤器来控制缓存穿透，根据不同的业务场景可以采取随机时间段的缓存时间来避免同一个时间点缓存失效以及对于具备热点的共享资源缓存操作，需要借助中间件的协调者来管理和控制我们的应用服务的操作避免缓存击穿的产生。</li>
</ul>
<blockquote>
<p>切流量 </p>
</blockquote>
<p>面临高并发流量的接入时，我们并无法保证所有服务节点都是可用状态，于是需要在接入层或者服务网关做故障转移，将流量切换到可用的服务节点上。</p>
<blockquote>
<p>可回滚</p>
</blockquote>
<p>在分布式的服务化架构设计，我们需要对服务实施版本控制与管理，一旦新发布的服务节点产生测试不可预知的测试，为了减少服务不可用时长抑或是服务的覆盖面，我们需要对服务进行回滚到上一个稳定版本以保证线上服务可用。</p>
<h5 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h5><blockquote>
<p>防重与幂等设计 </p>
</blockquote>
<p>当我们应用在单位时间内接收到相同并发的事务请求操作时，这个时候我们需要考虑事务请求操作处理不论多少次请求最终只能处理一次，这个时候可以通过设计防重key或者是防重表来保证我们只处理一次请求。<br>比如下单支付操作，由于支付渠道是无法避免重复支付的，因此对于我们系统服务而言就需要根据业务场景设置防重 key 来保证订单服务抑或是将支付记录在数据表并通过数据表进行查询验证，如果并发量很大的话，我们可以考虑通过MQ来接收支付渠道回调的响应结果并通过鉴权验证之后提交到MQ，再由MQ分发给消费者，这个时候就需要保证幂等，防止重复消息的消费。</p>
<blockquote>
<p>事务补偿机制</p>
</blockquote>
<p>在分布式架构设计中，基于ACID以及BASE理论知识,事务补偿操作可以是保证一系列的业务操作具备原子性而最终达到业务数据一致性的目标，当其中某一个操作出现异常的时候，我们采取重试让其运行得到我们期望的事件状态，如果重试不成功，则采取人工干预抑或是丢弃回滚事件。<br>比如一个支付场景，用户下单之后并没有立即支付，此时商品扣减库存如果在等待15min之后没有收到用户支付的请求，就需要将商品库存释放，此时就需要对此场景进行事务补偿，保证我们的业务最终一致性；<br>再比如一个主播提现系统，一般会有N+1或者N+7的支付平台，那么我们进行主播打款的时候有可能由于第三方支付平台网络不稳定导致支付成功但是没有返回响应，此时我们也需要进行事务补偿，针对不稳定的网络因素进行重试与验证处理，保证数据金额的最终一致性.</p>
<blockquote>
<p>状态机设计</p>
</blockquote>
<p>状态机系统包含条件，事件以及事件触发的状态变更操作，严格按照一定的状态变更规则通过外部事件触发以及条件的判断执行状态变更。<br>比如设计一个订单状态的状态机，我们需要考虑订单状态的变化以及对应触发状态变更的事件，比如下单-订单被创建，支付-支付成功与失败，接单-已接单状态还是拒单状态，订单签收-订单完成以及后续的退单操作对应的订单退款状态等一系列事件触发的订单状态变更形成一个状态机。</p>
<blockquote>
<p>后台系统可反馈</p>
</blockquote>
<p>可以针对一些核心业务功能采取行为记录的日志异步化持久化到数据层上，并通过后台管理系统查看反馈以及重要核心业务流程的追踪分析。</p>
<h5 id="分布式服务指标监控"><a href="#分布式服务指标监控" class="headerlink" title="分布式服务指标监控"></a>分布式服务指标监控</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch05.jpg"></p>
<p>在分布式架构中，最需要做到的就是能清楚每个服务节点运作的细节，此时就需要对整个分布式系统进行全栈监控，即不论是应用服务层(业务服务化)，抑或是平台组件服务还是底层机器的资源监控，我们都需要做到心中有数，才能够针对某一个服务进行排查与优化。</p>
<ul>
<li>基础层:主要监控底层以及资源情况,如CPU/内存/网络/磁盘IO/带宽流量等。</li>
<li>组件层:主要监控我们引入的中间件,比如Redis/MQ等,都需要对组件的容量/io/内存/线程/服务节点健康状态等指标进行监控。</li>
<li>应用层:一般是我们的业务服务上的监控,这个时候我们更关注服务依赖,服务调用链,日志收集,qps/tps等因素。</li>
</ul>
<h4 id="分布式小结"><a href="#分布式小结" class="headerlink" title="分布式小结"></a>分布式小结</h4><h5 id="分布式设计思考的维度"><a href="#分布式设计思考的维度" class="headerlink" title="分布式设计思考的维度"></a>分布式设计思考的维度</h5><blockquote>
<p>两个目标</p>
</blockquote>
<ul>
<li>提高系统的性能</li>
<li>保证系统服务的高可用</li>
</ul>
<blockquote>
<p>宏观的架构技术栈</p>
</blockquote>
<ul>
<li>全栈系统监控: 单机的基础监控 -  中间件服务监控  - 应用服务监控</li>
<li>服务/资源调度: 计算机资源调度  - 服务资源调度 - 架构调度</li>
<li>流量调度: 流量控制 - 流量管理 - 服务治理</li>
<li>状态/数据调度: 数据可用性 - 数据一致性 - 数据分片</li>
<li>DevOps与自动化运维: 基于上述的基础完成一系列的开发 - 版本提交 - 单元测试 - 打包 - 集成测试 - UI测试 - 发布测试环境 - 预生产环境发布 - 灰度发布 - 正式发布.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/arch06.jpg"></p>
<blockquote>
<p>业务服务化设计</p>
</blockquote>
<ul>
<li>性能设计</li>
<li>弹力设计(高可用技术)</li>
<li>业务设计</li>
<li>全栈系统监控</li>
</ul>
<h5 id="分布式面临需要解决的问题"><a href="#分布式面临需要解决的问题" class="headerlink" title="分布式面临需要解决的问题"></a>分布式面临需要解决的问题</h5><blockquote>
<p>技术架构面临的问题</p>
</blockquote>
<ul>
<li>服务节点如何崩溃恢复</li>
<li>分布式缓存问题</li>
<li>共识问题</li>
<li>流量控制（降级限流等策略）</li>
<li>整体架构的监控</li>
<li>自动化运维</li>
</ul>
<blockquote>
<p>服务化架构面临的问题</p>
</blockquote>
<ul>
<li>数据一致性与分布式事务</li>
<li>共享资源与分布式锁</li>
<li>服务治理</li>
<li>服务持续集成流程(DevOps)</li>
<li>服务架构的垂直拆分粒度以及产生的数据一致性问题</li>
</ul>
<p>其实，在这里仅提供一个思考的维度去分析我们的系统服务，在做分布式架构设计的时候，需要在宏观上搭建好技术基础骨架，进行业务分析并结合引入的服务化基础去思考我们架构可能存在的问题并验证设计的合理性与适用性。</p>
<h5 id="分布式理论知识"><a href="#分布式理论知识" class="headerlink" title="分布式理论知识"></a>分布式理论知识</h5><p>在分布式架构设计中，为了解决上述带来的问题，我们需要借助分布式技术已有的基础理论知识来指导并促进我们问题的解决。<br>其中分布式依赖的基础理论知识主要有以下两方面:</p>
<blockquote>
<p>分布式理论基础</p>
</blockquote>
<ul>
<li>拜占庭将军解决共识问题</li>
<li>CAP&amp;BASE理论</li>
<li>ACID&amp;2PC&amp;3PC</li>
</ul>
<blockquote>
<p>分布式协议与算法</p>
</blockquote>
<ul>
<li>Paxos算法</li>
<li>Raft算法</li>
<li>一致性hash算法</li>
<li>Gossip协议</li>
<li>Quorum NWP算法</li>
<li>PBFT算法</li>
<li>zookeeper的ZAB协议</li>
</ul>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式网络基础</title>
    <url>/2020/05/15/network/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="分布式网络基础"><a href="#分布式网络基础" class="headerlink" title="分布式网络基础"></a>分布式网络基础</h2><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/base.jpg"></p>
<p>在分布式服务化架构设计中,服务与服务之间通信均是基于网络底层协议来实现的,于是我们需要对网络相关基础知识有一个基本的认知,这样在我们服务与服务之间进行通信(跨进程通信)过程能够在我们的脑图形成一个基本的数据传输流程以及其中的细节问题,这样对于我们在进行网络问题的排查能够带来一定的帮助.现在开始展开网络基础相关知识的阐述.</p>
<h3 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h3><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><h5 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h5><p>协议是计算机与计算机之间通过网络通信时事先达成的一种“约定”,这种“约定”使那些由不同的厂商设备,不同的CPU以及不同的操作系统组成的计算机之间,只要遵循相同的协议就能够在网络传输中实现数据交互的通信.</p>
<h5 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h5><blockquote>
<p>分组交换</p>
</blockquote>
<p>在网络传输过程中,如果传输的数据块很大,则需要将其切成多个以包为单位的数据块进行传输,而这种将数据分装为一个个以包为单元的数据块称为分组.</p>
<blockquote>
<p>网络数据包</p>
</blockquote>
<p>数据包(报文)由控制信息(称为报文首部抑或是header)以及用户数据(也称为有效负载payload),控制信息包含有效负载的传输信息,即数据包的源IP地址/目标IP地址/分组之后的序号以便于在接收端的目标IP机器能够根据序号进行拼接组成一个与源数据包一致的数据块.</p>
<p>一个完整的数据包组成的结构如下:</p>
<ul>
<li>网络数据包的路由地址:包含发送数据包的源地址以及接收数据包的目标地址</li>
<li>错误检测与纠正: 在网络协议中执行错误检测与纠正,为避免在传输过程中发生错误,需要在网络数据包进行数据校验,奇偶检验位或者循环冗余校验.</li>
<li>跳数限制:主要是作用是告诉网络路由器数据包在网络中的时间是否超过了TTL设定的一个时间段,如果超过将会被丢弃并向发送端发起一个数据丢弃的一个报文由发送端决定是否进行重发.由于每个路由器都至少要把TTL域减一,TTL通常表示包在被丢弃前最多能经过的路由器个数.当记数到0时,路由器决定丢弃该包,并发送一个ICMP报文给最初的发送者.</li>
<li>数据包的长度</li>
<li>处理数据包的优先级</li>
<li>有效的负载,即数据包实际的数据,除了当前的结构,上述的字段信息可以在header中声明和定义.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/network_protocol.jpg"></p>
<blockquote>
<p>分组交换协议</p>
</blockquote>
<p>为了保证发送端与接收端能够正确进行通信,分组的两端必须保持报文首部和内容保持一致的约定,即房租交换协议.</p>
<h4 id="协议栈与网络分层模型"><a href="#协议栈与网络分层模型" class="headerlink" title="协议栈与网络分层模型"></a>协议栈与网络分层模型</h4><h5 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h5><blockquote>
<p>协议栈(网络堆栈)</p>
</blockquote>
<p>一组可以协同工作的网络协议层,定义七个协议层的OSI参考模型通常称为栈,定义Internet上的TCP/IP协议集也称为栈.术语的堆栈式指处理协议的实际软件.</p>
<ul>
<li>加载堆栈: 加载使用特定协议集所需的软件</li>
<li>绑定堆栈: 将一组网络协议链接到网络接口INC,每个INC至少绑定一个堆栈才能实现不同设备之间的数据传输.</li>
</ul>
<blockquote>
<p>IP堆栈的含义</p>
</blockquote>
<p>一般最普遍的网络堆栈的实现为一个互联网的协议栈,也称为IP栈,在操作系统中,IP栈提供了一套应用程序库,用于与远程设备建立和关闭链接以及在远程设备之间发送和接收数据,而这其中的一套应用程序库就是我们熟知的Socket API库,并且几乎所有提供IP堆栈的平台上的api都是一致的.TCP/IP栈提供了socket套接字用于接收和发送来自应用程序的请求,而应用程序具备选择TCP/UDP(UDP也有所属于自己的一套应用程序库来接收和发送数据)不同的协议来进行数据传输.于是在IP堆栈中提供UDP以及TCP两种协议并为两种协议提供相应的应用程序库,当我们应用程序选择TCP协议来进行网络通信的时候,此时就会将一套支持TCP协议的socket库加载到IP栈中,并将TCP协议绑定到我们的INC接口来实现与远程设备的数据传输.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/network_stack.jpg"></p>
<h5 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h5><blockquote>
<p>协议栈与OSI七层参考模型</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/osi.jpg"></p>
<ul>
<li>在网络分层模型中,应用层,表示层以及会话层传输数据的单位为有效负载payload(实际数据),在TCP/UDP的传输层中传输数据的单位为片段Segment,在IP(网络层)传输数据的单位为数据包package,在数据链路层传输数据的单位为帧Frames,物理层之间的数据传输以二进制0和1的bit数据流进行传输.</li>
<li>OSI参考模型每一层之间的通信都遵循特定的约定,每一层的约定对应着一套协议来负责实现该层的数据分组与组装.</li>
<li>OSI参考模型每个分层都接收由它下一层所提供的服务并负责为自己的上一层提供特定服务,上下层之间进行数据通信所遵循的约定称为接口,上下层之间通过接口来实现通信.</li>
<li>根据上述可以看出,每一个分层的协议传输的数据单位不同,同时对应的处理协议也不同,我们知道不同的协议对应着一套不同的处理程序库API,也就是OSI分层模型中的每一层对应的协议栈都会有所不同,协议栈之间通过接口来实现数据通信.</li>
</ul>
<blockquote>
<p>TCP/IP四层模型</p>
</blockquote>
<ul>
<li>摘录《图解TCP/IP协议》对OSI以及TCP/IP分层模型的对比如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_osi.jpg"></p>
<p>通过上图,我们可以很清晰地看出OSI与TCP/IP分层模型之间的联系与区分,同时每一层都对应到我们的计算机中的应用程序,操作系统和网卡硬件设备接口.</p>
<ul>
<li>关于数据传输单位的术语,这里直接摘录《图解TCP/IP协议》一书:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/desc_package.jpg"></p>
<ul>
<li>TCP/IP传输的完整数据包描述如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_package_header.jpg"></p>
<h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="TCP-IP协议传输流程"><a href="#TCP-IP协议传输流程" class="headerlink" title="TCP/IP协议传输流程"></a>TCP/IP协议传输流程</h4><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_transport.jpg"></p>
<ul>
<li>发送端将数据payload发送到应用程序中,经应用程序通过接口转发给传输的TCP/UDP协议,负责与远程设备建立连接,并在有效数据的数据包添加报文header(源端口以及目的端口号)</li>
<li>其次,传输层将上述带有端口号信息的数据报header以及payload传递给网络IP层,IP层接收到数据并在现有的数据添加IP的header,即源IP地址与目的IP地址.</li>
<li>接着,网络IP层将数据再次传递到数据链路层,此时在原有的数据报文上添加链路层的源mac地址以及目标mac地址,最后转发到物理层并将数据转换为二进制单位bit的数据流传输到接收端设备.</li>
</ul>
<h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><blockquote>
<p>三次握手</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/third_tcp.jpg"></p>
<ul>
<li>首先,客户端发起请求建立连接的SYN,同时发送初始序号(ISN)seq为x到服务端,此时客户端处于请求连接等待确认状态,SYN=1的报文不能携带数据,但是要消耗一个序号,此时客户端处于SYN_SEND状态.</li>
<li>其次,服务端接收到客户端的请求连接并给予SYN=1的响应ACK=1,并指定服务端初始的序号seq=y,并将客户端的seq+1作为应答,即ack=x+1发送到客户端.此时服务端处于SYN_RECV状态.</li>
<li>最后,客户端接收到SYN的报文并给予响应ACK,同时也对服务端的seq进行+1并给予响应,即ack=y+1,并将服务端发送的序号seq返回.此时客户端与服务端都彼此建立连接.</li>
</ul>
<blockquote>
<p>进行三次握手的原因</p>
</blockquote>
<ul>
<li>第一次握手确认客户端能够正常实现发送报文,而服务端能够正常接收报文;</li>
<li>第二次握手确认服务端能够发送报文,此时对于服务端而言,客户端能正常发送报文但是接收报文还不确定,而对于客户端而言,服务端可以正常接收和发送报文.</li>
<li>第三次客户端向服务端发送接收到报文的请求响应,此时对于服务端而言客户端已经具备接收和发送报文处理,于是客户端与服务端建立连接并开始进行通信.</li>
</ul>
<blockquote>
<p>半连接与全连接队列</p>
</blockquote>
<ul>
<li>半连接队列: 当服务端第一次接收到客户端发起的SYN报文请求时,服务端处于SYN_RECV的状态,此时服务端与客户端还没有建立完全连接,服务端将当前的状态的请求保存在一个队列中,即半连接队列</li>
<li>全连接队列: 服务端与客户端完成三次握手建立连接,此时会将已建立连接的请求报文添加到队列中,如果队列满则会出现丢包</li>
<li>丢包场景: 客户端发送SYN报文到服务端过程中超时会丢包,同理服务端向客户端发送ACK以及seq的响应超时也会丢包,同时根据上述可知,如果半连接队列或者是全连接队列满的话,也会出现丢包现象.</li>
</ul>
<blockquote>
<p>SYN攻击(DDos攻击)</p>
</blockquote>
<p>SYN攻击就是客户端在短时间内伪造大量不存在的IP地址,并向服务端不断地发送SYN报文请求,由于源IP地址不存在,于是服务为了回复确认请求的报文SYN并等待客户端的响应ACK，导致服务端需要不断重发直至超时,而这些伪造的SYN报文将长时间占用在未连接队列中,这样容易使得正常的SYN报文请求因为队列满而被丢弃,从而引起网络拥塞甚至系统瘫痪.SYN 攻击是一种典型的 DoS/DDoS 攻击.</p>
<p>一般通过以下命令进行排查:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>预防SYN攻击手段:</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><blockquote>
<p>四次挥手过程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/forth_tcp.jpg"></p>
<ul>
<li>客户端向服务端发起连接释放的FIN请求报文并消耗一个初始的序号(ISN)seq值为u,此时客户端不再向服务端发送数据,处于等待服务端FIN的响应,处于等待终止连接状态.</li>
<li>服务端接收到客户端的连接释放FIN报文请求并开始断开与服务端的连接,释放客户端持有的连接信息,在这个过程中连接释放需要等待其正常执行释放流程,于是服务端先向客户端给予响应ACK,并对于客户端发送的序号进行+1响应,即u+1,此时服务端消耗序号v并发送到客户端中.此时TCP连接释放处于半关闭状态,客户端需要等待服务端发送确认连接释放的报文FIN,此时客户端进入终止连接状态2.</li>
<li>这个时候服务端已经完成连接释放工作,向客户端发送连接释放确认请求FIN以及对先前客户端发起的FIN报文再次给予响应ACK,同时将客户端先前发起的连接关闭请求报文的序号seq+1返回到客户端中,即ack=seq+1,并重新初始化seq序号返回给客户端.</li>
<li>客户端接收到服务连接释放确认的报文,并响应给服务端ACK,同时将服务端携带的序号+1返回,同时也将携带服务端返回的序号响应ack一同返回给服务端,此时客户端TCP连接仍然未完全关闭,需要等待一段时间用于处理连接释放等收尾工作才会自动关闭,最后客户端与服务端都处于CLOSED状态.</li>
</ul>
<blockquote>
<p>进行四次挥手的原因</p>
</blockquote>
<p>主要是服务端在接收到客户端发送连接请求的报文FIN的时候,此时服务端并不能立即关闭,因为此时可能存在未处理完的网络通信,需要等待网络通信处理完成才能向客户端发送连接关闭确认报文,但是为了避免客户端不知道情况,于是就发送一个请求响应的报文段(ACK=1,seq=v,ack=u+1)告知客户端,“你的关闭连接请求报文我收到了,但是我这边连接关闭还需要等待一段时间才能关闭,晚点我再给你发一个报文确认请求”.</p>
<h4 id="滑动窗口与拥塞控制"><a href="#滑动窗口与拥塞控制" class="headerlink" title="滑动窗口与拥塞控制"></a>滑动窗口与拥塞控制</h4><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><blockquote>
<p>为什么TCP网络传输需要引入滑动窗口</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/split_window.jpg"></p>
<p>通过上述图示对比可知:</p>
<ul>
<li>在没有引入滑动窗口的时候,我们的TCP网络发送数据包的时候都是一个一个地往服务端发送数据,此时如果发送的数据包需要等待的响应ACK较长的话,那么也可以清楚地知道整个网络耗时以及吞吐量都会大大地降低,严重影响到网络的性能,于是引入滑动窗口来提升我们的网络性能,即在较短的时间且允许的数据包大小范围内发送数据包无需等待响应,此时一个是可以降低网络耗时,一个是提升网络的吞吐量,相比左边逐个发送数据包性能上有所提升.</li>
<li>关于超时重发,对于没有使用滑动窗口技术来发送数据包,如果在指定的超时时间内没有收到服务端返回的响应将会进行重复;而对于使用滑动窗口技术,由于窗口数据包都有存在顺序序号,于是客户端批量发送数据包的时候,如果接收到服务端三次响应的重复确认应答,那么客户端将会进行重发,也称为高速重发机制.</li>
</ul>
<blockquote>
<p>滑动窗口与流量控制</p>
</blockquote>
<p>为了防止服务端(或者称为接收端)接收到一个毫无关系的数据包并在当前的数据包进行耗时的处理而导致正常的数据包因处于高负载的情况被丢弃而重发消耗网络流量,于是就有了流量控制.</p>
<ul>
<li> 流量控制: TCP提供一种机制让发送端根据接收端的实际接收能力控制发送的数据量来避免无效的数据包处理导致耗时影响网络性能.</li>
<li>流量控制的窗口大小:接收端会向发送端通知自己可以接收的数据大小,于是发送端会发送不会超过这个限度的数据.该限度的大小称为窗口大小.</li>
<li>流量控制与超时: 客户端利用滑动窗口批量发送数据包,等待下一次服务端的窗口更新通知告知可以发送的数据包大小,而此时服务端接收到数据之后发现缓冲区满了,需要暂停接收数据,这个时候将会向客户端发送服务端窗口更新通知,如果此时因为超时或者更新通知数据丢包而导致无法继续通信,客户端发现过了超时时间还没有窗口更新通知,此时就会发送一个窗口探测的数据包以获取最新的窗口更新通知大小.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/flow_control.jpg"></p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>为了避免TCP一开始发送较大量的数据包而导致网络拥堵瘫痪的问题,在通信一开始时就会通过一个叫做慢启动的算法得出数值,对发送数据量的控制.</p>
<ul>
<li>拥塞窗口: 为了在发送端调节所要发送的数据的量大小,在慢启动的时候会先发送一个拥塞窗口大小为1的数据段到发送端,此后每收到一次确认应答ACK,就会窗口的值就会加1,并且在发送端进行发送数据包时,会将拥塞窗口与滑动窗口通知的大小进行比较取最小值进行发送.</li>
<li>对于重发采用超时机制,那么拥塞窗口可以设置为1之后进行慢启动修正.</li>
</ul>
<h4 id="粘包与拆包"><a href="#粘包与拆包" class="headerlink" title="粘包与拆包"></a>粘包与拆包</h4><h5 id="粘包与拆包问题分析"><a href="#粘包与拆包问题分析" class="headerlink" title="粘包与拆包问题分析"></a>粘包与拆包问题分析</h5><p>一般情况下出现粘包以及拆包现象主要是在网络传输的过程自定义协议,但是对于自定义的协议进行解析的时候存在一些换行.空格等一些特殊字符,这些特殊字符需要我们在应用层上进行手动处理来保证是一个完整的数据消息片段.</p>
<ul>
<li>正常传输</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_normal.jpg"></p>
<ul>
<li>粘包</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_zhanbao.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码表现</span></span><br><span class="line"><span class="comment">// 客户端发送数据</span></span><br><span class="line">String m1 = <span class="string">&quot;this is the first msg&quot;</span>;</span><br><span class="line">String m2 = <span class="string">&quot;this is the second msg&quot;</span>;</span><br><span class="line"></span><br><span class="line">client.send(m1);</span><br><span class="line">client.send(m2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端接收数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">  String msg = server.read();</span><br><span class="line">	log.info(<span class="string">&quot;msg=&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// msg.log</span></span><br><span class="line"><span class="comment">// msg = this is the first msgthis is the second msg</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拆包</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/tcp_chaibao.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码表现</span></span><br><span class="line"><span class="comment">// 客户端发送数据</span></span><br><span class="line">String m1 = <span class="string">&quot;this is the first msg&quot;</span>;</span><br><span class="line">String m2 = <span class="string">&quot;this is the second msg&quot;</span>;</span><br><span class="line"></span><br><span class="line">client.send(m1);</span><br><span class="line">client.send(m2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端接收数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">  String msg = server.read();</span><br><span class="line">	log.info(<span class="string">&quot;msg=&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// msg.log</span></span><br><span class="line"><span class="comment">// msg = this is the first msgthis is</span></span><br><span class="line"><span class="comment">// msg = the second msg</span></span><br></pre></td></tr></table></figure>

<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>一般需要我们进行自定义的协议,大部分都是编写框架或者是公司内部的一些基础的通用技术支持,在Java网络编程中一般底层网络利用Netty框架来帮助我们快速实现一个高性能的web服务,而Netty框架本身提供了编解码器来帮助我们解决上述的粘包与拆包问题.</p>
<ul>
<li><code>LineBasedFrameDecoder</code> 可以基于换行符解决。</li>
<li><code>DelimiterBasedFrameDecoder</code>可基于分隔符解决。</li>
<li><code>FixedLengthFrameDecoder</code>可指定长度解决</li>
</ul>
<p>后续关于Netty的编解码器再重新写一篇文章来阐述,在这里仅需知道什么是粘包与拆包即可.</p>
<h3 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a>HTTP/HTTPS协议</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><blockquote>
<p>http简要概述</p>
</blockquote>
<ul>
<li>用于客户端与服务端之间的通信</li>
<li>通过发起请求以及请求响应完成客户端与服务端之间的通信</li>
<li>http协议是不保存状态的协议,即无状态协议,保存状态是通过cookie与session协同完成</li>
<li>通过请求的uri定位到远程资源</li>
<li>具备告知服务器端具体的意图行为,比如doGET/doPOST/doPUT/doDELETE/doPATCH等操作</li>
<li>http协议是属于短连接的方式,但是可以通过“keep-alive”来持久连接,主要是为了减少每次建立连接都要进行三次握手以及退出连接进行四次挥手的过程.</li>
<li>使用管线化技术来避免每次连接都需要等待连接的响应,类似于滑动窗口原理,可以同一个时间点发起http的请求.</li>
</ul>
<p>最后,关于上述的描述,摘录《图解HTTP》截图说明:</p>
<p>http方法明细如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/http_method.jpg"></p>
<p>http的持久连接明细如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/http_chijiuhua.jpg"></p>
<p>http管线化(pipeline)如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/http_pipeline.jpg"></p>
<blockquote>
<p>http报文说明</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/http_header.jpg"></p>
<ul>
<li>HTTP请求体结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v https://www.baidu.com</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1                            ### 请求行(请求方法 + http协议版本)</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP响应体结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -i https://www.baidu.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK														### 状态行(http协议版本 + 状态码)</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2443</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Thu, 21 May 2020 06:57:08 GMT</span><br><span class="line">Etag: &quot;58860402-98b&quot;</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:24:18 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; .... &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>http常用头字段说明</p>
</blockquote>
<ul>
<li>通用的部分首部字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Cache-Control: 控制缓存行为</span></span><br><span class="line"><span class="comment">## Pragma: 报文指令</span></span><br><span class="line"><span class="comment">## Transfer-Encoding: 指定报文主体的传输编码方式</span></span><br><span class="line"><span class="comment">## Via: 代理服务器信息</span></span><br><span class="line"><span class="comment">## Warning: 错误通知</span></span><br></pre></td></tr></table></figure>

<ul>
<li>部分请求首部的字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Accept: 通知服务器用户代理可处理的媒体类型以及媒体类型的相对优先级</span></span><br><span class="line"><span class="comment">## Accept-Charset: 用户代理可处理的字符集,用q表示优先级</span></span><br><span class="line"><span class="comment">## Accept-Encoding: 用户代理可以处理的内容编码,如gzip等</span></span><br><span class="line"><span class="comment">## Authorization: 用户代理需要进行认证授权信息</span></span><br><span class="line"><span class="comment">## Referer: 告知服务器请求资源的原始uri</span></span><br></pre></td></tr></table></figure>

<ul>
<li>部分响应首部的字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Location: 响应状态码返回302的时候会携带Location的uri</span></span><br><span class="line"><span class="comment">## WWW-Authorization: 但客户端发起请求的授权认证不对的时候服务端会返回401并携带此响应信息指定认证方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实体使用的首部字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Allow: 允许使用的http方法</span></span><br><span class="line"><span class="comment">## Content-Length: 实体主体部分的大小</span></span><br><span class="line"><span class="comment">## Content-Range: 数据太太,分组发送,告知当前数据发送的字节大小资源情况</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缓存使用的字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 缓存控制,Cache-Control 与 Pragma</span></span><br><span class="line"><span class="comment">## Cache-Control: no-store  没有缓存</span></span><br><span class="line"><span class="comment">## Cache-Control: no-cache  缓存但重新验证,有缓存但未过期,响应返回304</span></span><br><span class="line"><span class="comment">## Cache-Control: private | public    缓存默认私有/公有(中间代理、CDN等代理中间件缓存)</span></span><br><span class="line"><span class="comment">## Cache-Control: max-age=31536000  | must-revalidate   缓存过期与验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Pragma,与Cache-Control: no-cache定义一致,但是定义Pragma以向后兼容基于HTTP/1.0的客户端,不能拿来完全替代HTTP/1.1中定义的Cache-control头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 缓存失效时间计算公式: expirationTime = responseTime + freshnessLifetime - currentAge</span></span><br><span class="line"><span class="comment">## 可以查看头部信息的Cache-Control: max-age=N | expires | Last-Modified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 缓存验证</span></span><br><span class="line"><span class="comment">## ETags:作为缓存的一种强校验器，ETag响应头是一个对用户代理(User Agent,即UA)不透明,如果资源请求的响应头里含有ETag,客户端可以在后续的请求的头中带上If-None-Match头来验证缓存</span></span><br><span class="line"><span class="comment">## Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存</span></span><br><span class="line"><span class="comment">## 当向服务端发起缓存校验的请求时，服务端会返回 200 ok表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Vary响应</span></span><br><span class="line"><span class="comment">## Vary: User-Agent,缓存服务器需要通过UA判断是否使用缓存的页面.如果需要区分移动端和桌面端的展示内容,利用这种方式就能避免在不同的终端展示错误的布局</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他首部字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## X-FRAME-OPTIONS: 在html使用iframe标签的时候,是否允许跨域访问,有DENY/SAMEORIGN/ALL</span></span><br><span class="line"><span class="comment">## X-XSS-Protection: 针对跨站脚本攻击的防护机制开关,0 - XSS过滤设置无效, 1 - 设置为有效</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>http常用的状态码说明</p>
</blockquote>
<ul>
<li>状态码的类别如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/http_status.jpg"></p>
<ul>
<li>2XX:返回响应成功,204表示没有资源返回但响应正常,206表示请求部分资源</li>
<li>301: 资源的uri已经被更新,告知客户端请求资源uri需要进行更新,以后使用新的资源uri进行访问</li>
<li>302: 资源的uri被临时更新,告知客户端当前请求资源的uri需要临时更新,但是之后仍然会使用旧的资源uri.</li>
<li>304: 表示缓存,告知客户端直接使用缓存响应即可.</li>
<li>400: 客户端请求报文存在问题</li>
<li>401: 表示需要客户端请求资源的时候发起认证</li>
<li>403: 没有权限访问,就是不让客户端访问资源,不需要给出理由</li>
<li>404: 服务端没有资源</li>
<li>500: 服务端本身处理程序出现问题</li>
<li>503: 表示服务端的负载过大或者是停机维护,请稍后再试.</li>
</ul>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><ul>
<li>http与https区分</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/https_http.jpg"></p>
<p>https协议是在http的基础上增加一层SSL/TLS协议,也就是HTTP部分接口使用SSL/TLS协议来代替进行密文加密传输数据.</p>
<ul>
<li>https执行流程原理</li>
</ul>
<p>https采用非对称的公开密钥加密和对称加密的共享加密并用的混合加密机制,同时为了保证公开的密钥是可信任的,于是需要第三方的认证机构颁发证书来完成公开密钥的认证.具体的https加密执行流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/network/https.jpg"></p>
<ul>
<li>https发起一个请求的时候,底层仍然是以TCP与远程建立连接,需要经过三次握手,此时客户端发起请求的时候,会携带以下信息: TLS/SSL协议版本 + client.random加密的对话密钥 + 加密算法 + sessionId(用于保持会话连接)</li>
<li>其次,服务端接收到信息的时候,确认SSL/TLS的版本号,会接收到客户端的加密算法,并同样生成一个对话密钥(server.random)并携带证书信息返回给客户端. </li>
<li>客户端接收到服务端的证书信息的时候,使用第三方机构进行证书的验证,一般是根据证书管理路径/是否有效等进行验证,然后验证成功之后,将随机生成一个pre master secret,然后利用上述建立会话的基础,以client.random + server.random + pre master secret进行对称加密生成摘要,再利用证书的公钥进行加密,接着再将握手消息进行hash,利用协商好的对话密钥pre master secret进行加密(握手信息 + 握手消息的hash)发送到服务端.</li>
<li>服务端接收sessionToken的时候需要用私钥进行解密然后再利用对称加密算法进行摘要解密得到随机对话密钥,然后再将握手消息进行解密,得到握手信息,对握手消息进行hash与传输过来的hash进行验证,验证通过之后,将使用pre master secret进行加密部分握手消息传递的客户端</li>
<li>客户端使用对话密钥进行解密,验证与服务端传递的hash是否一致,如果一致握手协议至此完成,接下来所有的通信数据将由之前交互过程中生成的 pre master secret / client.random/server.random 通过随机密钥的算法得出 session Key,作为后续交互过程中的对称密钥.</li>
</ul>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>paxos算法</title>
    <url>/2020/07/04/paxos/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/title.jpg"></p>
<p>在讲述分布式的一致性之前,先对基本的分布式协议算法有一个初步的认知,其实再分析分布式环境常见问题,最后再回到一致性问题来进行阐述.本文主要讲述分布式共识算法之Paxos算法,分别从朴素的算法说明,流程原理以及最终实现的原理逐一展开阐述说明.最后说明一点,在这里不会去花时间证明Paxos算法,有兴趣可以查看Lamport的Paxos论文证明实现.</p>
<h4 id="朴素的Paxos算法简述"><a href="#朴素的Paxos算法简述" class="headerlink" title="朴素的Paxos算法简述"></a>朴素的Paxos算法简述</h4><h5 id="共识问题描述"><a href="#共识问题描述" class="headerlink" title="共识问题描述"></a>共识问题描述</h5><p>假设现在有三个服务节点能够进行提案操作,那么Paxos的共识算法就是确保上述服务节点之一的提案数据值能够被选中,也就是说达成共识的安全要求需满足以下三个条件:</p>
<ul>
<li>只有被提案的数据值才具备被选中的资格</li>
<li>最终仅有一个提案值能够被选中</li>
<li>除非提案的数据值最终被选中，否则进程将无法学习到该提案的数据值</li>
</ul>
<p>考虑三个服务节点都是属于独立部署且需要通过网络进行异步消息通讯,此时建立起一个异步通信且非拜占庭将军问题模型如下:</p>
<ul>
<li>服务节点以任意的运作速度运行,除非出现宕机或者是重启,如果在服务节点发生故障之前选择一个提案数据值能够持久化到可靠的存储系统中,那么当服务节点重启恢复的时候就能够将故障之前的提案数据值进行恢复,否则不存在解决方案.</li>
<li>服务节点之间可以花费任意长的时间进行通信,可以复制,也可以丢失但是不能被破坏.</li>
</ul>
<h5 id="Paxos参与的角色"><a href="#Paxos参与的角色" class="headerlink" title="Paxos参与的角色"></a>Paxos参与的角色</h5><ul>
<li>提案者（proposers）:负责发起一个提案值的写入操作,其中包含有序自增长的提案编号以及提案值数据值v.</li>
<li>接收者（acceptors）:负责接收提案者的写入操作,通过共识算法来实现选择最终的提案数据值v,并将最终选中的提案值写入到学习者,写入学习者节点后的数据将不能发生变更.</li>
<li>学习者（learner）:存储接收者达成共识的提案数据值,仅作为最终数据的存储并为其他学习者提供学习最新选中的数据值v.</li>
</ul>
<h5 id="如何确定值"><a href="#如何确定值" class="headerlink" title="如何确定值"></a>如何确定值</h5><blockquote>
<p>准备阶段</p>
</blockquote>
<p>基于上述的异步非拜占庭模型基础上,在保证服务节点正常运作以及消息不丢失的情况,Paxos算法确定一个值需要满足以下条件:</p>
<ul>
<li>接受者必须接收第一个发起提议的请求.</li>
<li>如果选择了一个值为v的提议请求,那么每一个被选择的更高编号的提议者都存在提案值为v,即如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 如果选择一个值为v的提议请求，则被任意一个接收者所接收的每一个较高编号的提议者都存在提议值v.</span><br><span class="line">2) 如果选择一个值为v的提议请求，那么任何提议者发出的每一个高编号的提案都存在提议值为v.</span><br><span class="line">3) 对于任意的数据v和n,这个时候向接收者服务集群现在发起一个提议数据(携带编号以及数据值)[n,v],这个时候集群中的接收者服务节点将会出现两种情况:一是丢弃编号小于n的提议请求;二是接收的数据值v为小于n的最高编号的提议服务节点.</span><br></pre></td></tr></table></figure>

<p>基于上述的分析,我们可以梳理并总结提议者向接收者发起提议请求(n,v)之后响应返回的算法如下:</p>
<ul>
<li>接收者接收到提议请求(n,v)并承诺不再接收小于n的编号提议请求,如果之前没有提议过将直接返回;如果已经提议过但还没确定那么直接丢弃小于编号n的提议请求;</li>
<li>接收者接收到提议请求(n,v)时,发现已经选择并确定一个数据值为v’,那么这个时候将选择v’小于n的最高编号n’作为新的响应数据并携带确定的数据v’到提议者.</li>
</ul>
<p>上述的操作阶段称为prepare准备阶段.</p>
<blockquote>
<p>接收阶段</p>
</blockquote>
<p>基于上述准备阶段算法,此时接收阶段算法处理如下:</p>
<ul>
<li>对于提议者而言,其接收到准备阶段响应的请求,这个时候会有两种情况:一个是返回的响应为准备阶段发起的编号n表示当前携带提议编号n以及v可以正常发起一个接收请求到接收服务节点;一个是返回的响应为接收服务节点携带小于编号的最高编号n’以及对应确定的值v’,这个是提议者将当前最大的编号n以及对应确定的值v’向接收服务节点发起接收请求.</li>
<li>对于接收服务节点而言,如果还没有响应一个编号大于n的提议请求,那么将会接收[n,v]或者是[n, v’]的请求提议并将数据持久化到学习者服务节点中.</li>
</ul>
<h5 id="对齐-learn-策略"><a href="#对齐-learn-策略" class="headerlink" title="对齐(learn)策略"></a>对齐(learn)策略</h5><p>首先,我们先考虑以下几个方面:</p>
<ul>
<li>接收者服务节点面临多个提议服务请求操作,那么如何保证确定值的数据安全.(一旦确定并写入,后续将不能进行更改)</li>
<li>对于提议者而言,如何保证提议者节点发起的提议编号是大于确定值的最高编号.</li>
</ul>
<p>通过上述问题,我们可以反推思考,当接收服务节点确定值之后将数据更新到leaner节点,那么后续的提议操作都可以通过leaner节点获取最终确定值以及对应的最高编号以保证接收服务节点;其次对于提议者服务节点而言,当向接收服务节点发起提议请求的时候,提议者也可以通过learner服务节点获取确定值的最高编号再次发起提议请求操作,这样避免多次无效的请求操作被丢弃.</p>
<h4 id="Baisc-Paxos算法"><a href="#Baisc-Paxos算法" class="headerlink" title="Baisc-Paxos算法"></a>Baisc-Paxos算法</h4><p>假设服务集群中有三个提议者节点clientA,clientB以及clientC,同时对应着接收者节点acceptorA,acceptorB以及acceptorC,以及leaner服务节点leaner</p>
<h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>主要是描述的是多节点之间如何就某个值（提案 Value）达成共识,换而言之就是单个数据值在集群服务节点中达成共识.</p>
<blockquote>
<p>准备阶段 - 发起提议请求</p>
</blockquote>
<p>提案者节点A向接收节点A,B,C分别发起编号为[1, ]的准备请求,如下所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic01.jpg"></p>
<ul>
<li>提议者是如何确定当前的编号值?</li>
</ul>
<p>根据上述确定值的算法方案,提议者发起的编号为整数且具备单调递增的特性,于是我们需要将每个提议者发起的提案编号进行记录并存储起来,于是需要有一张本地变量表来存储提议者每次发起提议的编号,当重新发起提议的时候将按照单调性自增长产生对应的提议编号.</p>
<ul>
<li>不同的提议者节点如何避免提议编号的冲突?</li>
</ul>
<p>在上述提议者节点A发起提议编号为[1, ]准备请求,那么如果提议者B或者C节点也发起提议编号为[1, ]的时候,要如何避免编号冲突?首先,在分析提议编号冲突之前,我们先分析下如果提议者节点B以及C节点同时发起提议编号均为[1, ]准备请求,那么这个时候对于接收者的服务节点,我们根据上述确定一个值的策略,这个时候三个节点提议相同的编号最有可能给予的响应都是成功,如果响应为成功,那么会出现三种情况,一种是都提议相同的最终值v,一种至少有半数节点提议相同值v,那么可以通过半数投票进行确定,一种是提议节点发起数据值v的请求写入是混乱无序的,这个时候对于接收者服务节点是无法进行选择的.对于Paxos共识算法而言,为了避免上述的问题,将采取提议编号自增长的策略,那么提议者节点从哪里获取当前的编号为整个集群服务更高的编号呢?在Paxos算法中,存在这样的一个learn角色,我们可以将我们每个提议者节点获取提议编号的时候更新到我们的learner节点服务来维护我们集群服务提议者编号数据,保持提议者编号的单调性,这样每个提议者节点就可以从learn节点获取一份更高的编号发起准备请求.即</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic02.jpg"></p>
<p>这个时候提议者节点A以及B节点分别从learner学习者服务节点获取更高的编号并记录下来,然后向接收者服务节点分别发起编号为[1,]以及[2,]的准备请求.</p>
<blockquote>
<p>准备阶段 - 接收响应请求</p>
</blockquote>
<p>接收者服务节点A,B,C分别接收到提议者A以及B节点的服务请求,这个时候接收者A以及B先后接收到提议者A,B的准备请求,也就是说acceptorA以及acceptorB先接收到准备请求携带的提议编号[1, ],根据上述确定值的策略,接收者节点A以及B此时并没有确认提案,于是将返回一个“尚无其他提议”请求的响应给到提议者节点A以及B.同时承诺只能接收大于编号为1的提案请求.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic03.jpg"></p>
<p>这个时候提议者节点A接收到acceptorA以及acceptorB节点尚无其他提议的响应,于是准备向接收者服务节点发起确认提交的请求.同样地,对于提议者节点B发起准备请求[2,]的时候,也接收者服务A以及B节点并没有确认提案,于是也向提议者A以及B节点发起尚无提案的响应请求,同时承诺只能接收大于编号为2的提案请求.即</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic04.jpg"></p>
<p>这个时候接收者节点A以及B考虑到分布式环境存在网络原因,于是对于提议者节点B发起准备请求阶段,导致接收者节点C先接收到提议者B节点的准备请求,于是对于接收者节点C而言是先接收到提议者B的准备请求[2, ],于是对于提议者A发起的准备请求[1, ]将会丢弃并承诺只能接收大于编号为2的提案请求.此时将会向提议者节点B给予响应,而对于提议者节点A的准备请求将直接丢弃并不做响应即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic05.jpg"></p>
<h5 id="接收阶段"><a href="#接收阶段" class="headerlink" title="接收阶段"></a>接收阶段</h5><blockquote>
<p>接收阶段 - 提议者作出决策</p>
</blockquote>
<p>对于提议者节点,将按照最大的提议编号作为向接收者服务节点A,B以及C发起数据值确认接收的请求.由于在上述的提议者节点之前准备阶段接收到“尚无其他提案”的请求响应,于是对于提议者节点A将会向接收者服务节点A,B,C节点发起[1, v1]的接收请求,而对于提议者节点B将会向接收者服务节点发起[2, v2]的接收请求,即</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic06.jpg"></p>
<blockquote>
<p>接收阶段 - 接收者接收提案</p>
</blockquote>
<p>根据上述选择值的策略,接收者服务节点由于在准备阶段已经承诺不再接收小于当前最高编号的提案,这个时候对于接收者服务节点A,B而言,其在准备阶段已经受理并承诺不再接收小于编号为2的提议者,于是这个时候对于接收请求[1, v1]将会直接丢弃而接收请求[2, v2].即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic07.jpg"></p>
<p>这个时候接收者将接收确定值为v2,并将最终提案值v2存储到所有的学习者learner节点服务中.</p>
<h5 id="问题补充"><a href="#问题补充" class="headerlink" title="问题补充"></a>问题补充</h5><p>当集群服务节点这个时候已经确定提案值v2并将其写入到学习者learner节点中,那么假设这个存在提议者节点C节点,这个时候再发起一个提议的请求操作[7, v7],如下所述:</p>
<ul>
<li>准备阶段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic08.jpg"></p>
<p>对于提议者服务节点而言,提议者节点从学习者节点learner获取当前最大的提案编号,假设此时为7,这个时候分别向接收者服务节点发起准备请求[7, ];</p>
<p>对于接收者服务节点而言,接收者服务节点接收到[7, ]的准备请求,此前接收者服务节点已经确认提案委[2, v2],此时7&gt;2,但是由于已经存在确认提案值[2, v2],于是向提议者服务节点发起[2, v2]的请求响应.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic09.jpg"></p>
<ul>
<li>接收阶段</li>
</ul>
<p>这个时候提议者接收到准备阶段响应的请求数据[2, v2],对于提议者节点而言此时知道当前集群服务节点已经存在确定提案值v2,于是选择最大的编号max(2, 7),并丢弃修改的提案值v7,然后向接收者服务节点发起接收请求[7, v2],即</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/basic10.jpg"></p>
<p>而对于接收者服务节点而言,此时会接收当前的请求[7, v2]并将最新的编号数据更新到学习者learner节点中,此时完成了提议者节点C的提议请求操作.</p>
<h4 id="Multi-Paxos思想实现"><a href="#Multi-Paxos思想实现" class="headerlink" title="Multi-Paxos思想实现"></a>Multi-Paxos思想实现</h4><p>主要是描述的是执行多个Basic Paxos 实例，就一系列值达成共识.换而言之就是在集群服务中一系列的数据值写入达成共识问题.</p>
<h5 id="基于leader的选举策略"><a href="#基于leader的选举策略" class="headerlink" title="基于leader的选举策略"></a>基于leader的选举策略</h5><p>实现一系列数据值的修改来达成共识,可以利用leader节点设计思路来实现Multi-Paxos思想,即在集群服务节点中选举一个主节点作为leader节点,负责接收客户端的读写操作,也就是说所有的客户端服务向leader服务节点发起写入操作的时候由leader服务节点将写入操作直接转发到接收者服务节点,而客户端发起读取操作的时候,直接由leader服务节点读取本地数据,即从宏观上看的读写流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/leader01.jpg"></p>
<p>通过上述的读写流程,我们可以思考以下几个问题:</p>
<ul>
<li>提议者为什么在这里可以只需要发起一次提议的写入请求就可以达到共识,Multi-Paxos算法是如何达到共识?</li>
</ul>
<p>首先,在上述的分布式集群服务中,对于接收者服务节点而言,它主要承担着决策主导的作用,也就是不论是哪个客户端发起的写入请求到集群服务中,都将会把写入请求转发到leader节点负责执行写入以及分发写入到acceptor节点来达到共识,我们可以对比在Basic-Paxos算法中,之所以需要有prepare阶段主要目的是为了解决多个提议者同时发起提议以及提议冲突问题.而leader节点正如前文所述负责将执行读写操作,不存在多个提议者服务,减少提议者发起请求的冲突,提升性能(因为冲突需要通过分布式加锁解决).</p>
<ul>
<li>提议者即然可以发起一次写入操作请求,那么写入的操作请求中是否还需要携带提议者编号呢?</li>
</ul>
<p>提议者是发起写入操作的时候是需要携带提议编号的.有两个方面:一个是假设没有携带提议者编号,从我们应用服务而言,我们无法感知到数据变化的版本,比如现有接收者服务节点存储的数据为v1,之后提议者B发起一个写入提议者的请求为v2,同时提议者C此时又发起一个写入请求v1,最终对于业务服务而言是看不到数据变更的,但是我们知道这份数据是发生变化的,如果存储的数据为栈或者链表等结构存储,那么有可能造成数据丢失,即“ABA”问题;另一个是可以理解为写入操作的“决策”,即这个时候如果有提议者A发起一个写入请求[4, 5]以及一个提议者B发起一个提议请求为[9, 10],假设此时接收者服务节点已经存储一份本地数据表[8, 12]的数据,那么对于提议者A此时由于编号小于现有存储的数据,于是将会把提议者A的写入操作丢弃而接收提议者B的写入操作以保证数据的正确性.因为在Basic-Paxos算法中提议编号是具备单调性.在这里Multi-Paxos算法也是建立在Basic-Paxos算法的基础上引入leader节点的思想来解决多值共识问题.</p>
<ul>
<li>引入leader节点存在的问题</li>
</ul>
<p>根据上述分析,我们很容易想到引入leader节点的时候,leader节点承担集群服务的写入操作,写入分发以及写入的响应操作,因此存在淡点故障以及写入的性能瓶颈.</p>
<ul>
<li>如何让提议者具备高可用</li>
</ul>
<p>在paxos算法中,我们知道存在三个角色,即提议者,学习者以及接收者,那么让提议者服务具备高可用特性,相信第一反应就是做成集群冗余,那么对于集群冗余而言,我们就可以考虑到故障转移以及数据恢复问题,根据上述的Paxos算法参与的角色,我们可以将提议者发起的请求记录在存储服务,其他冗余服务可以主节点服务的存储服务中学习并获取数据进行更新.即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/leader02.jpg"></p>
<p>从上面可以看到当前的leader节点服务扮演着提议者以及学习者的角色来实现一个基于Multi-Paxos的leader策略的高可用方案.</p>
<ul>
<li>如何让提议者提升性能呢?</li>
</ul>
<p>通过上述的分析,我们知道引入leader节点来执行写入操作,仍然存在单点写入的性能瓶颈,那么在分布式架构设计中要如何提升写入性能呢?单从架构设计上来看,分布式设计最重要的一个设计思想就是“分而治之”思想,同理,在这里我们要提升性能就是将写入的请求进行分流到不同的节点中,此时采取的方案可以类似于redis-cluster的集群方案,同时如果需要保证高可用的话,就可以需要分别针对单点的写入进行高可用的部署,即满足上述的高可用方案.因此,对于一个分散的写入集群可以如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/learn03.jpg"></p>
<p>这里的方案和上述高可用的方案存在一些区别,主要如下:</p>
<ul>
<li>在上述的图示中,两个leader节点都具备发起提议写入操作,但是既然存在多个提议者允许写入操作,那么就会存在提议编号冲突问题,对于冲突问题可以考虑不相交的编号集合策略来选择对应的最高编号,同时保证单调性,在上述中两个节点中简单采用奇偶正整数来划分编号并保证编号的单调性,这样就能够避免提议编号的冲突.</li>
<li>基于上述的策略,我们考虑这样的一个情况,那就是假如leader1节点发起[3, 7]的提议写入请求,leader2发起一个[4,9]的提议请求,而此时对于接收者服务节点存储的数据的最大编号为2,如果leader1节点由于网络原因导致leader2先将[4.9]提议者写入,那么当leader1发起的[3.7]请求到接收者的时候由于编号较小将会丢弃请求,这样会导致数据丢失.对于此类情况可以考虑重新发起提议请求选择更大的编号来重新执行写入操作.</li>
</ul>
<p>在实际分布式集群中,leader扮演着proposer+learner角色,而follower节点扮演着acceptor+learner角色,即leader与follower节点简要如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/learn04.jpg"></p>
<h5 id="基于状态机策略"><a href="#基于状态机策略" class="headerlink" title="基于状态机策略"></a>基于状态机策略</h5><p>通过上述的分析,对于多值数据的确定,可以考虑引入leader以及leader节点分散写入的方式来提升性能,但是对于实现有序的多值确定要如何保证呢?这个时候在分布式系统架构中会引入一个“状态机”设计,根据状态机理论,如果初始状态一致,输入的状态一致,那么最终输出的结果也将具备一致性,从而达到共识的目的,利用状态机来存储每一次提案编号以及确定的值,即实例,因此对于分布式系统架构设计引入状态机的目的就是要保证有序且一致性.现在来看下状态机服务的演变过程如下:</p>
<ul>
<li>初始状态的服务,状态机服务为单点服务,按照先来后到的顺序接收多个业务客户端发起的command命令,通过状态机服务来将客户端发起的command记录并存储起来,并记录对应command的状态机序号(保持单调性),然后由server负责处理command并将输出结果存储到状态机中,产生状态转移,最后由状态机将数据输出到客户端.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/state01.jpg"></p>
<ul>
<li>考虑到状态机服务的单点故障问题,于是引入状态机集群服务,即如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/state02.jpg"></p>
<ul>
<li>这个时候我们要思考如何保证状态机服务集群对客户端发起的command具备有序性?假设现在server1接收到command1,server2接收到command2,server3同时接收到command3以及command4,而此时command1-command4是具备按照先后次序发起请求,那么这个时候状态的转移也应当保证有序,即对应command1-command4的输出结果.那么对于server1-server3就需要达到共识目的,引入上述的Paxos的共识算法,同时每个server节点具备三个角色(proposer/acceptor/learner),也就是说每个server都能通过自身发起提议请求,同时确定一个选中的值然后传递到状态机作为输入,状态机记录提议编号以及确定值,每个server服务通过learner角色来学习获得对应的提议编号以及选择的确定值以保证服务server发起的提议编号为当前状态机最高编号从而避免冲突.即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/state03.jpg"></p>
<p>server服务之间通过learner学习并获取对应的instance实例,这里的实例可以理解为每次发起提议请求产生确定值的一次操作.server具备leaner角色,于是每个server之间可以通过学习获取到最新的实例信息.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/state04.jpg"></p>
<p>由于第一次command1落到服务集群的server1中,于是在server1中将当前确定记录为一个instance并存储到存储层中,同样command2落到集群服务server2中,由于server1已经存在一个记录,这个时候server2从server1学习到instance1信息并更新,然后再以更高的编号发起提议并确定command2的请求操作,同理server3也是从server2学习并最终发起提议以及确定值,于是我们知道在集群服务中,无论是客户端发起的请求是落地到哪个server服务中,都将会从其他节点学习到最新的instance信息并以当前确定值更高的编号发起新的一轮提议.可以看到当上述4个instance确定之后,server服务集群之一才能发起新的一轮实例提议请求.</p>
<ul>
<li>状态机服务的leader选举策略</li>
</ul>
<p>在上述我们看到如果没有leader节点服务,每次提交的command请求都会随机落到其中的某一个server中,而每一个server发起提议请求时都需要从learner服务中获取当前一个更高的编号来发起提议请求,于是产生冲突概率会增加,导致server服务都需要从其他server服务节点中进行学习并更新确定的instance以保证发起的编号是更高且没有冲突的.虽然最后可以保证共识,但是在分布式环境每次都需要从节点学习会带来额外的网络开销,影响服务的性能,于是会考虑引入leader服务节点,将上述的server服务选举出一个leader节点,由leader节点负责接收数据的提议写入操作并同步到其他server节点中.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/paxos/state-leader.jpg"></p>
<ul>
<li>状态机记录最大编号的作用</li>
</ul>
<p>状态机保存的最高编号时刻与Paxos算法实例保持同步,也就是说通过Paxos算法达成共识的最高编号以及对应的确定值最终都会作为状态机的输入,状态机输入记录的数据要与server的实例保持同步.但是如果发生机器宕机的时候,状态机可能因为写入磁盘数据失败导致回滚而造成数据丢失,在这里我们不采用fsync强制的约束写盘方式,而是通过状态机记录编号来进行重启回放,也就是服务启动的时候,状态机会和server服务的最高编号进行比较,比如现在状态机检查到的最高编号为n,而Paxos算法server的最高编号为m,且满足n &lt; m,这个时候如果存在(n, m]的确定值,那么状态机就能够从paxos服务server拉取n - m之间的编号以及对应的确定值作为状态机的输入记录,那么对外的业务集群服务仍然能够获取到确定的最高编号为m以及对应的确定值的数据,这也称为重启回放.关于状态机的实现,比如Mysql的binlog也可以理解为状态机等.</p>
<h4 id="Paxos算法参考"><a href="#Paxos算法参考" class="headerlink" title="Paxos算法参考"></a>Paxos算法参考</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&amp;mid=2247483695&amp;idx=1&amp;sn=91ea422913fc62579e020e941d1d059e#rd</span><br><span class="line">https://en.wikipedia.org/wiki/Paxos_(computer_science)#Assumptions</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft算法简述</title>
    <url>/2020/07/24/raft/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><h4 id="Raft简述"><a href="#Raft简述" class="headerlink" title="Raft简述"></a>Raft简述</h4><h5 id="Raft概要"><a href="#Raft概要" class="headerlink" title="Raft概要"></a>Raft概要</h5><p>基于Multi-Paxos算法的基础上做了一些限制与简化,Raft算法属于强一致性模型的共识算法模型,在集群服务节点中仅有一个leader节点服务来负责所有请求的写入操作.Raft算法主要解决服务节点之间的leader选举,各个服务节点之间的日志同步以及服务节点成员中leader节点服务发生宕机时如何变更来达成最终的共识问题.从本质上是属于强leader模型,一切以leader为准的方式来实现各个服务节点一系列值的共识以及节点之间日志的一致性.</p>
<h5 id="Raft算法三种状态"><a href="#Raft算法三种状态" class="headerlink" title="Raft算法三种状态"></a>Raft算法三种状态</h5><ul>
<li>Follower状态: 集群服务中普通的节点,主要职责有以下方面: 一个是负责接收和处理leader节点的消息;一个是负责维持与leader节点之间的心跳检测,以感知leader节点是处于可用状态;一个是通过心跳检测获取leader节点不可用状态时,将会推荐自己作为候选节点而发起投票选举操作.</li>
<li>Candidate状态: 此时已经感知到leader节点不可用,那么这个时候将会向集群服务节点发起RPC消息的投票请求,通知其他集群服务节点来进行投票,如果超过半数投票那么将当前服务节点晋升为leader节点.</li>
<li>Leader状态: 通过选举投票成为leader节点,此时主要的工作职责有三:一个是负责接收客户端的所有写入请求,包括集群服务节点的写入请求也将会转发到leader节点来处理;一个是同步数据日志到各个follower服务节点,以保证数据的一致性;一个是发送心跳检测以便于各个follower节点能够感知到leader节点是处于可用状态而不会发起投票选举操作.</li>
</ul>
<h5 id="Raft算法开源产品"><a href="#Raft算法开源产品" class="headerlink" title="Raft算法开源产品"></a>Raft算法开源产品</h5><ul>
<li>分布式键值对存储系统Etcd: <a href="https://etcd.io/docs/v3.4.0/">https://etcd.io/docs/v3.4.0/</a></li>
<li>基于Go语言实现的分布式注册与配置中心Consul: <a href="https://www.consul.io/docs">https://www.consul.io/docs</a></li>
<li>Raft开源产品总览: <a href="https://raft.github.io/">https://raft.github.io/</a></li>
<li>Raft学习指南: <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
</ul>
<h4 id="Raft算法解决分布式共识问题"><a href="#Raft算法解决分布式共识问题" class="headerlink" title="Raft算法解决分布式共识问题"></a>Raft算法解决分布式共识问题</h4><h5 id="单节点实现的共识问题"><a href="#单节点实现的共识问题" class="headerlink" title="单节点实现的共识问题"></a>单节点实现的共识问题</h5><p>假设现在有一个数据存储服务的节点Node用于存储key-value的键值数据,这个时候客户端向键值服务节点Node发起写操作请求,那么此时对于Node执行写请求达到的共识操作要么是成功,要么是失败,即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node.jpg"></p>
<h5 id="多节点实现共识问题"><a href="#多节点实现共识问题" class="headerlink" title="多节点实现共识问题"></a>多节点实现共识问题</h5><p>当上述的键值服务节点增加副本时,这个时候便构成分布式共识问题,即一个client发起写请求操作到键值服务集群中,那么对于键值服务集群节点需要根据客户端client发起的写请求操作来达到共识.基于上述的Raft算法理解,我们知道raft算法是属于强leader模型来达到一致性,于是需要在键值服务节点中选举leader节点作为接收client的写请求,并且将由leader节点向其他follower节点发起执行命令来达到整个服务键值节点的一致性.因此整个过程包含leader选举策略以及实现的leader集群主从节点日志复制.即从宏观上看如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/multi_node.jpg"></p>
<h5 id="Leader选举策略"><a href="#Leader选举策略" class="headerlink" title="Leader选举策略"></a>Leader选举策略</h5><ul>
<li>在初始状态下,所有的键值服务节点都属于follower节点,在Raft算法中,follower节点会存在两个核心属性,即等待leader节点心跳检测的超时时间timeout以及任期编号number(也可以理解为武侠小说里面的选举丐帮帮主的任期,意为第几任丐帮帮主).在初始状态下,键值服务集群不存在leader节点,此时任期number为0,同时为了保证集群每个follower节点都能够有机会发起投票以及避免投票冲突带来的性能问题,于是采取心跳检测的超时时间作为随机数.即如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_init.jpg"></p>
<ul>
<li>在上述可以看到,follower节点A等待超时间为三个键值服务节点最小,于是将会由follower节点A向其他服务节点发起投票RPC消息请求成为leader节点,于是这个时候follower节点A成为候选节点A,更新当前节点的任期number为1并为自己投票获得为1的选票,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_candidated.jpg"></p>
<ul>
<li>这个时候其他键值服务B和C节点接收到候选节点A发起的RPC请求投票信息,这个时候B和C节点由于还没有接收到其他投票请求,那么就会更新当前的任期编号为1,并且将投票给A服务节点给予响应,同时A服务节点在发起RPC请求投票的时候会设置一个等待选举结果的随机超时时间timeout,如果在超时时间内没有获得半数投票,那么原先的选举会失效并将会重新发起投票选举,如果未超时,A服务节点接将收到其他服务节点投票响应并为自己的选票进行相应的计算增加,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_candidated_response.jpg"></p>
<ul>
<li>此时服务节点A获得到选票为3,在Raft算法中,集群服务节点超过半数即可由候选节点升级为leader节点,于是服务A节点获取到的票数为3已超过服务集群节点的半数agreement成为leader节点.即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_elected.jpg"></p>
<ul>
<li>这个时候集群服务已经成功将服务节点A选举为leader节点,我们知道在Raft算法中,follower节点是有机会通过自身发起RPC投票消息成为leader节点的,那么当集群服务已经存在leader节点的时候,我们并不希望follower再次发起投票选举的动作,于是对于follower节点而言需要知道当前集群服务leader节点的存活情况,于是leader节点需要向follower节点周期性地发起心跳信息的检测以告知当前follower节点leader节点是可用状态,同时follower节点进行心跳检测超时时间是随机的,以避免超时发起投票选举冲突带来的网络开销性能,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_ping.jpg"></p>
<p>至此,我们完成了一个键值服务集群的leader选举过程,接下来我们来看下客户端向集群服务发起写入请求操作的处理过程.</p>
<h5 id="主从节点日志复制"><a href="#主从节点日志复制" class="headerlink" title="主从节点日志复制"></a>主从节点日志复制</h5><p>Raft实现主从日志复制其实是可以理解为实现集群服务节点对客户端client发起的写请求达成共识的问题,其主要实现是基于上述的leader选举与2PC提交协议来实现客户端client的写入操作,也就是当一个客户端client向集群服务发起一个写请求操作的时候,集群服务节点需要针对客户端的写入请求操作采取一致的变更行为.</p>
<ul>
<li>首先是客户端向键值服务集群发起一个<code>set x= 10</code>的写入请求,此时服务集群接收写请求过程,一种情况是发送的写请求直接被leader节点接收,另一种是发送的写请求到folloer节点,由follower节点转发给leader节点,如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_write_req.jpg"></p>
<ul>
<li>Leader节点接收到客户端发起的写请求操作之后,会将当前的<code>set x=10</code>指令更新到undo日志中,并向集群服务节点发起RPC日志复制更新操作,即如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_write_log.jpg"></p>
<ul>
<li>Follower节点接收到Leader节点的RPC复制日志消息请求,根据日志的任期,命令以及索引值更新到本地状态机中,并给予leader消息的响应.即如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_write_log_replicated.jpg"></p>
<ul>
<li>Leader服务节点接收到集群Follower服务节点的RPC日志复制消息的响应,此时约定一个投票规则,即超过半数节点服务返回响应为success,那么此时leader节点就可以将复制日志log的entry进行提交并告知当前leader节点已经完成复制日志的提交,此时follower节点接收到通知之后提交复制日志log的entry以与leader节点达成共识.即如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_write_commit.jpg"></p>
<ul>
<li>最后键值集群服务对客户端client的写请求<code>set x= 10</code>达成共识之后并返回成功响应给客户端.在这个过程中客户端一直等待leader节点完成写入请求,处于阻塞状态.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/leader_write_log_response.jpg"></p>
<p>至此,一个键值服务集群基于Raft算法的强Leader模型来完成客户端发起写入请求的共识问题.</p>
<h5 id="解决成员变更"><a href="#解决成员变更" class="headerlink" title="解决成员变更"></a>解决成员变更</h5><p>在上述的Raft集群模型中,只是一个正常运作的过程,如果键值集群服务节点发生扩容,那么此时将会面临集群分裂问题,即集群服务存在多个Leader节点;如果是当前的集群Leader节点发生宕机或者是产生不可用,那么此时需要从现有的集群服务剔除不可用的服务.可以看到上述两个问题均为集群服务节点发生变更的问题,那么Raft算法是如何解决成员节点变更问题呢?</p>
<blockquote>
<p>集群成员节点的变更本质 - 基于单节点变更方案</p>
</blockquote>
<p>存在两种方案: 联合共识算法以及Raft的单节点变更策略.以下是基于Raft的单节点变更策略</p>
<p>假设现在有一个基于Raft算法构成的集群服务,在上述的日志复制以及Leader选举之后,现在服务集群的节点A为Leader节点,节点B以及节点C作为Follower节点,当Raft算法服务集群发生以下缩容抑或是扩容之后,集群成员的变更情况如下</p>
<blockquote>
<p>集群服务节点Leader发生宕机导致集群服务节点成员的变更</p>
</blockquote>
<ul>
<li>基于Raft算法集群正常稳定的状态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_init.jpg"></p>
<p>通过上述工程图可知,在一个处于稳定状态的集群服务中,以服务节点C为Master节点组成的集群服务,其从节点为服务A以及服务C,此时在Master节点需要通过ping的网络心跳检测来感知集群服务中其他的Follower节点,同时我们也会看到在组成的集群服务中存在一份元数据的配置,这份元数据的配置包含集群服务状态,主从节点,机器IP以及存储数据的元数据等基础信息.</p>
<ul>
<li>此时集群服务发生宕机,假设为主服务节点C,此时集群变化如下,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_down01.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_down02.jpg"></p>
<p>从服务节点A以及B将会接收不到Master节点发出的ping心跳包,这个时候从服务节点A以及B会因为超时没有接收到心跳包甚至会根据来自集群其他集群服务节点的心跳检测来确定Master服务节点此时是处于不可用状态,那么这个时候Raft算法集群为了保证集群存在强领导服务节点的存在,重新由从服务节点发起选举,假设这个时候选举到的服务节点为A,那么当原先的Master服务节点C重新恢复的时候,这个时候集群就会出现两个Master节点,注意看到服务节点C重启之后还不属于现有的Raft集群中.</p>
<ul>
<li>根据Raft算法,集群中只能有一个Leader服务节点,那么Raft算法是如何解决崩溃恢复节点出现的“脑裂”问题.</li>
</ul>
<p>通过上述的工程图我们可以看到集群中的元数据配置发生变化,此时原先的Master服务节点的集群配置与现有状态的集群配置发生了变化,于是对于服务节点C的恢复,首先服务节点C需要向Raft集群的Master服务节点同步数据到本地,其次Master服务节点接收到服务节点C的请求并感知到有新的服务节点加入集群,于是更新上述的元数据配置,接着通过日志复制同步元数据配置到集群的其他从服务节点,即B以及C节点,最后C节点从主节点A通过日志复制得到的meta数据应用到本地的状态机,更新本地状态机存储的元数据集群配置信息,成为现有Raft集群的一个从服务节点,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_restore01.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_restore02.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/single_node_restore03.jpg"></p>
<blockquote>
<p>集群扩容产生的集群“脑裂”问题的演变</p>
</blockquote>
<p>同样地,如果在现有的Raft集群中新加入一个甚至是多个服务节点,此时集群服务也将会出现多个Master节点现象,即集群“脑裂”(如ES集群扩容容易发生的现象).</p>
<ul>
<li>首先,我们同样来看一个稳定状态的Raft集群服务,如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_init.jpg"></p>
<ul>
<li>其次,假设服务节点A,B,C节点处于一个Raft集群的稳定状态服务,可以看到此时的服务配置并没有发生变更,而服务节点D以及E属于待加入的服务节点,那么按照单节点变更的方式,服务节点D以及服务节点E加入集群满足有序性,即在现有的Raft服务集群中依次执行单节点变更的方式来变更集群服务节点,也就是说先执行服务节点D的节点变更,再执行服务节点E的变更,即要实现多个服务节点的扩容,就需要按照单节点的变更方式逐个将待加入的服务节点加入到现有的Raft算法集群中,如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_sync1.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_sync2.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_sync3.jpg"></p>
<p>可以看到Raft算法集群不论是服务扩容还是缩容在这里是基于单个节点变更为基础先进行数据同步,其次以日志复制的形式将元数据更新到集群的从服务节点中以此来达成集群只有一个Master节点的目标.</p>
<h5 id="异地区域集群问题"><a href="#异地区域集群问题" class="headerlink" title="异地区域集群问题"></a>异地区域集群问题</h5><p>假设上述所有的服务节点都具备投票选举成为Master节点的权利,那么如果此时发生异常:</p>
<ul>
<li>其一是华南与华北地区之间的网络发生抖动,造成服务节点D以及E节点与华南地区的服务节点心跳检测产生超时;</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_done_network.jpg"></p>
<p>这个时候我们发现华北地区与华南地区的服务节点网络发生分区,对于华北地区的服务节点,此时D以及E节点,此时存在两个问题,一个是与Master节点心跳检测发生超时,一致地认为Master服务节点发生不可用,其次由于与华南地区的从服务节点发生分区,但是在本区域的服务节点是互通的,即服务节点D与E,根据上述的条件可知,服务节点D以及服务节点E具备投票选举权利,于是就会在这段发生分区的期间进行Master选举,于是就会产生华北地区存在一个Master服务节点,当华南与华北区域网络恢复正常的时候,此时服务Raft集群存在两个Master节点,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_done_network_master.jpg"></p>
<ul>
<li>其二是是华南Master服务节点发生宕机,那么此时华南与华北地区就可能会在自己的地区产生一个Master节点,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_master_down.jpg"></p>
<p>从这里我们可以看到华南区域的服务节点与华北服务节点都具备投票选举成为Master节点,这个时候在理想状态下(不存在网络区域超时问题),此时服务节点A,B,D以及E节点可以通过投票选举出一个新的Master节点,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_master_down_recover.jpg"></p>
<p>那如果是在选举过程中发生区域的网络超时,那么此时华南与华北区域的服务节点会出现短暂的分区现象,这个时候华南区域与华北区域的服务节点会各自投票选举出集群服务的Master节点,即</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft/double_node_master_down_recover2.jpg"></p>
<p>通过上述的分析,跨区域服务节点在网络发生分区的情况下会出现集群的“脑裂”现象,与此同时,我们可以分析到出现脑裂的原因有两个,一个是网络发生分区,集群服务节点在短暂的时间内被迫划分成两个“集群”服务;一个是每个服务节点都具备成为Master节点的权利;于是我们可以根据上述出现的问题进行调整:一个网络超时时间的配置可以适当延长;一个是变更节点为存储数据节点,不具备选举成为Master节点,并且设置master节点个数为奇数抑或是(集群机器个数/2)+1个,同时考虑到同一个集群不同区域的机器分配问题,需要根据实际业务场景去调整,避免不同区域在同一个集群下产生双主节点,如上,可以考虑将华北区域的节点设置为数据节点,华南区域为数据节点且为具备选举Master节点的角色,如果成本允许且应用场景需要,可以考虑根据区域划分集群,同时通过冗余节点同步跨区域节点的数据.</p>
<p>至此,接下来对Raft算法进行一般性分析与总结.</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>raft算法增强与总结</title>
    <url>/2020/08/24/raft02/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/title.jpg"></p>
<h3 id="Raft简述"><a href="#Raft简述" class="headerlink" title="Raft简述"></a>Raft简述</h3><h4 id="Raft概要"><a href="#Raft概要" class="headerlink" title="Raft概要"></a>Raft概要</h4><p>Raft算法是一种用于管理Replicated Log的共识算法,其算法结果与效率与Multi-Paxos一致,但是在算法的设计结构上与Paxos算法是不同的,Raft算法更加便于理解和实现,主要有以下两点:</p>
<ul>
<li><p>Raft算法将leader选举,日志复制以及安全共识要素分离出来,并强化一致性,即强leader模型,集群服务节点以leader节点为主来实现实现一系列值的共识和各节点日志的一致,强leader这样做的目的是为了减少集群其他服务节点必须考虑的状态,换言之,就是如果集群服务存在leader节点,那么对非leader节点服务而言,我只考虑leader节点是存活的情况下,保证我自己当前服务节点状态不会发生变更.</p>
</li>
<li><p>其次,Raft算法提供成员变更机制,严格来说是引入单节点变更机制来解决集群中存在“脑裂”情况(集群出现多个leader节点)</p>
</li>
</ul>
<h4 id="Raft集群节点状态"><a href="#Raft集群节点状态" class="headerlink" title="Raft集群节点状态"></a>Raft集群节点状态</h4><ul>
<li>Follower状态: 集群服务中普通的节点,主要职责有以下方面: 一个是负责接收和处理leader节点的消息;一个是负责维持与leader节点之间的心跳检测,以感知leader节点是处于可用状态;一个是通过心跳检测获取leader节点不可用状态时,将会推荐自己作为候选节点而发起投票选举操作.</li>
<li>Candidate状态: 当前集群节点为候选leader服务节点,将会向集群其他服务节点发起RPC消息的投票请求,通知其他集群服务节点来进行投票,如果超过半数投票那么当前服务节点将晋升成为leader节点.</li>
<li>Leader状态: 通过选举投票成为leader节点,此时主要的工作职责有三:一个是负责接收客户端的所有写入请求,包括集群服务节点的写入请求也将会转发到leader节点来处理;一个是同步client的数据操作日志(binlog/oplog)到各个follower服务节点,以保证数据的一致性;一个是发送心跳检测以便于各个follower节点能够感知到leader节点是处于可用状态而不会发起投票选举操作.</li>
</ul>
<h4 id="Raft算法参考学习"><a href="#Raft算法参考学习" class="headerlink" title="Raft算法参考学习"></a>Raft算法参考学习</h4><ul>
<li>分布式键值对存储系统Etcd: <a href="https://etcd.io/docs/v3.4.0/">https://etcd.io/docs/v3.4.0/</a></li>
<li>基于Go语言实现的分布式注册与配置中心Consul: <a href="https://www.consul.io/docs">https://www.consul.io/docs</a></li>
<li>Raft开源产品总览: <a href="https://raft.github.io/">https://raft.github.io/</a></li>
<li>Raft学习指南: <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
</ul>
<h3 id="Raft算法核心原理"><a href="#Raft算法核心原理" class="headerlink" title="Raft算法核心原理"></a>Raft算法核心原理</h3><h4 id="集群强Leader选举"><a href="#集群强Leader选举" class="headerlink" title="集群强Leader选举"></a>集群强Leader选举</h4><h5 id="leader选举要素"><a href="#leader选举要素" class="headerlink" title="leader选举要素"></a>leader选举要素</h5><ul>
<li>任期Term: leader选举存在任期Term,每次完成leader选举会更新一次任期Term</li>
<li>超时Timeout: 具备两种含义,即包含leader心跳检测超时以及候选节点等待选举结果超时</li>
</ul>
<h5 id="leader选举过程"><a href="#leader选举过程" class="headerlink" title="leader选举过程"></a>leader选举过程</h5><ul>
<li>初始化状态</li>
</ul>
<p>所有的键值服务节点都属于follower节点,在Raft算法中,follower节点会存在两个核心属性,即等待leader节点心跳检测的超时时间timeout以及任期编号term.在初始状态下,键值服务集群不存在leader节点,此时任期term为0,同时为了保证集群每个follower节点都能够有机会发起投票以及避免投票冲突带来的性能问题,于是采取心跳检测的超时时间作为随机数.即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_init.jpg"></p>
<ul>
<li>投票请求</li>
</ul>
<p>在上述集群的初始状态中,我们可以看到followerA节点等待leader节点的ping心跳率先超时,于是followerA节点成为候选节点Candidate,同时默认为自己的任期term进行+1的投票,此时节点A会更新当前的任期编号term为1(初始状态为0),接着再向集群服务节点B以及C发起RPC投票请求,即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote_req.jpg"></p>
<ul>
<li>投票请求响应</li>
</ul>
<p>当候选服务节点A发起RPC投票请求的时候,会在当前的服务节点设置一个等待选举结果的随机超时时间timeout,那么存在两种情况:</p>
<ol>
<li>如果是在timeout时间内,集群的服务节点B以及C接收到候选节点A的RPC投票请求并且此时还没有接收到其他服务节点的投票请求,那么就会更新当前的任期编号为1,同时将投票给A服务节点并给予响应,即:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote_resp_success.jpg"></p>
<ol start="2">
<li>如果在超时时间内没有获得半数投票,那么原先的选举会失效并将会重新发起投票选举,如果未超时,A服务节点接将收到其他服务节点投票响应并为自己的选票进行相应的计算增加,即:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote_resp_fail.jpg"></p>
<ul>
<li>A节点获得半数投票成为leader节点</li>
</ul>
<p>当候选节点A在超时的时间内获得到集群半数以上的节点给予的投票响应,于是会晋升成为leader节点,并周期性地向follower节点发起类似ping的心跳响应,并在当前任期内维持ping心跳检测的超时时间timeout,即如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote_result.jpg"></p>
<h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><h5 id="日志项Log-Entry"><a href="#日志项Log-Entry" class="headerlink" title="日志项Log Entry"></a>日志项Log Entry</h5><blockquote>
<p>日志项属性</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_entry.jpg"></p>
<p>由上图可知,日志实体(log Entry)主要包含以下几个属性:</p>
<ul>
<li><p>日志执行指令(cmd):客户端服务发起事务请求操作并通过leader服务节点的共识模块输出的一条持久化到leader服务节点所在的状态机上的指令.</p>
</li>
<li><p>日志索引值(logIndex): 日志项对应的整数索引值,用来标识日志项的,是一个连续的、单调递增的整数号码,并且当前的日志项(logEntry)不会改变其在日志(log)下的位置</p>
</li>
<li><p>日志任期编号(term): 创建当前日志项(logEntry)的leader节点当前所处的任期编号term,主要来保证appendEnrty到日志log的一致性检查.</p>
</li>
</ul>
<h5 id="日志项复制原理"><a href="#日志项复制原理" class="headerlink" title="日志项复制原理"></a>日志项复制原理</h5><p>Raft算法的日志复制是基于优化之后的2PC(减少一半的消息往返)提交来实现客户端事务操作的共识与数据的一致性,其具体过程如下:</p>
<ul>
<li>客户端服务client service向Raft集群服务发起事务请求操作,将转发由Raft集群的leader节点进行事务请求的写入以此来保证Raft集群服务的共识问题,假设客户端服务发起写请求操作<code>set x=10</code>,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_write_req.jpg"></p>
<ul>
<li>leader节点接收到事务请求操作,将请求提交给leader节点服务下的共识模块进行事务操作并输出cmd指令以RPC的方式进行AppendEntries(复制日志项)到其他服务节点中,即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_rpc_append_entry.jpg"></p>
<ul>
<li>当follower节点将接收到leader节点RPC的appendEntries(日志复制)进行持久化后,将会返回给leader节点,而leader节点如果接收到大多数follower节点的RPC日志复制成功的响应,那么就会将当前的log应用到leader节点的状态机并给予客户端的响应.即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_rpc_append_entry_res.jpg"></p>
<ul>
<li>这个时候leader节点如果有新的RPC日志项复制抑或是发起heartbeat心跳检测,<code>RPC-AppendEntries&amp;Heartbeat</code>会携带当前最大的且即将提交的<code>index</code>到follower节点,follower节点会进行一致性检查流程并将日志项提交到本地状态机以保证与leader节点的日志数据一致.即:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_rpc_append_entry_res_updated.jpg"></p>
<ul>
<li>整个RPC日志复制流程如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_rpc_append_entry_final.jpg"></p>
<p>最后,关于Raft算法的日志复制,可以类比数据库的主从复制架构来思考,上述的提交日志可以理解为binlog或者是oplog,那么每次发起的RPC日志复制抑或是心跳检测都会携带日志最大且即将提交的索引值index,通过binlog或者是oplog将数据更新到节点的状态机上.</p>
<h5 id="日志的一致性检测"><a href="#日志的一致性检测" class="headerlink" title="日志的一致性检测"></a>日志的一致性检测</h5><blockquote>
<p>一致性检测原理</p>
</blockquote>
<p>假设当前Raft服务集群节点的log以及对应的logEntry如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_consistence_init.jpg"></p>
<p>在上述图中,我们看到leader节点与follower节点的日志数据存在不一致,我们知道Raft算法是属于强leader模型,一切以“leader”为主,因此日志复制也不例外,一旦出现不一致,那么follower节点会进行一致性检查并以leader发送的RPC日志为主将不一致性的数据强制更新为与leader节点日志一致,而对于leader节点的日志是不会覆盖和删除自己的日志记录.也就是说对于raft算法的一致性检查原理主要包含以下步骤:</p>
<ul>
<li>leader节点通过RPC日志复制的一致性检查,查找与follower节点上与自己相同的日志项最大的索引值,这个时候follower节点的索引值之前的日志记录与leader是保持一致的,而之后的日志将产生不一致.</li>
<li>leader节点找到与follower节点相同的索引值并将索引值之后的日志记录复制并通过RPC发送到follower节点,强制follower节点更新日志数据不一致的记录.</li>
</ul>
<blockquote>
<p>一致性检查流程</p>
</blockquote>
<p>以上面的日志记录为例,leader节点当前的索引值为8,而follower节点A与follower节点B索引值分别为5和8,这个时候假设leader节点向集群follower节点通过RPC发送新的日志记录抑或是心跳消息.此时follower节点A与B将会进行一致性检查.</p>
<ul>
<li>若为RPC复制新的日志项,其检查流程如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_consistence_req.jpg"></p>
<ul>
<li>若为心跳检测,其检查流程如下:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_consistence_req_heartbeat.jpg"></p>
<p>上述不论是发送RPC复制日志项还是心跳消息,在follower节点B以及C中由于日志属性不匹配抑或是日志项不存在而被拒绝当前<code>index=9</code>或者<code>index=8</code>的日志项更新,于是对于leader节点将向后递减重新发送新的RPC复制日志到follower节点,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/log_consistence_res.jpg"></p>
<p>至此,在有限的时间内leader节点会将其日志复制到follower节点来保证整个Raft集群的日志数据一致性.</p>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li><p>leader节点通过日志复制RPC消息,将当前最新且uncommited的日志索引值发送到Raft集群的follower节点上,假设此时的消息索引值<code>index=rpcIndex</code></p>
</li>
<li><p>Raft集群的follower节点接收到日志复制的RPC消息,会检查上一个日志索引值preIndex(index=rpcIndex-1)对应的日志项entry中的index,term以及cmd的属性是否匹配,如果不匹配则会拒绝当前index(rpcIndex)的entry更新并返回失败消息给leader节点,如果成功则持久化当前日志项并返回成功消息给leader节点(一致性检查).</p>
</li>
<li><p>leader节点接收到follower节点的失败消息,于是递减当前的index`(rpcIndex-1),再次发起新的日志RPC复制消息到follower节点上</p>
</li>
<li><p>这个时候follower再次进行一致性检查,如果匹配那么返回成功给leader节点,此时leader节点就会知道当前follower节点的数据索引值(rpcIndex-2)与leader节点的日志是一致的.</p>
</li>
<li><p>最后leader几点再次发起日志复制的RPC请求,复制并更新该索引值(rpcIndex-2)之后的日志项,最终实现leader节点与follower节点的日志一致性.</p>
</li>
</ul>
<h4 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h4><h5 id="集群成员变更问题"><a href="#集群成员变更问题" class="headerlink" title="集群成员变更问题"></a>集群成员变更问题</h5><ul>
<li>集群中leader节点崩溃与恢复</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_cluster_down.jpg"></p>
<p>从上面我们可以看到在一个Raft集群服务中,如果leader节点发生不可用,那么剩下的follower节点将会重新进行选举,假设此时选举B作为leader节点,那么当原有的leader节点恢复正常的时候,此时集群存在两个“leader”节点,如何解决?</p>
<ul>
<li>集群扩容</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_clutser_extend.jpg"></p>
<p>从上述可以看到,在实现集群服务节点的扩容时,如果新加入的服务节点刚好碰上原有的集群服务发生网络分区,导致C与B,A节点失去联系,而在C节点恢复的时候与刚加入的服务节点D&amp;E组成一个新的Raft集群(D&amp;E与原有的服务节点属于同一个区域内);其次如果是新加入的两个节点与原有的服务节点不属在同一个区域,那么当前raft集群扩容就存在跨区域的集群,跨区域必然会存在网络不可靠的因素,因此一旦两个区域发生网络分区错误,那此时新区域下的D&amp;E以及原有的区域集群节点分别组成了一个Raft集群,此时就会面临双leader节点问题.</p>
<p>从上述的问题分析中,我们都看到集群服务可能出现多个leader节点,这就违背了Raft算法的强leader且唯一性的特征,而对于Raft算法解决这类集群成员节点变更则是通过单节点变更来解决集群的“脑裂”问题.</p>
<h5 id="单节点解决成员变更"><a href="#单节点解决成员变更" class="headerlink" title="单节点解决成员变更"></a>单节点解决成员变更</h5><p>在Raft算法的论文中关于集群成员节点的变更存在着一个集群的配置属性,即在了解单节点变更方式之前,我们需要对集群cluster的配置有一个基本的认知(与ES集群相似)</p>
<blockquote>
<p>集群配置</p>
</blockquote>
<p>在一个稳定的Raft集群服务中,存在着以下的一个leader以及两个follower节点,follower节点的配置需要从leader节点同步进行更新,于是在这里我们关注leader节点的配置即可,也就是整个集群的一份配置.对于ES集群而言,其配置信息如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_cluster_configuration.jpg"></p>
<p>上述的log/clusterName/nodes等信息组成一个集群的配置信息,也就是说Raft 算法要解决上述多leader节点的问题,其实是保障在集群配置变更时,集群能稳定运行,不会同时出现多个leader节点的集群配置.</p>
<blockquote>
<p>引入集群配置的目的</p>
</blockquote>
<ul>
<li>其一,我们可以想到的方案是停更集群服务的执行,更改集群的配置再重启生效,但是显然在当前互联网应用中是不允许也是不被采纳的,极大影响用户体验,容易造成用户流失;</li>
<li>其二是重启集群服务的步骤存在着误操作步骤,容易导致上线服务时出现不可预知的错误.</li>
</ul>
<p>因此Raft算法利用单节点变更的方式来实现自动化的配置更新以保证我们集群服务的强一致性.</p>
<blockquote>
<p>单节点变更原理</p>
</blockquote>
<ul>
<li>假设现有的Raft集群服务配置为C[n1,n2,…],此时服务集群加入一个节点Xm,同时对应的配置nm,这个时候leader节点监听到有新的节点加入读取节点配置nm并更新到当前的leader配置C中,设新配置为C1,即[n1,n2,…nm],并向新节点同步数据log.</li>
<li>其次leader节点更新配置之后C1并发起日志复制的RPC请求消息到集群服务的各个节点,集群服务节点接收到RPC消息请求并将新的配置应用到本地状态机中,至此完成了单节点变更.</li>
</ul>
<blockquote>
<p>单节点如何解决成员变更</p>
</blockquote>
<ul>
<li>崩溃恢复过程</li>
</ul>
<ol>
<li>Raft集群的leader节点发生不可用,原先具备leader选举权的follower节点进行leader选举,最终节点B成为新一轮的leader,即如下:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_1.jpg"></p>
<p>此时集群的配置由[A,B,C]变更为[B,C],同时配置中的部分属性数据也会发生变更,比如任期term以及log数据</p>
<ol start="2">
<li>这个时候如果A节点恢复并重新加入到现有的Raft集群中,那么利用单节点原理,leaderB更新配置并将log同步覆盖更新节点A,此时A节点自然作为follower节点,最后leader节点B通过日志复制的RPC向集群服务更新配置最终保证集群的强leader模型,</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_2.jpg"></p>
<ul>
<li>扩容解决“脑裂”问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_3.jpg"></p>
<p>在现有的Raft集群中加入节点D,此时集群raft_cluster监听到节点D加入集群,此时leader节点更新集群的配置并向节点D同步日志数据log,最后更新集群配置之后再向Raft集群服务节点发起日志复制的RPC请求消息同步最新的集群配置信息从而保证Raft集群的强一致性.</p>
<ul>
<li>集群跨区域“脑裂”问题(扩展)</li>
</ul>
<blockquote>
<p>集群脑裂</p>
</blockquote>
<ol>
<li>初始化状态,只有华南区域部署Raft集群服务,但因业务需求原因,需要在华北地区增加机器节点,并加入到现有的Raft集群服务,即:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_region1.jpg"></p>
<ol start="2">
<li>如果两区域网络没有发生分区错误,按照上述单节点变更原则,最终Raft集群配置以及节点状态如下:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_region2.jpg"></p>
<ol start="3">
<li>如果两区域的网络发生分区,那么就会导致Raft集群服务在不同的区域中产生两个leader节点,即:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_region3.jpg"></p>
<ol start="4">
<li>华南区域leader节点发生不可用,而在重新选举的过程中,区域产生分区错误,导致Raft集群服务出现两个leader节点,即:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_region4.jpg"></p>
<p>对于3&amp;4问题,属于跨区域的集群的“脑裂”问题(ES集群也存在同样的问题)</p>
<blockquote>
<p>如何解决集群脑裂问题</p>
</blockquote>
<ul>
<li>脑裂产生的原因</li>
</ul>
<ol>
<li><p>网络发生分区错误: 机器宕机抑或是网络拥堵超时</p>
</li>
<li><p>每个节点具备成为leader节点资格.</p>
</li>
</ol>
<ul>
<li>脑裂解决</li>
</ul>
<ol>
<li><p>基于上述的现象,发生网络分区错误最有可能的原因就是网络超时,于是可以针对分区域的不同节点设定对应的超时时间,比如可以将华北区域的节点超时时间变长(等待心跳检查以及选举leader的超时时间)</p>
</li>
<li><p>其次可以将node节点降低权限,仅作为提供数据服务,不具备竞选leader资格(即没有投票资格),假设当前集群节点个数为n,根据反证法以及投票满足大多数原则(理想状态不考虑随机超时时间)可知最小可以配置具备成为leader节点个数为<code>(n/2)+1</code>并且是在处于同一个区域下,即:</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/mem_change_cluster_region5.jpg"></p>
<h3 id="Raft算法分析小结"><a href="#Raft算法分析小结" class="headerlink" title="Raft算法分析小结"></a>Raft算法分析小结</h3><h4 id="节点状态变化"><a href="#节点状态变化" class="headerlink" title="节点状态变化"></a>节点状态变化</h4><ul>
<li><p>Raft算法集群节点服务的初始化状态均为Follower节点,并且每一个Follower节点具备成为Leader节点的资格,也就是说可以同时具备存储数据以及集群Leader的特征,其次Follower节点都拥有一个随机等待leader节点发起ping心跳检测的超时时间timeout</p>
</li>
<li><p>成为候选节点之后就会更新任期Term并随机设置对应的投票请求超时时间,如果在指定的超时时间内超过半数投票,那么就会晋升成为leader节点,并周期性地向集群从服务节点发起心跳检测以避免Follower节点成为候选节点发起leader投票选择.</p>
</li>
<li><p>主观下线,即Raft算法集群服务节点中有一个Follower节点超时没有得到leader节点的心跳检测请求,那么就会为自己进行投票,此时会晋升成为候选节点,又称为单节点的主观下线,即凭借单节点服务设置的超时时间timeout来判断leader服务是否可用.(redis的sentinel集群服务的sdown)</p>
</li>
<li><p>客观下线(不属于Raft算法),即集群半数以上的Follower节点没有在超时的时间内得到leader节点的心跳检测请求(或者说集群大多数节点认为leader节点不可用)而重新发起投票选举请求.(redis的sentinel集群服务的odown)</p>
</li>
</ul>
<h4 id="节点之间的通讯"><a href="#节点之间的通讯" class="headerlink" title="节点之间的通讯"></a>节点之间的通讯</h4><ul>
<li>leader投票选举请求: 通过候选节点发起RPC的投票请求,集群其他节点在指定的timeout内接收到投票请求并按照先来先得得顺序进行投票.</li>
<li>日志复制请求: 集群服务的leader节点接收到事务操作执行事务指令并发起RPC请求对事务指令复制到事务操作日志log中并同步到集群其他服务节点</li>
<li>leader与follower节点心跳维持: leader节点发起RPC并携带任期Term信息的心跳检测,以此来维持集群服务leader节点与follower节点之间的健康检测状态,保证集群服务的可用性.</li>
</ul>
<h4 id="共识与数据一致性"><a href="#共识与数据一致性" class="headerlink" title="共识与数据一致性"></a>共识与数据一致性</h4><h5 id="Raft算法架构"><a href="#Raft算法架构" class="headerlink" title="Raft算法架构"></a>Raft算法架构</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_consensus_opr.jpg"></p>
<p>通过上述可知,客户端client service多个节点发起事务操作提交到集群的leader节点,集群的leader服务节点通过共识模块来输出对应的数据值并记录变更日志log,同时发起日志复制到集群其他服务节点以便于同步变更操作并等待大多数节点的响应之后再持久化到本地的状态机,最后更新之后再返回给客户端响应,而集群服务的其他节点则通过新的日志复制RPC消息抑或是RPC心跳检测进行一致性校验然后更新到对应的状态机上.</p>
<h5 id="共识问题"><a href="#共识问题" class="headerlink" title="共识问题"></a>共识问题</h5><ul>
<li>什么是共识</li>
</ul>
<p>简而言之,就是不同进程p对分别输入一组u的数据,通过相同的程序处理逻辑来保证其输出值最终都是v.即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_consensus.jpg"></p>
<ul>
<li>对于Raft集群存在哪些共识问题</li>
</ul>
<ol>
<li>leader的选举</li>
</ol>
<p>当Follower节点发现Raft集群leader节点不可用时就会推荐自己选举成为leader节点并发起投票选举,这个时候Follower节点成为Candidate节点,于是会自增加自己的任期Term并向Raft集群其他服务节点发起RPC通讯的投票请求,如果赢得超过半数投票请求,那么当前Follower节点就晋升成为leader节点.</p>
<ol start="2">
<li>事务操作</li>
</ol>
<p>我们知道Raft算法是属于强leader模型,所有的事务请求最终都会落到leader服务节点上,那么在Raft集群服务中只有leader节点的进程输入数据并通过leader节点的共识算法模块输出状态变更的记录值,并复制共识输出的变更记录log同步到Raft集群Follower节点.</p>
<h5 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h5><ul>
<li>什么是数据一致性</li>
</ul>
<p>Raft集群服务对外提供数据的读取始终保证一致性,即对Raft集群之外的服务,简称为客户端服务client service,client service多个节点node向Raft集群服务发起读取请求,那么要保证client service的每个节点node读取到请求数据都是一致的.</p>
<ul>
<li>如何保证一致性</li>
</ul>
<p>当Raft算法已经选举Leader节点之后,为了保证Raft集群中的数据一致性,Raft算法采取强制的Leader策略,将客户端的写入操作更新到leader节点的日志文件中,并以RPC通讯的方式复制到Raft集群的从服务节点中,从服务节点从操作日志来增量更新数据从而保证leader与follower节点数据的一致性.</p>
<ul>
<li>日志复制异常</li>
</ul>
<p>当leader节点发起复制日志的RPC请求消息到Raft集群中各个follower节点,如果此时leader节点发生不可用,那么此时会有以下几种情况(前提是leader节点的日志已经写入成功,leader节点恢复之前):</p>
<p>其一follower节点大多数接收到复制日志的请求并执行成功;</p>
<p>其二follower节点只有少数接收到复制日志的请求并执行成功;</p>
<p>其三follower节点没有接收到复杂日志的请求;</p>
<p>不论是上述哪种情况,leader节点发生不可用的时候,必然会重新选举一个具备日志完整性的follower节点作为新的leader节点,如果当前leader节点存在原有的log的记录(1&amp;2的情况),会重新发起复制日志的RPC请求消息到集群服务的各个节点,如果大多数集群服务节点都响应成功那么就会在当前的leader节点将日志log应用到状态机并在下一个RPC日志复制抑或是心跳检测消息通知其他follower节点更新到状态机上;如果响应失败(机器不可用除外,需要更新集群配置,重新RPC日志复制),一般是一致性检查失败,于是会根据一致性流程强制更新数据并最终保证日志数据与leader节点一致;最后是follower节点上并没有先前leader的日志记录,那么对应的数据将会丢失,因为重新选举之后,当leader节点恢复时,日志数据会根据一致性检查被强制更新为与leader节点日志一致,因此需要在客户端服务进行重试与幂等性操作保证数据不丢失.</p>
<h4 id="leader任期Term"><a href="#leader任期Term" class="headerlink" title="leader任期Term"></a>leader任期Term</h4><h5 id="任期特征"><a href="#任期特征" class="headerlink" title="任期特征"></a>任期特征</h5><ul>
<li><p>Raft算法中任期Term包含时间段以及编号,并且会影响leader选举和请求的处理</p>
</li>
<li><p>Raft算法中leader节点的任期编号具备单调性,且为正整数递增</p>
</li>
</ul>
<h5 id="任期的更新"><a href="#任期的更新" class="headerlink" title="任期的更新"></a>任期的更新</h5><ul>
<li>当Raft集群服务中存在follower节点发现leader节点不可用的时候,就会成为candidate节点,并为当前节点的任期自增1,然后将自己的任期编号Term以参数的形式携带在投票请求的RPC中向其他服务节点发起新一轮任期leader节点的投票选举.</li>
</ul>
<h5 id="任期与投票选举"><a href="#任期与投票选举" class="headerlink" title="任期与投票选举"></a>任期与投票选举</h5><ul>
<li>Follower节点接收到Candidate节点的任期投票,若当前的follower节点任期比投票选举的任期小且是在超时的时间范围内,那么当前Follower节点就会为发起投票的请求节点进行选举并给予响应</li>
<li>Follower节点接收到Candidate节点的任期投票,若当前的follower节点任期比投票选举的任期大,那么当前的Follower节点将会拒绝投票请求</li>
<li>如果Raft服务的leader节点由于发生不可用,而同时在不可用期间Raft集群已经通过选举产生新的leader节点服务,此时当原先的leader服务节点恢复健康状态时,由于会接收到leader节点的心跳检测以及任期编号等信息,发现当前的任期编号比接收到任期编号小,那么这时候原先的leader节点就会更新自己的任期并成为集群服务的follower节点(单节点变更).</li>
</ul>
<h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><h5 id="周期检测"><a href="#周期检测" class="headerlink" title="周期检测"></a>周期检测</h5><p>leader节点会周期性向follower节点发起心跳检测(携带投票选举的Term),以避免follower节点成为候选节点进行投票选举.</p>
<h5 id="节点具备成为leader权利"><a href="#节点具备成为leader权利" class="headerlink" title="节点具备成为leader权利"></a>节点具备成为leader权利</h5><p>Raft集群服务的follower节点在指定的时间内没有接收到leader节点的心跳检测消息,那么此时会认为leader节点不可用,会推荐自己成为候选节点并自增任期编号,同时发起leader选举.</p>
<h5 id="大多数原则"><a href="#大多数原则" class="headerlink" title="大多数原则"></a>大多数原则</h5><p>follower节点成为candidate节点发起的leader选举,如果获得集群服务大多数服务节点的投票响应,那么当前follower节点就会成为leader节点</p>
<h5 id="具备持续性"><a href="#具备持续性" class="headerlink" title="具备持续性"></a>具备持续性</h5><p>Raft集群通过每次选举产生新的leader,同时会对应新的Term,每一轮新Term都具备持续性,也就是说在一个任期Term内,只要是leader节点是可用的,那么就不会发生新的一轮选举,可用性是通过周期性检测来保证.</p>
<h5 id="一次投票-amp-先来服务"><a href="#一次投票-amp-先来服务" class="headerlink" title="一次投票&amp;先来服务"></a>一次投票&amp;先来服务</h5><p>在一次选举中,每一个服务节点最多会对一个任期编号进行投票,并且按照先来先服务原则进行投票.即在发生选举过程中,可能存在两个或者多个候选节点向集群服务发起投票,Raft集群为了避免同时发生投票的碰撞,采取随机超时时间的心跳检测机制来进行投票,这个时候对于其中一个服务节点A,先接收到服务节点B且携带任期编号为v的投票请求并给予投票,此时服务节点C也携带任期编号为v投票请求到服务节点A,由于A节点先投票给B,于是返回给节点C当前已经没有选票,投票失败的响应.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote_request_short.jpg"></p>
<h5 id="满足完整性日志"><a href="#满足完整性日志" class="headerlink" title="满足完整性日志"></a>满足完整性日志</h5><p>日志完整性高的follower节点拒绝投票给日志完整性低的候选节点.假设现在Raft集群服务提交的日志log如下(其中包含日志索引logIndex,实体log包含任期编号term以及变更的指令):</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/arch/raft02/leader_vote__replicated_log.jpg"></p>
<p>现在Raft集群中各个节点以及日志复制情况如上,那么此时如果leader节点发生不可用,followers都具备成为leader节点,但是如果是一个日志索引下标<code>logIndex=5</code>的候选节点向一个日志索引下标为<code>logIndex=8</code>的follower节点发起投票请求,这个时候follower节点将会被拒绝,主要原因是后者的<code>logIndex</code>更大,相对地,其日志完整性更高(可类比于kafka的ISR副本机制)</p>
<h4 id="Raft算法中的timeout含义"><a href="#Raft算法中的timeout含义" class="headerlink" title="Raft算法中的timeout含义"></a>Raft算法中的timeout含义</h4><ul>
<li>follower节点等待leader节点发起的心跳检测的随机超时时间</li>
<li>每次发起新的一轮选举时,候选节点发起投票请求并等待投票请求响应的随机超时时间.</li>
</ul>
]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>单节点的一致性hash算法</title>
    <url>/2020/10/01/single_consistence/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/single_consistence/title.jpg"></p>
<h3 id="JDK1-7版本的Hash"><a href="#JDK1-7版本的Hash" class="headerlink" title="JDK1.7版本的Hash"></a>JDK1.7版本的Hash</h3><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><h5 id="HashTabale简述"><a href="#HashTabale简述" class="headerlink" title="HashTabale简述"></a>HashTabale简述</h5><ul>
<li>实现<code>Map</code>接口,提供实现所有<code>Map</code>的接口方法,通过存储Key数据来映射对应的Value值,并且不允许存储的Key以及Value为空.</li>
<li>存储的Key数据必须要实现Object的<code>HashCode</code>以及<code>Equals</code>方法.</li>
<li><code>HashTable</code>影响性能的两个核心因素,即初始化容量(initial capacity)以及负载因子(load factor);容量capacity即为hash table对应桶的个数,初始化容量即为hash table进行初始化创建hash table需要分配的桶个数;load factor则是hash table在实现容量动态扩容前的桶个数满意度的度量器,即hash table的桶个数达到<code>capaticy * load factor</code>会实现动态扩容,即rehash.</li>
<li>默认load factor为0.75,过高则能减少分配空间的浪费但是查询的时间复杂度会增加,过低会增加分配空间的浪费,无法充分利用内存空间,相对地能提升查询的时间复杂度.</li>
<li><code>Map</code>存储的key-value数据通过创建一个迭代器并返回,迭代器具备<code>fail-fast</code>特性,即在进行迭代器遍历的过程中,如果对遍历的元素进行修改,将会抛出异常,即<code>ConcurrentModificationException</code>;而对于返回<code>Map</code>存储的key或者是value的枚举类<code>Enumerations</code>并非具备<code>fail-fast</code>特性.</li>
<li>JDK源码对<code>Fail-Fast</code>的解析说明,迭代器的快速失败行为不能得到保证,因为一般来说,如果是存在非同步并发修改时不可能做出任何硬性保证.具备<code>Fail-Fast</code>的迭代器尽最大努力抛出ConcurrentModificationException.因此,如果一个程序依赖于这个异常来保证其正确性是错误的做法,因为迭代器的fail-fast行为只能用于程序bug的检测.</li>
<li>在实际使用过程中,如果当前应用场景不需要保证线程安全的并发访问,JDK推荐使用<code>HashMap</code>,而对于需要保证线程安全的并发访问,JDK推荐使用<code>ConcurrentHashMap</code>.</li>
</ul>
<h5 id="HashTable的类关系图"><a href="#HashTable的类关系图" class="headerlink" title="HashTable的类关系图"></a>HashTable的类关系图</h5><p><img src="/Users/keithl/docker/dev/data/xiaokunliu.github.io/websites/zimages/arch/single_consistence/hashtabe_class.jpg"></p>
<p>根据上述类图,我们知道HashTable主要包含三个核心部分,一个是控制hash阀值的Holder,一个是存储key-value的Entry以及提供遍历查询的KeySet/ValueSet/迭代器Enumerator.</p>
<h5 id="put-amp-putAll操作"><a href="#put-amp-putAll操作" class="headerlink" title="put&amp;putAll操作"></a>put&amp;putAll操作</h5><blockquote>
<p>HashTable`源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// 对key进行hash</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  			</span><br><span class="line">  			<span class="comment">// 根据hash结果获取bucket的下标</span></span><br><span class="line">  			<span class="comment">// 查询所在下标并对重复key对应的value进行替换</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">          	<span class="comment">// 动态扩容</span></span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// putAll操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>put&amp;putAll的核心要点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash算法</span></span><br><span class="line">hash(key);</span><br><span class="line"><span class="comment">// 分配计算bucket的下标</span></span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line">rehash();</span><br><span class="line"><span class="comment">// 创建新的entry</span></span><br><span class="line"><span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br></pre></td></tr></table></figure>

<ul>
<li>Hash算法</li>
</ul>
<ol>
<li>对象之间的 == 与 equals区分</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// == 是对象存储的内存地址比较</span></span><br><span class="line"><span class="comment">// equals是对象属性引用的比较,可以自定义两个对象是否相同的原则</span></span><br><span class="line"><span class="comment">// 两者之间存在歧义的等价关系,jdk的Object定义的源码说明如下:</span></span><br><span class="line"><span class="comment">// The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements</span></span><br><span class="line"><span class="comment">//     * the most discriminating possible equivalence relation on objects;</span></span><br><span class="line"><span class="comment">//     * that is, for any non-null reference values &#123;@code x&#125; and</span></span><br><span class="line"><span class="comment">//     * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only</span></span><br><span class="line"><span class="comment">//     * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object</span></span><br><span class="line"><span class="comment">//     * (&#123;@code x == y&#125; has the value &#123;@code true&#125;).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"> 	</span><br><span class="line">  	</span><br><span class="line">  	 <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;1113&quot;</span>, <span class="number">4</span>, <span class="string">&quot;xxx3&quot;</span>);</span><br><span class="line">        Person p5 = p4;</span><br><span class="line">       	</span><br><span class="line">       <span class="comment">// 很明显,下面equals是不合理的,引用同一份内存地址,对象存储的属性以及地址分配空间应当是保持一致性的</span></span><br><span class="line">       <span class="comment">// 于是在逻辑上,如果a1 == a2, 那么一定会有a1.equals(a2), 反之不一定成立,于是&quot;==&quot;是&quot;equals&quot;的充分条件,而&quot;equals&quot;是&quot;==&quot;的必要条件.</span></span><br><span class="line">        System.out.println(p4 == p5);       <span class="comment">// 地址相同,true</span></span><br><span class="line">        System.out.println(p4.equals(p5));	<span class="comment">// 上述自定义为false,所以永远为false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据jdk语法含义,equals方法是值的比较,或者说是对象属性值的比较,于是重写equals方法应当如下:</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 引用同一份内存地址,必须返回true</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不同对象但是具备相同的属性也作为两个对象相同.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder()</span><br><span class="line">    .append(age, person.age)</span><br><span class="line">    .append(name, person.name)</span><br><span class="line">    .append(hobby, person.hobby)</span><br><span class="line">    .isEquals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>hash算法需要将对象进行<code>hashCode</code>以及<code>equals</code>方法的必要性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Java语法规范</span></span><br><span class="line"><span class="comment">// The method equals definesanotion of object equality,which is based on value,not reference, comparison</span></span><br><span class="line"><span class="comment">// The method hashCode is very useful, together with the method equals, in hashtables such as java.util.HashMap</span></span><br><span class="line"><span class="comment">//The equals method in Enum is a final method that merely invokes super.equals on its argument and returns the result, thus performing an identity comparison</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object定义的equals方法以及hashcode方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Object的hashCode是基于底层C语言实现</span></span><br><span class="line">  <span class="comment">// 存在的含义: 返回一个对象的hashcode,如果对象是存储在HashMap数据结构中,将有利于hashMap进行hash运算来存储到对应HashTable的桶中</span></span><br><span class="line">  <span class="comment">// 1. 如果两个对象通过equals比较是相同的,那么两个对象的hashcode也必须是一致的</span></span><br><span class="line">  <span class="comment">// 2. 如果两个对象通过equals比较返回为false,那么对应的hashcode不一定是需要相等的,对于不相等的对象(地址空间不同)但是具备相同的hashcode数值,可以考虑重写equals的方法以确保对象保持相同的hashcode以及equals来提升hashMap的性能.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// equals方法的含义,对于非空的x,y,z</span></span><br><span class="line">  <span class="comment">// 1. 具备自反性,x.equals(x) - true</span></span><br><span class="line">  <span class="comment">// 2. 具备对称性,x.equals(y) 与 y.equals(x) 是一致的</span></span><br><span class="line">  <span class="comment">// 3. 具备传递性,x.equals(y), y.equals(z) =》x.equals(z) 结果相同</span></span><br><span class="line">  <span class="comment">// 4. 总是返回false,对于任意非空x,y,z有 x.equals(null) = false</span></span><br><span class="line">  <span class="comment">// 根据上述hashCode的源码说明,当使用HashMap存储对象作为key的时候,需要将对象的equals方法以及hashCode进行覆盖重写以保持通过equals比较返回的对象为true具备相同的hascode值,以提升hashMap的性能.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// HashTable以及HashMap的存储源码(为什么需要重写hashcode的同时也要重写equals方法能提升map的性能)</span></span><br><span class="line"><span class="comment">// 在put方法中存在以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">  <span class="comment">// 判断hashCode以及equals方法来确定是否属于同一个key,是的话直接覆盖</span></span><br><span class="line">  <span class="comment">// 存在两个不同对象但是具备相同的hash,属性值不同的情况,因此在这里比较hash以及equals来保证是相同key.</span></span><br><span class="line">  <span class="comment">// 不同属性值但是相同的hash会存放在链表中</span></span><br><span class="line">  <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">    V old = e.value;</span><br><span class="line">    e.value = value;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashcode相同但是equals不相同以及hashCode不相同的情况</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">  <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">  rehash();</span><br><span class="line"></span><br><span class="line">  tab = table;</span><br><span class="line">  hash = hash(key);</span><br><span class="line">  index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates the new entry.</span></span><br><span class="line">Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果hashCode不同,那么直接插入hashTable对应的桶位置</span></span><br><span class="line"><span class="comment">// 如果hashCode相同,那么将会以链表的形式插入链表头部,并指向hashTbale的桶位置中</span></span><br><span class="line"><span class="comment">// 因此我们可以知道,当不重写equals方法的时候,这个时候产生的链表长度会越来越长,查询的时间复杂度为O(N),影响hashMap的查询效率</span></span><br><span class="line">tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>hash算法实现原理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * A randomizing value associated with this instance that is applied to</span></span><br><span class="line"><span class="comment">  * hash code of keys to make hash collisions harder to find.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> hashSeed;  <span class="comment">// 与此实例相关联的随机值，应用于键的哈希码，降低hash冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Initialize the hashing mask value.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">    (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">  <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">  <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">    hashSeed = useAltHashing</span><br><span class="line">      ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">      : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行异或运算</span></span><br><span class="line"><span class="comment">// 如果vm.isBooted 开启并且容量大于threshold会分配hashSeed</span></span><br><span class="line"><span class="comment">// 配置jdk.map.althashing.threshold</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -Djdk.map.althashing.threshold=-1:表示不做优化（不配置这个值作用一样）</span></span><br><span class="line"><span class="comment">// -Djdk.map.althashing.threshold&lt;0:报错</span></span><br><span class="line"><span class="comment">// -Djdk.map.althashing.threshold=1:表示总是启用随机HashSeed</span></span><br><span class="line"><span class="comment">// -Djdk.map.althashing.threshold&gt;=0:便是hashMap内部的数组长度超过该值了就使用随机HashSeed，降低碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用hashSeed主要是为了降低hash冲突</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashSeed will be zero if alternative hashing is disabled.</span></span><br><span class="line">    <span class="comment">// key的hashcode 与 hashSeed 进行异或</span></span><br><span class="line">     <span class="keyword">return</span> hashSeed ^ k.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配并计算key对应的桶的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashTable的put方法</span></span><br><span class="line">put() &#123;</span><br><span class="line"> 				 <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述的代码,有几个细节需要注意:</p>
<ol>
<li>其一,在java中最大以及最小的整数值为</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the minimum value an &#123;<span class="doctag">@code</span> int&#125; can</span></span><br><span class="line"><span class="comment">     * have, -2&lt;sup&gt;31&lt;/sup&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MIN_VALUE = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the maximum value an &#123;<span class="doctag">@code</span> int&#125; can</span></span><br><span class="line"><span class="comment">     * have, 2&lt;sup&gt;31&lt;/sup&gt;-1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述可知,hash在java中取值范围是在MIN_VALUE - MAX_VALUE之间,那么对于hash &amp; MAX_VALUE得到最终的结果为 0 - 2147483647,也就是说不论hash是否为负数还是正数,都能够保证得到的index一定是落在大于等于0的区间,这样就不会导致分配的hashTable计算出现不合法的index,即index &lt; 0的情况.</p>
<ol start="2">
<li><p>其二是跟进hashTable的桶长度进行取模,得到最终的index下标一定是落在(0 - len-1)的下标范围内</p>
</li>
<li><p>其三是不同的key但是hash相同的数据,会查找hashTable桶对应下标的位置并逐个遍历链表,通过比较hashcode以及equals方法来定位是否存在相同的key来进行覆盖更新,如下代码</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这里我们可以思考一件事情,如果重写hashcode的同时不重写equals方法,会导致什么结果?</span></span><br><span class="line"><span class="comment">// 1. 不会覆盖更新,那么就是在相同的hashTable桶中的index位置插入新的entry</span></span><br><span class="line"><span class="comment">// 2. 这个时候产生的问题就是entry链条增加,那么查询的时间复杂度也会相应增加.</span></span><br><span class="line"><span class="comment">// 3. 这也是为什么在进行使用map/set存储的对象中,如果是作为key,需要重写hashcode并重写equals方法的原因,提升查询效率,减少时间复杂度.</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">  V old = e.value;</span><br><span class="line">  e.value = value;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>这里有三个变量<code>count</code>,<code>modCount</code>以及<code>threshold</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录hashTable的结构发生变化的次数,即相同位置对应的entry长度发生变化异或是hashTable因rahash内部发生变化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashTable中entry的总个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当hashTable的entry个数大小超过阀值时会进行rehash</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩容机制Rehash (当hash链的entry个数大于等于(<code>容量大小capacity*负载因子loadFactor</code>)threshold将会进行rehash)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">  Entry&lt;K,V&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">// 新的容量 = 旧有的容量加 + 1</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">      <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  Entry&lt;K,V&gt;[] newMap = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rehash,改变hashTable结构,自增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新分配hash种子</span></span><br><span class="line">  <span class="keyword">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);</span><br><span class="line"></span><br><span class="line">  table = newMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = old;</span><br><span class="line">      old = old.next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// hash seed是否变更进行重新hash</span></span><br><span class="line">      <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">        e.hash = hash(e.key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">      e.next = newMap[index];</span><br><span class="line">      newMap[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建新的Entry并追加到hashTable中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates the new entry.</span></span><br><span class="line"><span class="comment">// entry个数增加 </span></span><br><span class="line">Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">count++;</span><br></pre></td></tr></table></figure>

<h5 id="删除Remove"><a href="#删除Remove" class="headerlink" title="删除Remove"></a>删除Remove</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步删除并返回删除对应key的value数据值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取下标索引位置</span></span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">      <span class="comment">// 判断下标索引对应的链表信息</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">           <span class="comment">// 根据hashcode以及equals方法判断 </span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="遍历查询"><a href="#遍历查询" class="headerlink" title="遍历查询"></a>遍历查询</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步加锁遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取hash下标并遍历下标对应的链表,直到查找到相同的key为止</span></span><br><span class="line">  Entry tab[] = table;</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="HashMap简述"><a href="#HashMap简述" class="headerlink" title="HashMap简述"></a>HashMap简述</h5><ul>
<li>实现<code>Map</code>接口,提供了所有可选<code>Map</code>的可选方法操作,与<code>HashTable</code>类基本一致,但是区分在于<code>HashMap</code>不存在同步操作,即线程安全以及<code>HashMap</code>允许存储的Key和Value数据为空.</li>
<li>初始化容量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于HashMap的<code>put</code>方法如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果hash桶为空,那么膨胀桶为2^15大小的hashMap信息</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">// key为空,也会存储在hashMap中</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="comment">// 不论value是否被覆盖都会唤醒当前方法并记录访问</span></span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">   <span class="comment">// hashTable结构发生变更,次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放key为null的数据</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">     <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">       V oldValue = e.value;</span><br><span class="line">       e.value = value;</span><br><span class="line">       e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   modCount++;</span><br><span class="line">   addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加链表的entry</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果当前的大小大于等于最大的entry个数并且对应的桶位置非空(也就是存在hashTable桶下的链表非空)才会进行扩容</span></span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容为原来大小的2倍</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">  <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新分配hashSeed并将旧的hashTable复制到newTable中</span></span><br><span class="line">  transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">  table = newTable;</span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建entry并追加到链表中</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加entry到链表中</span></span><br><span class="line"> Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">   value = v;</span><br><span class="line">   next = n;</span><br><span class="line">   key = k;</span><br><span class="line">   hash = h;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap的<code>remove</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">  <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">   <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">   Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">   Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历链表并根据key查询对应的entry,并从链表中删除</span></span><br><span class="line">   <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">     Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">     Object k;</span><br><span class="line">     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       size--;</span><br><span class="line">       <span class="keyword">if</span> (prev == e)</span><br><span class="line">         table[i] = next;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         prev.next = next;</span><br><span class="line">       e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     prev = e;</span><br><span class="line">     e = next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap的<code>get</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据key获取value信息 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>













<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h3 id="JDK1-8版本的Hash"><a href="#JDK1-8版本的Hash" class="headerlink" title="JDK1.8版本的Hash"></a>JDK1.8版本的Hash</h3><h4 id="HashTable-1"><a href="#HashTable-1" class="headerlink" title="HashTable"></a>HashTable</h4><h4 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h4><h4 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4>]]></content>
      <categories>
        <category>distributed</category>
      </categories>
      <tags>
        <tag>分布式架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2021/04/18/docker01/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="docker-相关命令小结"><a href="#docker-相关命令小结" class="headerlink" title="docker 相关命令小结"></a>docker 相关命令小结</h3><h4 id="查看镜像地址"><a href="#查看镜像地址" class="headerlink" title="查看镜像地址"></a>查看镜像地址</h4><ul>
<li>docker info<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.6.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 1</span><br><span class="line">  Running: 0</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 1</span><br><span class="line"> Images: 1</span><br><span class="line"> Server Version: 20.10.5</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Cgroup Version: 1</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 05f951a3781f4f2c1911b05e61c160e9c30eaa8e</span><br><span class="line"> runc version: 12644e614e25b05da6fd08a38ffa0cfe1903fdec</span><br><span class="line"> init version: de40ad0</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 5.10.25-linuxkit</span><br><span class="line"> Operating System: Docker Desktop</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 4</span><br><span class="line"> Total Memory: 1.941GiB</span><br><span class="line"> Name: docker-desktop</span><br><span class="line"> ID: CVY7:NOBR:D337:VCRN:D24O:ZFH2:DJTN:TBXE:QO6K:ZOXP:A444:XIZN</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> HTTP Proxy: http.docker.internal:3128</span><br><span class="line"> HTTPS Proxy: http.docker.internal:3128</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="docker-镜像操作"><a href="#docker-镜像操作" class="headerlink" title="docker 镜像操作"></a>docker 镜像操作</h4><ul>
<li><p>docker pull</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker pull keithl20160828/dev:1.0</span></span><br><span class="line"><span class="comment">## docker pull ubuntu:lastest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>docker基于镜像创建容器实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker run -d -p 3306:3306 -p 32005:80 -p 32006:22 --name dev -v $PWD/data:/opt/data keithl20160828/dev:1.0</span></span><br><span class="line"><span class="comment">## -d 后台执行</span></span><br><span class="line"><span class="comment">## -p 端口映射</span></span><br><span class="line"><span class="comment">## --name 创建的容器名称</span></span><br><span class="line"><span class="comment">## -v docker容器数据挂载在本地磁盘</span></span><br><span class="line"><span class="comment">## 镜像以及版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列出镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 列出镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看容器的详细信息</span></span><br><span class="line">docker inspect name/Id</span><br></pre></td></tr></table></figure>
</li>
<li><p>悬虚镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 仓库名称以及镜像标签版本为none的镜像</span></span><br><span class="line"><span class="comment">## 删除悬虚镜像</span></span><br><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除一个镜像</span></span><br><span class="line">docker image rm imageName/Id</span><br><span class="line"><span class="comment">## 删除所有redis镜像</span></span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line"><span class="comment">## 删除redis:2.0版本之前的版本镜像</span></span><br><span class="line">docker imgage rm $(docker imgae ls -q -f before=redis:2.0)</span><br><span class="line"></span><br><span class="line">docker rmi imageId</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于已有的容器进行创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [container] commit -m <span class="string">&quot;commit msg&quot;</span> -a <span class="string">&quot;author&quot;</span> containerId newImage:tag </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul>
<li><p>启动与关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [container] start containerName or docker start containerName</span><br><span class="line">docker [container] stop containerName or docker stop containerName</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:8080 --name nginx-dev nginx:1.0</span><br><span class="line"><span class="comment">## -i 标准输入打开，默认为false</span></span><br><span class="line"><span class="comment">## -t 是否分配一个终端，默认为false</span></span><br><span class="line">docker run -d -it -p 80:8080 --name nginx-dev nginx:1.0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看启容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## 查看运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">## 查看容器的详细信息</span></span><br><span class="line">docker inspect name/Id</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it containerName/Id /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入与导出容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 导出</span></span><br><span class="line">docker <span class="built_in">export</span> containerName/Id container.tar</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从已有的容器文件导入</span></span><br><span class="line">cat container.tar | docker import keithl20160828/container:tag</span><br><span class="line"><span class="comment">## 从uri导入</span></span><br><span class="line">docker import uri</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停与重启容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 暂停容器</span></span><br><span class="line">docker [container] pause containerName/Id</span><br><span class="line"><span class="comment">## 重启</span></span><br><span class="line">docker [container] restart containerName/Id </span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除一个终止的容器</span></span><br><span class="line">docker rm containerName/Id</span><br><span class="line"><span class="comment">## 删除所有终止的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器文件复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## container cp命令支持在容器和主机之间复制文件</span></span><br><span class="line"><span class="comment">## 将本地的data文件复制到dev容器下的/tmp</span></span><br><span class="line">docker [container] cp data dev:/tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件系统变更</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker [container] diff containerName/Id</span></span><br><span class="line">docker diff dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看端口映射</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## docker [container] port containerName/Id </span></span><br><span class="line">docker port dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## container update命令可以更新容器的一些运行时配置，主要是一些资源限制份</span></span><br><span class="line">docker update --<span class="built_in">help</span> 查看可以更新容器运行时的配置</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h4><ul>
<li><p>Dockerfile文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER keithl@1248237617.com</span><br><span class="line"></span><br><span class="line">RUN mv /etc/apt/sources.list /etc/apt/sources.list-backup</span><br><span class="line">COPY $PWD/config/sources.list /etc/apt/sources.list</span><br><span class="line">COPY $PWD/config/.vimrc /root/.vimrc</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y openssh-server</span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN echo &#x27;root:root123&#x27; | chpasswd</span><br><span class="line">RUN sed -i &#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># SSH login fix. Otherwise user is kicked off after login</span><br><span class="line">RUN sed &#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27; -i /etc/pam.d/sshd</span><br><span class="line"></span><br><span class="line">#ENV NOTVISIBLE &quot;in users profile&quot;</span><br><span class="line">RUN echo &quot;export VISIBLE=now&quot; &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line">## install nginx</span><br><span class="line">##RUN apt-get install nginx</span><br><span class="line"></span><br><span class="line">## install mysql</span><br><span class="line">##RUN apt-get install mysql-server-5.7</span><br><span class="line"></span><br><span class="line">## install vim</span><br><span class="line">RUN apt-get install -y vim</span><br><span class="line"></span><br><span class="line">## use netstat</span><br><span class="line">RUN apt-get install -y net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 22 80 3306 50000</span><br><span class="line">CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于Dockerfile构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /path/dockerfilepath (ls -al # have Dockerfile file)</span></span><br><span class="line">docker build -t imageName:tag .</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于容器定制镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit containerName keithl20160828/dev:1.0</span><br><span class="line">docker images</span><br><span class="line">docker push keithl20160828/dev:1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于已有的镜像构建为自己的私有库镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag session-web:lastest keithl20160828/session-web:1.0</span><br><span class="line">docker push keithl20160828/session-web:1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存镜像并拷贝到新机器重建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在机器A上保存</span></span><br><span class="line">docker save nginx | gzip &gt; nginx-lastest.tar.gz</span><br><span class="line"><span class="comment">## 在机器B上加载nginx镜像</span></span><br><span class="line">docker load -i nginx-lastest.tar.gz </span><br><span class="line">docker load &lt; nginx-lastest.tar.gz </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><ul>
<li>docker数据管理方式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用-v以及--mount方式来挂载数据卷(创建docker的数据卷会持久化到操作系统上的文件系统),同时还可以通过指定--mount type=bind挂载在当前宿主机器上的文件目录，</span></span><br><span class="line"><span class="comment">## 也可以通过--mount bind=tmpfs来挂载到内存,而使用-v是挂载到数据卷上，即使持久化到docker创建的指定数据卷上</span></span><br><span class="line"><span class="comment">## --mount or -v 挂载到数据卷，生产环境</span></span><br><span class="line"><span class="comment">## --mount type=bind,挂载到主机目录，需要使用主机目录的决定路径，用于测试</span></span><br><span class="line"><span class="comment">## --mount type=tmpfs，挂载到内存中</span></span><br><span class="line"><span class="comment">## 于是使用docker进行挂载使用--mount能够更为明确自己做的事情</span></span><br><span class="line"><span class="comment">## 用户需要在多个容器之间共享一些持续更新的数据,需要使用数据卷进行挂载</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>挂载形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--mount选项支持三种类型的数据卷，</span><br><span class="line">包括：</span><br><span class="line">- volume：普通数据卷，映射到主机/var/lib/docker/volumes路径下；</span><br><span class="line">- bind：绑定数据卷，映射到主机指定路径下；</span><br><span class="line">- tmpfs：临时数据卷，只存在于内存中,还可以使用tmpfs类型的数据卷,其中数据只存在于内存中,容器退出后自动删除.</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据卷</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建数据卷</span></span><br><span class="line">docker volume create -d volumeName</span><br><span class="line"><span class="comment">## 存储在本地主机目录</span></span><br><span class="line">/var/lib/docker/volumes</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据卷</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 列出数据卷</span></span><br><span class="line">docker volumn ls</span><br><span class="line"><span class="comment">## 查看指定数据卷信息</span></span><br><span class="line">docker inspect volumn volumeName</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除悬虚数据卷</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除悬虚数据卷 </span></span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除数据卷</span></span><br><span class="line">docker volume rm volumeName</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据卷挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 使用持久化</span></span><br><span class="line"><span class="comment">## 创建一个数据卷并基于数据进行挂载</span></span><br><span class="line">docker volume create myVolume</span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev -v myVolume:/etc/nginx nginx:1.0 </span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev --mount <span class="built_in">source</span>=myVolume,target=/etc/nginx nginx:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 数据卷挂载在主机文件夹上</span></span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev -v /opt/nginx/:/etc/nginx nginx:1.0  <span class="comment">## 本地目录不存在会创建</span></span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/opt/nginx,target=/etc/nginx nginx:1.0   <span class="comment">## 本地目录不存在会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 挂载文件</span></span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev -v /opt/nginx/nginx.conf:/etc/nginx/nginx.conf nginx:1.0</span><br><span class="line">docker run -d -p 8080:80 --name nginx-dev --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/opt/nginx/nginx.conf,target=/etc/nginx/nginx.conf nginx:1.0 </span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读</span></span><br><span class="line">docker run -d -p --name web -v /webapp:/opt/webapp:ro trainning/webapp python app.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据卷共享</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 多个容器之间共享数据卷 - 数据卷容器</span><br><span class="line">## 创建数据卷容器，仅用于多个容器进行共享</span><br><span class="line">## 此时进入容器根目录即可看到dbdata目录,容器最好命名与共享的文件夹名称一致，一眼就知道共享的文件夹名称</span><br><span class="line">docker run -it -d -v /dbdata --name db ubuntu:latest</span><br><span class="line"></span><br><span class="line">## 其他容器进行共享</span><br><span class="line">## 使用--volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态</span><br><span class="line">## 如果删除了挂载的容器（包括db、db1和db2），数据卷并不会被自动删除。</span><br><span class="line">## 如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器</span><br><span class="line">docker run -it -d --volumes-from db --name db1 ubuntu:latest</span><br><span class="line">docker run -it -d --volumes-from db --name db2 ubuntu:latest</span><br><span class="line"></span><br><span class="line">## 此时在进入上述容器db/db1/db2的根目录下的dbdata为三个容器共享，此时其中一个容器在此目录进行写变化，则其他容器也能接收到最新的数据变化</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据备份与恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 挂载宿主机器并备份dbdata数据目录</span></span><br><span class="line">docker run --volumes-from db -v $(<span class="built_in">pwd</span>):/backup --name backup-docker ubuntu:lastest tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line"><span class="comment">## 恢复</span></span><br><span class="line"><span class="comment">## 先创建一个数据卷</span></span><br><span class="line">docker run -it -d -v /dbdata2 --name dbdata2 ubuntu:lastest</span><br><span class="line">docker run -it -d --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup restore-docker ubuntu:lastest tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h4><ul>
<li><p>宿主机器与docker容器之间的互通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## -P, 随机分配端口</span></span><br><span class="line">docker run -d -it -P --name dev keithl20160828/dev:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## -p 指定端口</span></span><br><span class="line">docker run -d -it -p 8080:80 --name dev keithl20160828/dev:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 映射指定地址的任意端口</span></span><br><span class="line"><span class="comment">## 将容器的80端口映射到192.168.10.9地址下的随机分配的端口</span></span><br><span class="line">docker run -d -it -p 192.168.10.9::80 --name dev keithl20160828/dev:1.0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看绑定的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看容器端口绑定到对应的地址与端口</span></span><br><span class="line">docker [container] port containerName/Id containerPort</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看容器的网络配置</span></span><br><span class="line">docker inspect containerName/Id </span><br></pre></td></tr></table></figure>
</li>
<li><p>容器之间的服务互通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建一个db的容器并绑定数据卷</span></span><br><span class="line">docker volume create db</span><br><span class="line">docker run -it -d -p 3306:3306 --name mysql-db -v db:/opt/mysql/data mysql:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现web容器与db互联</span></span><br><span class="line"><span class="comment">## --link 实现互联</span></span><br><span class="line"><span class="comment">## --link linkedContainerName:linkedContainerAlias</span></span><br><span class="line">docker run -it -d -p 80:80 --name web -v <span class="variable">$PWD</span>/go:/opt/web --link mysql-db:mysql web:1.0 go run main.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>Docker通过两种方式公开连接信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1）环境变量env</span></span><br><span class="line"><span class="comment">## 查看环境变量</span></span><br><span class="line">docker <span class="built_in">exec</span> -it dev /bin/bash</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">docker run -it -d --name dev ubuntu:1.0 env</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2)更新/etc/hosts文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it dev /bin/bash</span><br><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络相关的技术</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDN（软件定义网络）或NFV（网络功能虚拟化）的相关技术</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker三剑客</title>
    <url>/2021/04/18/docker02/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="Docker三剑客"><a href="#Docker三剑客" class="headerlink" title="Docker三剑客"></a>Docker三剑客</h3>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap与concurrenthashmap分析</title>
    <url>/2020/07/02/hashmap/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="hashmap1-7分析"><a href="#hashmap1-7分析" class="headerlink" title="hashmap1.7分析"></a>hashmap1.7分析</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>基于数组 + 单向链表的数据结构</li>
<li>如何验证数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储的数据为Entry的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何验证是单向链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;   <span class="comment">// Entry包含next的指针,表示相同的hash不同key对应的Entry都是通过链表进行相连</span></span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hashmap核心属性"><a href="#hashmap核心属性" class="headerlink" title="hashmap核心属性"></a>hashmap核心属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* The number of key-value mappings contained in this map.</span><br><span class="line">*/</span><br><span class="line">transient int size;// 当前map包含的key-value个数</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* The next size value at which to resize (capacity * load factor).</span><br><span class="line">* @serial</span><br><span class="line">*/</span><br><span class="line">// If table == EMPTY_TABLE then this is the initial capacity at which the</span><br><span class="line">// table will be created when inflated.</span><br><span class="line">int threshold; // map进行扩容的阈值</span><br><span class="line"></span><br><span class="line">// 负载因子</span><br><span class="line"> final float loadFactor;</span><br><span class="line"> </span><br><span class="line"> // 默认配置</span><br><span class="line"> // hashmap大小为16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">// 最大为2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">// 负载因子为0.75</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"> </span><br><span class="line">// 空数组 </span><br><span class="line">static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="put的过程"><a href="#put的过程" class="headerlink" title="put的过程"></a><code>put</code>的过程</h4><h5 id="put源码分析"><a href="#put源码分析" class="headerlink" title="put源码分析"></a>put源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果返回的数据值不为null,说明存在hash冲突,返回的是旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果为空数组,那么进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进行hash计算</span></span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据hash得到table对应的index</span></span><br><span class="line">  <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果存在hash冲突,根据key值来进行比较处理</span></span><br><span class="line">  <span class="comment">// 如果key相同则进行覆盖</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 记录hashmap结构变更的次数,有新的key索引到map的数组中</span></span><br><span class="line">  modCount++;</span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inflateTable初始化数组"><a href="#inflateTable初始化数组" class="headerlink" title="inflateTable初始化数组"></a><code>inflateTable</code>初始化数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数组初始化/数组扩容</span><br><span class="line">  private void inflateTable(int toSize) &#123;</span><br><span class="line">        // Find a power of 2 &gt;= toSize</span><br><span class="line">        // 扩容的容量保证数组大小为2^n</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">        // 重新初始化数组</span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">  <span class="comment">// 将hashcode的高12位与hashcode的高20位进行异或运算</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用位运算得到索引下标数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">  <span class="comment">// 原始的容量为len </span></span><br><span class="line">  <span class="comment">// 扩容后的容量为2len</span></span><br><span class="line">  <span class="comment">// 数组的数据迁移, x &amp; (len - 1) 变更为 x &amp; (2len - 1). 即原先的下标为0的数组进行数据迁移之后会转为0 或者 16,因为容量增加1倍</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">// hashcode % len</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将节点添加到链表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点entry</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 触发扩容的条件,当前的大小达到阈值并且存在hash冲突</span></span><br><span class="line">   <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">     <span class="comment">// 扩容为原先容量的2倍</span></span><br><span class="line">		 resize(<span class="number">2</span> * table.length);</span><br><span class="line">     hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">     bucketIndex = indexFor(hash, table.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   createEntry(hash, key, value, bucketIndex);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点entry并将当前的下标的entry引用指向e</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>resize</code>数组扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 数据迁移</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="get的过程"><a href="#get的过程" class="headerlink" title="get的过程"></a><code>get</code>的过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> getForNullKey();</span><br><span class="line">     Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行hash定位到table的位置,如果存储的数据的链表头不为null,那么就需要将其进行链表的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap1-7分析"><a href="#ConcurrentHashMap1-7分析" class="headerlink" title="ConcurrentHashMap1.7分析"></a><code>ConcurrentHashMap</code>1.7分析</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>基于数组 + 链表</p>
</li>
<li><p>如何验证</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储为Node的数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="comment">// segments本身是一把可重入的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每一个片段中都存储一份table的数据,进行扩容的时候是对Segment的table进行扩容</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个Node节点都具备一个next,同时对应的value以及next具备可见性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于ConcurrentHashMap是划分为一个个小片段的hashmap</span></span><br></pre></td></tr></table></figure>

<h4 id="ConcurrentHashMap核心属性"><a href="#ConcurrentHashMap核心属性" class="headerlink" title="ConcurrentHashMap核心属性"></a><code>ConcurrentHashMap</code>核心属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个片段的table大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 并发级别,表示划分的Segment的片段</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h4 id="put的过程-1"><a href="#put的过程-1" class="headerlink" title="put的过程"></a><code>put</code>的过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">  	<span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 计算hash</span></span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//  this.segmentShift = 32 - sshift;  // 32 - 4</span></span><br><span class="line">  <span class="comment">// this.segmentMask = ssize - 1;   		//默认为 15</span></span><br><span class="line">  <span class="comment">// 对应concurrentHashMap的容量大小,容量大小为2^n,保证定位到的j落在数组下标上</span></span><br><span class="line">     <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">     <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">        (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">      s = ensureSegment(j);</span><br><span class="line">     <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化片段</span></span><br><span class="line">ensureSegment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据存储到Segment对应的table中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化<code>ensureSegment</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll技术扩展</title>
    <url>/2020/03/13/epoll/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="Epoll技术回顾"><a href="#Epoll技术回顾" class="headerlink" title="Epoll技术回顾"></a>Epoll技术回顾</h5><p>基于上一篇的epoll技术存在一些问题，对此将纠正部分要点</p>
<h6 id="epoll使用技术"><a href="#epoll使用技术" class="headerlink" title="epoll使用技术"></a>epoll使用技术</h6><blockquote>
<p>使用锁的技术</p>
</blockquote>
<ul>
<li>读写锁:内核在操作对象进行轮询的时候加读锁,而通过加写锁为了保证唤醒只执行一次,即在网络socket数据报可达,通过中断上下文调用<code>wake_up()</code>方法来触发回调<code>callback</code>方法的执行,通过callback方法将执行的task添加到CPU就绪队列️中，方便CPU进行调度执行</li>
<li>使用epoll空间的内置的锁<code>mtx</code>:当事件就绪的时候,内核需要将就绪的socket拷贝到用户空间,为了保证期间能够被拷贝而能够进行休眠,休眠的过程需要进行加锁</li>
<li>全局锁:通过加全局锁释放epoll容器下的资源,避免产生死锁</li>
</ul>
<h6 id="epoll技术使用SLAB的方式进行内存管理"><a href="#epoll技术使用SLAB的方式进行内存管理" class="headerlink" title="epoll技术使用SLAB的方式进行内存管理"></a>epoll技术使用SLAB的方式进行内存管理</h6><p>epoll技术基于SLAB的方式管理内存,通过SLAB的方式来创建epoll空间以及epitem结构体对象</p>
<blockquote>
<p>epoll对象</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventpoll.c</span></span><br><span class="line">ep = kzalloc(<span class="keyword">sizeof</span>(*ep), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// slab.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kzalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> kmalloc(size, gfp | __GFP_ZERO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>epitem结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Slab cache used to allocate &quot;struct epitem&quot; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">epi_cache</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slab cache used to allocate &quot;struct eppoll_entry&quot; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pwq_cache</span> __<span class="title">read_mostly</span>;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SLAB内存管理特点</p>
</blockquote>
<ul>
<li>使用连续的内存地址空间来存储epitem/epoll,避免内存碎片(多个epoll的产生是在多核下多进程)</li>
<li>使用的epitem/epoll释放存放在”对象池”中进行重复利用，同时减少创建和销毁epitem带来的性能开销(内存申请和释放的开销),可以理解为高速缓存</li>
<li>内存分配原理如下:<br><img src="http://s1.wailian.download/2020/03/14/slab_principle9dde9930a78a6378.jpg" alt="slab_principle9dde9930a78a6378.jpg"></li>
</ul>
<h6 id="epoll技术设计"><a href="#epoll技术设计" class="headerlink" title="epoll技术设计"></a>epoll技术设计</h6><blockquote>
<p>epoll空间以及epitem部分源代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Lock which protects rdllist and ovflist */</span></span><br><span class="line">    <span class="keyword">rwlock_t</span> lock;  <span class="comment">// 读写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rbr</span>;</span>  <span class="comment">// 红黑树根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transferring ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* RB tree node links this structure to the eventpoll RB tree */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span>     <span class="comment">//连接红黑树结构的节点</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span>   <span class="comment">// 就绪队列header节点，与epoll空间的ready list连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span>    <span class="comment">// 存储注册的socket的fd以及对应的file</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>   <span class="comment">// 指向epoll容器</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>   <span class="comment">// 监听的事件变化结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>epoll设计分析</p>
</blockquote>
<ul>
<li>epoll技术在逻辑设计上,epoll空间作为epitem的容器,同时将注册的socket绑定到epitem中,并且epoll空间与epitem在逻辑设计存储上用红黑树结构进行存储，方便通过socket的fd快速定义到对应的epitem</li>
<li>epoll空间通过ovflist将所有就绪的epitem以单链表的结构连接起来</li>
<li>epitem包含wake_up唤醒函数以及对应的socket描述符信息，同时在注册新的socket的时候绑定对应的一个epitem,而每个epitem都将添加到对应的epoll_entry节点上,并将epoll_entry节点添加到epoll空间下的等待队列中,在系统调用<code>epoll_wait</code>的时候进行轮询</li>
<li><code>ep_wait</code>通过epoll空间的轮询队列wait queue进行事件轮询遍历检测当前是否有就绪事件,如果有会将就绪事件拷贝到<code>ready list</code>队列中</li>
<li>对此基于上述进行小结,对于wait_queue - poll_wait_queue - ovflist - ready_list,其流程如下：<br><img src="http://s1.wailian.download/2020/03/14/epoll_logic_struct.jpg" alt="epoll_logic_struct.jpg"></li>
</ul>
<h6 id="Epoll给予的思考小结"><a href="#Epoll给予的思考小结" class="headerlink" title="Epoll给予的思考小结"></a>Epoll给予的思考小结</h6><blockquote>
<p>使用epitem&amp;epoll技术的思考</p>
</blockquote>
<ul>
<li>epoll技术通过使用epitem中间层的方式来完成对每个注册的socket进行监控,通过对等待队列上事件节点的轮询将就绪节点以链表的方式连接起来,避免了数组遍历与查找</li>
<li>借助epoll容器来对每个epitem进行管理,由内核对epoll空间进行事件监控,即将所有的事情委托给容器来进行操作,epoll容器将最终的结果返回告知唤醒处理逻辑</li>
<li>从epoll技术的思考中，我们也可以想到在实际业务工作领域中，可以借鉴epoll思想引入中间层来解决原有结构存在的不足,通过中间层增强功能来弥补不足 </li>
</ul>
<blockquote>
<p>采用分散冗余思想</p>
</blockquote>
<ul>
<li>epoll技术为了解决大内存数据拷贝问题,将注册和等待进行拆分,分别针对对应的细小功能模块进行优化和改进,也就是相比select/poll设计上更为细粒度且专业化</li>
<li>为了提升性能,在内部使用SLAB内存管理方式会预先申请连续内存存储对应的对象,也就是在某一个时刻上存在空间的冗余</li>
<li>对此,在我们大型系统中,为了缓解高并发流量的压力,也会采取集群分布式的方式来分担系统的流量负载,也会存在分散冗余的设计</li>
</ul>
<h5 id="其他高级轮询技术"><a href="#其他高级轮询技术" class="headerlink" title="其他高级轮询技术"></a>其他高级轮询技术</h5><h6 id="dev-poll"><a href="#dev-poll" class="headerlink" title="/dev/poll"></a>/dev/poll</h6><p>是Solaris操作系统上名为<code>/dev/poll</code>的特殊文件提供了可扩展的轮询大量描述,相比select技术,其轮询技术可以预先设置好待查询的文件描述符列表,然后进入一个循环等待事件发生,每次循环回来之后不需要再设置该列表,其流程如下:</p>
<ul>
<li>打开<code>/dev/poll</code>文件，然后初始化一个pollfd结构数组(poll使用的结构)</li>
<li>调用<code>write</code>方法往<code>/dev/poll</code>写这个结构数组并传递给内核</li>
<li>执行<code>io_ctl</code>的<code>DP_POLL</code>阻塞自身以等待事件的发生</li>
<li>调用结构如下:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dvpoll</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>* <span class="title">dp_fds</span>;</span>      <span class="comment">// 链表的形式,指向一个缓冲区,提供给ioctl返回的时候存储一个链表的数组</span></span><br><span class="line">    <span class="keyword">int</span>            dp_nfds;     <span class="comment">// 缓冲区成员大小</span></span><br><span class="line">    <span class="keyword">int</span>            timeout; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决大内存拷贝问题,但是对于<code>/dev/poll</code>的实现需要查看对应的solaris系统细节,存在兼容性问题</li>
</ul>
<h6 id="kqueue技术"><a href="#kqueue技术" class="headerlink" title="kqueue技术"></a>kqueue技术</h6><ul>
<li>FreeBSD4.1引入kqueue技术,允许进程向内核注册描述所关注的kqueue事件的事件过滤器(event filter),其定义如下:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的kqueue描述符,用户后续的kevent调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kqueue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于注册事件也用于确定是否有事件发生</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kevent</span><span class="params">(<span class="keyword">int</span> kq,                                                                  <span class="comment">// kqueue的注册事件fd</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct kevent *changelist, <span class="keyword">int</span> nchanges,                           <span class="comment">// 给出关注事件作出的更改,无更改为NULL &amp; 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">           struct kevent *eventlist, <span class="keyword">int</span> nevents,                                   <span class="comment">// kevent结构数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timespc *timeout)</span></span>;                                          <span class="comment">// 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新事件函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EV_SET</span><span class="params">(struct kevent *kev, <span class="keyword">uintptr_t</span> ident, <span class="keyword">short</span> filter, u_short flags, u_int fflags, intptr_r data, <span class="keyword">void</span> *udata)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kevent结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>   ident;</span><br><span class="line">    <span class="keyword">short</span> filter;</span><br><span class="line">    u_short flags;</span><br><span class="line">    u_int fflags;</span><br><span class="line">    intptr_r data;</span><br><span class="line">    <span class="keyword">void</span> *udata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上述的结构可以推测出与<code>epoll</code>的实现原理类似,只不过相比epoll实现,增加更多事件的监听(异步IO/文件修改通知/进程跟踪/信号处理等)</li>
<li>但是和<code>/dev/poll</code>一样存在的兼容性问题,目前是在FreeBSD系统中</li>
<li>对应不同的事件以及事件的过滤器，如下：<br><img src="http://s1.wailian.download/2020/03/14/kqueue_filters.jpg" alt="kqueue_filters.jpg"><br><img src="http://s1.wailian.download/2020/03/14/kqueue_flags.jpg" alt="kqueue_flags.jpg"></li>
</ul>
<h5 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h5><h6 id="什么是C10K问题"><a href="#什么是C10K问题" class="headerlink" title="什么是C10K问题"></a>什么是C10K问题</h6><blockquote>
<p>对于C10K问题,给出以下的参考链接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://en.wikipedia.org/wiki/C10k_problem</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C10K的理解</p>
</blockquote>
<p>摘录wiki百科,在互联网应用中,服务端进程要处理大量的客户端的socket,C10K命名是为了同时处理1w个连接的缩写名称,是属于一个优化问题.</p>
<h6 id="现有解决C10K成熟方案"><a href="#现有解决C10K成熟方案" class="headerlink" title="现有解决C10K成熟方案"></a>现有解决C10K成熟方案</h6><ul>
<li>Nginx是为了解决C10K设计的高并发连接处理服务器</li>
<li>IO框架</li>
<li>事件驱动设计</li>
<li>Reactor设计模式</li>
</ul>
<h6 id="C10K与C10M相关文章"><a href="#C10K与C10M相关文章" class="headerlink" title="C10K与C10M相关文章"></a>C10K与C10M相关文章</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.kegel.com/c10k.html</span><br><span class="line">http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之IO演进简述</title>
    <url>/2020/03/19/javaio/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 参考链接</span><br><span class="line">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</span><br><span class="line">https://www.slideshare.net/e456/tyma-paulmultithreaded1</span><br></pre></td></tr></table></figure>

<p>在先前的文章<a href="https://blog.csdn.net/wind_602/article/details/104456904">《Unix之IO模型》</a>已经讲述到5种IO模型以及对应的同步异步和阻塞非阻塞相关核心概念,接下来看下Java的IO模型在服务端的网络编程中是如何演进,注意这里用启动Java程序表示一个JVM进程,而JVM进程中以多线程方式进行协作,这里讲述以线程为主展开</p>
<h5 id="Java中的BIO演进"><a href="#Java中的BIO演进" class="headerlink" title="Java中的BIO演进"></a>Java中的BIO演进</h5><blockquote>
<p>BIO 概述</p>
</blockquote>
<ul>
<li>在上篇文章中讲述到阻塞式IO是应用进程等待内核系统接收到数据报并将数据报复制到内核再返回的处理过程</li>
<li>在Java中的阻塞式IO模型(Blocking IO)网络编程中,服务端<code>accept</code> &amp; <code>read</code> 都需要等待客户端建立连接和发起请求才能够进行让服务端程序进行响应,也就是上述的方法在服务端的编程中会让服务端的主线程产生阻塞,当其他客户端与Java服务端尝试建立连接和发请求的时候会被阻塞,等待前面一个客户端处理完之后才会处理下一个客户端的连接和请求,以上是Java的BIO体现</li>
</ul>
<blockquote>
<p>服务端单线程BIO模型</p>
</blockquote>
<ul>
<li>单线程图解</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200224112801220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>代码演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.java</span></span><br><span class="line"><span class="comment">// 仅写部分服务端核心代码</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(ip, port);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	Socket socket = server.accept();	<span class="comment">// 接收客户端的连接,会阻塞</span></span><br><span class="line">	out.put(<span class="string">&quot;收到新连接:&quot;</span> + socket.toString());</span><br><span class="line">	<span class="comment">// client have connected</span></span><br><span class="line">	<span class="comment">// start read</span></span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BuufferedReader(<span class="keyword">new</span> InputstreamReader(socket.getInputStream));</span><br><span class="line">	String line = br.readLine();		<span class="comment">// 	等待客户端发起请求进行读取操作,会阻塞</span></span><br><span class="line">	<span class="comment">// decode 	..</span></span><br><span class="line">	<span class="comment">// process  ..</span></span><br><span class="line">	<span class="comment">// encode   ..</span></span><br><span class="line">	<span class="comment">// send     ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果(启动两个客户端)<br><img src="https://img-blog.csdnimg.cn/20200224111717505.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020022411180840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200224111850175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>分析<ul>
<li>上述代码accept方法以及read方法需要等待客户端发送数据过来,服务端才能从操作系统的底层网卡获取数据,在没有获取数据之前将处于阻塞状态</li>
<li>其次,可以看到上述的服务端程序只能处理一个客户端的连接和请求操作,只有当前的客户端连接以及请求执行完之后才能接收下一个客户端的连接以及请求处理操作</li>
<li>不足: 上述代码压根无法满足服务端处理多客户端的连接和请求,同时造成CPU空闲,尤其是在接收客户端读取的时候,如果没有客户端读取其他客户端建立的连接请求根本无法处理,因此对上述进行改进为多线程处理方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>基于1:1的多线程BIO模型</p>
</blockquote>
<ul>
<li>根据上述的BIO模型,现优化为主线程接收accept以及通过创建多线程方式处理IO的读写操作</li>
<li>一个客户端的请求处理交由服务端新创建的一个线程进行处理,主线程仍然处理接收客户端连接的操作</li>
<li>如下图<br><img src="https://img-blog.csdnimg.cn/20200224113035793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>代码演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread-task.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">IOTask</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	run()&#123;</span><br><span class="line">		<span class="keyword">while</span>(!Thread.isInterrupt())&#123;</span><br><span class="line">			<span class="comment">// read from socket inputstream</span></span><br><span class="line">			<span class="comment">// encode reading text</span></span><br><span class="line">			<span class="comment">// process</span></span><br><span class="line">			<span class="comment">// decode sent text</span></span><br><span class="line">			<span class="comment">// send</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.java</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(ip, port);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	Socket client = server.accept();</span><br><span class="line">	out.put(“收到新连接:” + client.toString());</span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> IOTask(client)),start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行效果(客户端启动服务端就接收到客户端的连接)<br><img src="https://img-blog.csdnimg.cn/20200224113906151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>分析<ul>
<li>通过多线程的方式将Accept与IO读写操作的阻塞方式进行分离,主线程处理accept接收客户端的连接,新开线程接收客户端的请求进行请求处理操作</li>
<li>上述的方式仅仅是将阻塞的方式进行分离,但是如果处理的客户端数量越来越多的时候,上述服务器创建线程会越来越多,容易造成机器CPU出现100%情况,那么我们可以如何控制线程的方式,在并发编程中,一般通过管理并发处理任务的多线程技术是采用线程池的方式,于是就有了以下的M:N的多线程网络编程的BIO模型</li>
</ul>
</li>
</ul>
<blockquote>
<p>基于M:N的线程池实现的BIO模式</p>
</blockquote>
<ul>
<li>M:N的线程池实现的图解如下<br><img src="https://img-blog.csdnimg.cn/20200224115357526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.java</span></span><br><span class="line">ExecutorService executors = Executros.newFixedThreadPool(MAX_THREAD_NUM);</span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(ip,port);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	Socket client = server.accept();</span><br><span class="line">	out.put(“收到新连接:” + client.toString());</span><br><span class="line">	threadPool.submit(<span class="keyword">new</span> IOTask(ckient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<ul>
<li>上述运行结果与1:1的线程模型是一致的,但是相比1:1创建线程的方式,充分利用池化技术重复利用线程资源,有助于降低CPU占用的资源</li>
<li>其次,上述的BIO都是属于阻塞式IO处理,每一次的accept操作以及read操作都需要等待客户端的操作才能给予响应,如果客户端不发生操作,那么新创建的线程将一直处于阻塞状态,将占用资源迟迟没有释放,也容易造成CPU发生瓶颈,于是我们想到能否等到客户端有发起相应的操作的时候线程才进行处理呢,在客户端还没有发生请求操作的时候,服务端线程资源是否可以优先处理其他任务,提升CPU利用率呢,这也就是接下来的非阻塞式IO,即Non-Blocking IO</li>
</ul>
</li>
</ul>
<h6 id="Java中的NIO演进"><a href="#Java中的NIO演进" class="headerlink" title="Java中的NIO演进"></a>Java中的NIO演进</h6><blockquote>
<p>NIO概述</p>
</blockquote>
<ul>
<li>在<a href="https://blog.csdn.net/wind_602/article/details/104456904">《Unix的IO模型》</a>中的NIO模型有非阻塞式IO,IO复用模型以及信号驱动的IO模型,在Java中的NIO模型主要是以非阻塞式IO以及IO复用模型为主</li>
<li>从上述的BIO可知,服务端会在accept方法以及read方法调用中导致当前线程处于阻塞状态,结合Unix中的非阻塞式IO可知,NIO本质上是将上述的方法设置为非阻塞,然后通过轮询的方式来检查当前的状态是否就绪,如果是Accept就处理客户端连接事件,如果是READ就处理客户端的请求事件</li>
<li>Java实现NIO的方式注意依赖于以下三个核心组件<ul>
<li>Channel通道:服务端与客户端建立连接以及进行数据传输的通道,分为ServerSocketChannel(接收客户端的TCP连接通道)以及SocketChannel(建立与服务端的连接通道) </li>
<li>Buffer缓存区: 客户端与服务端在channel中建立一个连续数组的内存空间,用于在channel中接收和发送数据数据实现两端的数据通信</li>
<li>Selector选择注册器,对比IO复用模型,Selector中包含select函数,用于向系统内核注册网络编程中的Aceept,Read以及Write等事件,相对于从Java而言,是指channel(不论是服务端还是客户端通道)可以向注册器selector发起注册事件,底层交由<code>select()</code>向操作系统进行事件注册</li>
</ul>
</li>
<li>简要的NIO模型图<br><img src="https://img-blog.csdnimg.cn/20200314174446806.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>基于单线程通道轮询的NIO模式(NIO模型)</p>
</blockquote>
<ul>
<li>这类IO模型与unix下的NIO模型是一致的,就是服务端不断地检查当前的连接状态信息,如果状态信息就绪那么就开始执行相应的处理逻辑</li>
<li>NIO图解模型如下<br><img src="https://img-blog.csdnimg.cn/20200225203847897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>在NIO模型图中,accept不断polling客户端是否有建立连接,如果有客户端连接到服务端,这个时候就会将其转发进行IO操作</li>
<li>部分java示例伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.java</span></span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 设置所有的socket默认伪阻塞,必须设置服务端的通道为非阻塞模式</span></span><br><span class="line">server.configureBlocking(<span class="keyword">false</span>); </span><br><span class="line"><span class="comment">// 绑定端口以及最大可接收的连接数backlog</span></span><br><span class="line">server.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT), MAX_BACKLOG_NUM); </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	SocketChannel client = server.accept();</span><br><span class="line">	<span class="comment">// 非阻塞获取,所以client可能为null</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">null</span> != client)&#123;</span><br><span class="line">		<span class="comment">// 设置客户端的通道为非阻塞</span></span><br><span class="line">		client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 进行IO操作</span></span><br><span class="line">		<span class="comment">// read</span></span><br><span class="line">		ByteBuffer req = ByteBuffer.allocate(MAX_SIZE);</span><br><span class="line">		<span class="keyword">while</span>(client.isOpen() &amp;/&amp; client.read(req)!= -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">// BufferCoding是自己封装的一个解码工具类,结合ByteBuffer与Charset使用,这里不演示代码实现</span></span><br><span class="line">			<span class="comment">// decode</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = BufferCoding.decode(req);</span><br><span class="line">			<span class="keyword">if</span>(data != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// prepared data to send </span></span><br><span class="line">		sentData = process(data);</span><br><span class="line">		<span class="comment">// encode </span></span><br><span class="line">		ByteBuffer sent = BufferCoding.encode(sentData);</span><br><span class="line">		<span class="comment">// write</span></span><br><span class="line">		client.writeAndFlush(sent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析<ul>
<li>上述的代码与BIO的设计基本无差,只是在原有的基础上设置为非阻塞的操作,然后通过不断轮询的方式不断监控连接和读取操作,与BIO的多线程设计差别不大,只是BIO是多线程方式实现,这里是单线程实现</li>
<li>小结:上述代码使用BIO的API方式,也就是说不断polling的过程都是调用阻塞的API去检查是否就绪的状态,结合先前的Unix的IO模型,非阻塞可以继续改进为给予select的方式来实现,而select不是属于调用阻塞式API而是通过事件轮询的方式等待套接字中的描述符变为就绪状态再进行业务处理操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>基于单线程的select事件轮询IO模式(IO多路复用模型)</p>
</blockquote>
<ul>
<li>IO复用模型是通过调用select函数不断轮询获取当前socket的描述符是否就绪,是基于事件的方式实现非阻塞</li>
<li>客户端与服务端都需要注册到selector上,告诉selector当前对哪个描述符感兴趣,再由selector将感兴趣的描述符注册到系统内核中,内核收到一份描述符的数组表,根据网络传输过来的事件告知selector当前对应的描述符的状态信息</li>
<li>其简要的示例图如下<br><img src="https://img-blog.csdnimg.cn/20200225214336286.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>从上述模型可以看出<ul>
<li>服务端启动的时候,首先需要创建channel并注册到selector上才能够监听到客户端建立的连接</li>
<li>其次客户端要与服务端建立通信,也需要在客户端自己创建channel并注册到selector上</li>
<li>当selector监听到客户端的连接就会转发给服务端的Accept事件进行处理</li>
<li>当selector监听到客户端发起请求的操作,就会转发给处理READ事件进行处理,并且如果需要将数据通知客户端,并且在指定的事件上添加写操作</li>
<li>此时selector监听到写操作的时候,就会转发给处理WRITE事件进行处理,并且当前在进行写操作之后取消写操作的事件</li>
</ul>
</li>
<li>java实现的伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.java</span></span><br><span class="line">ServerSocketChannel server = ServerSocketChannel,open();</span><br><span class="line">server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 服务端只注册ACCEPT,作为接入客户端的连接</span></span><br><span class="line"><span class="comment">// DataWrap封装读写缓存ByteBuffer</span></span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT, server);</span><br><span class="line">server.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT), MAX_BACKLOG_NUM); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">int</span> key = selector.select();</span><br><span class="line">	<span class="keyword">if</span>(key == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">// 获取注册到selecor所有感兴趣的事件</span></span><br><span class="line">	Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		SelectionKey key = it.next();</span><br><span class="line">		it.remove();</span><br><span class="line">		<span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">			<span class="comment">// 	接收accept事件</span></span><br><span class="line">			ServerSocketChannel serverChannel = (ServerSocketChannel)key.attachment();</span><br><span class="line">			SocketChannel client = server.accept();</span><br><span class="line">			client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">// 客户端已经获取到连接,告诉客户端的channel可以开始进行读写操作</span></span><br><span class="line">			client.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, <span class="keyword">new</span> DataWrap(<span class="number">256</span>, <span class="number">256</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// read</span></span><br><span class="line">		<span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 在事件中添加写操作</span></span><br><span class="line">			key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key.isWriteable())&#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			<span class="comment">//  成功完成写操作,这个时候取消写操作</span></span><br><span class="line">          	key.interestOps(key.interestOps() &amp; (~SelectionKey.OP_WRITE));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<ul>
<li>上述代码相比第一种方案的实现,主要是采用select函数调用获取注册的事件,阻塞于select事件</li>
<li>另外上述的代码相比第一种稍微更为复杂,操作也更为繁琐</li>
<li>同时两种方式存在的不足都是单线程的方式,在接入层支撑的连接并发量大的时候,并且如果处理的业务复杂且耗时,那么无疑也将会影响到程序的性能,无法快速响应给客户端,同时也会出现短暂的阻塞</li>
</ul>
</li>
</ul>
<blockquote>
<p>基于多线程实现的NIO(Reactor模型)</p>
</blockquote>
<ul>
<li>Reactor模型是参考《Scalable in Java》的文章,目的是为了更好地利用CPU资源将selector监听到事件分别进行相应的分发提高用户响应</li>
<li>Reactor中主要包含selector, channel以及事件SelectionKey,通过不断polling的方式监听客户端的连接,如果有连接进来就将连接转发给Accept,将服务端channel与客户端的channel连接起来,并告知客户端可以进行读写操作</li>
<li>后面在服务端接收到读取事件的时候,就会利用线程池的方式提交任务来处理客户端发过来的请求事件,并准备写数据到缓冲区,并再通知并注册写事件</li>
<li>接收到写事件之后,从缓存区中获取数据并刷新到客户端</li>
<li>Reactor简要图如下<br><img src="https://img-blog.csdnimg.cn/20200314173905118.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>多Reactor模式 + 多线程</p>
</blockquote>
<ul>
<li>(Main)Reactor模型中主要接收服务端以及客户端的注册,其中服务端在启动的时候就注册到Reactor上,而客户端建立连接之前也需要现注册到Reactor中,再由监听到客户端连接的Reactor转发给处理Accept的事件操作,将客户端通道设置非阻塞且建立其可以进行读写的事件监听操作,对于单个而言仍然是在Reactor线程中,而多个Reactor模型中会将当前的客户端连接以及通道转给另一个Reactor进行网络IO操作</li>
<li>对于单个Reactor模型,接收到客户端的请求之后,进行读取然后向线程池提交任务去处理实际业务,在发送给客户端之前向事件注册写事件然后交由Reactor执行写数据到客户端</li>
<li>对于多个Reactor模型.接收到客户端的请求之后,将通过SubReactor读取数据,之后的操作与上述单个Reactor模型流程一致的</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200314173918989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后面会详细写高性能IO编程模型,会再详细讲Reactor以及对应的实现</p>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty组件源码分析</title>
    <url>/2020/04/10/netty01/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="深入Netty组件分析"><a href="#深入Netty组件分析" class="headerlink" title="深入Netty组件分析"></a>深入Netty组件分析</h3><p>讲述netty之前,先看下netty的一个整体结构如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_struct.jpg"></p>
<p>从上述可以看出,netty核心部分主要有基于可扩展性的事件驱动设计模型实现,通用的通信API(支持的网络协议比较丰富)以及基于ByteBuffer实现的零拷贝机制,同时从web的安全性考虑,netty支持SSL/TLS完整协议.</p>
<p>分析Netty的原理之前,我们先看看netty的核心组件有哪些.</p>
<h4 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h4><blockquote>
<p>netty一个简单示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZGROUPSIZE = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZTHREADSIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZGROUPSIZE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZTHREADSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        NettyServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = initServerBootstrap();</span><br><span class="line">        ChannelFuture channelFuture = serverBootstrap.bind(IP, port).sync();</span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerBootstrap <span class="title">initServerBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> TcpServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> serverBootstrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get new client connection &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用之后需要进行释放回到内存池中方便回收,以便于下次使用的时候可重复利用</span></span><br><span class="line">      <span class="comment">// 如果不释放将会产生新的ByteBuff</span></span><br><span class="line">       ((ByteBuf) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">      ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述的一个简单示例,可以看到Netty核心组件主要有:</p>
<ul>
<li>启动类ServerBoostrap</li>
<li>事件轮询类EventLoop以及EventLoopGroup</li>
<li>Netty自身实现的Channel,如上述的NioServerSocketChannel,作为数据传输的载体</li>
<li>Netty自身实现异步操作的ChannelFuture</li>
<li>事件(入站与出站事件)与ChannelHandler</li>
<li>责任链ChannelPipeline与上下文ChannelHandlerContext</li>
<li>ByteBuff组件</li>
</ul>
<h5 id="启动类ServerBoostrap"><a href="#启动类ServerBoostrap" class="headerlink" title="启动类ServerBoostrap"></a>启动类ServerBoostrap</h5><p>通过上述应用程序可以看到,使用到启动类主要有以下方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServerBoostrap类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 添加boss事件轮询以及worker事件轮询</span></span><br><span class="line">  <span class="function">ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加事件源,监听客户端连接</span></span><br><span class="line">  <span class="function">B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加监听事件变化后对事件响应的处理器</span></span><br><span class="line">  <span class="function">ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定服务IP以及端口</span></span><br><span class="line">  <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerBoostrap的类图结构为:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_boostrap.jpg"></p>
<p>根据上述可知,ServerBoostrap类依赖于Netty自身实现的Channel,需要借助Channel来实现数据传输,Channel可以是一个网络输入以及输出的载体通道.</p>
<h5 id="Netty的事件轮询器EventLoop以及轮询器组EventLoopGroup"><a href="#Netty的事件轮询器EventLoop以及轮询器组EventLoopGroup" class="headerlink" title="Netty的事件轮询器EventLoop以及轮询器组EventLoopGroup"></a>Netty的事件轮询器EventLoop以及轮询器组EventLoopGroup</h5><p>基于并发知识经验,有线程与线程组之分,因而可以推测到EvenntLoopGroup的作用主要为了在程序运行过程中可以管理和控制一组处理相同业务操作的EventLoop事件,对此先查看EventLoop的组成结构设计.</p>
<p>EventLoop定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EventLoop是具备有序性,是一个有序事件执行器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoop</span> <span class="keyword">extends</span> <span class="title">OrderedEventExecutor</span>, <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventLoopGroup 是一个事件执行器组,在原有的基础上增强事件功能方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于OrderedEventExecutor,通过查看开发工具查看父类最终也是一个事件执行器组,在原有的基础上增强功能,即EventExecutor</span></span><br><span class="line"><span class="comment">// OrderedEventExecutor -&gt; EventExecutor -&gt; EventExecutorGroup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件执行器具备两个功能:一个是迭代器功能,一个是计划任务的线程池</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">ScheduledExecutorService</span>, <span class="title">Iterable</span>&lt;<span class="title">EventExecutor</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述可知,EventLoop以及EventLoopGroup具备线程池以及迭代器功能,其简要类图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_eventloop.jpg"></p>
<p>结合Reactor模式以及上述的netty代码示例,我们从宏观上看<code>Channel</code>,<code>EventLoop</code>,<code>EventLoopGroup</code>以及<code>Thread</code>之间的关系如下(摘录Netty实战):</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_event_loop_thread.jpg"></p>
<p>对此,可以对<code>EventLoop</code>以及<code>EventLoopGroup</code>的理解如下:</p>
<ul>
<li>EventLoopGroup包含多个EventLoop,每个EventLoop的生命周期绑定一个线程,相当于<code>Thread</code>与<code>ThreadGroup</code>之间的关系,也就是不论是注册还是事件IO完成响应都将会在专有的线程上进行处理.</li>
<li>每个<code>Channel</code>进行注册操作都只能注册于一个<code>EventLoop</code>,但是由于一个<code>EventLoopGroup</code>存在多个<code>EventLoop</code>,因而一个<code>EventLoop</code>可以分配给一个或者多个<code>Channel</code>进行IO相关的事件处理.</li>
</ul>
<p>对于Netty的实现是使用多线程方式来实现一个异步程序上的非阻塞式IO网络编程,同时将IO相关操作与Handler操作分离,真正实现IO操作与业务处理逻辑上的分离,并通过多线程异步的方式来回调唤醒执行IO事件完成操作的handler方法.</p>
<h5 id="Netty自定义的Channel-重点"><a href="#Netty自定义的Channel-重点" class="headerlink" title="Netty自定义的Channel(重点)"></a>Netty自定义的Channel(重点)</h5><p>Channel是Java的NIO的基本构造,Netty在原有的基础上进行方法增强,主要有:</p>
<ul>
<li>对于用户而言具备以下三方面</li>
</ul>
<ol>
<li>提供了channel的当前状态,即连接是open还是connected状态</li>
<li>channel相关的属性配置ChannelConfig,比如channel接收的buffer大小配置</li>
<li>channel支持读取,写出,连接以及绑定的IO操作,与ChannelPipeline一同协作完成所有和Channel相关的IO事件操作,其中ChannelPipeline以责任链的方式连接所有IO事件与Channel相关的请求事件的完成处理器.</li>
</ol>
<ul>
<li>Channel是异步的</li>
</ul>
<p>在netty中所有的IO操作都是以多线程的方式进行异步回调,是属于应用程序上的多线程异步操作,而本质上是使用非阻塞式IO的方式进行调用,在Reactor同步IO操作的基础上更改为异步完成处理操作的方式.类似于Proactor模式,但仍有不同,区分在于Netty的异步调用是在程序中进行回调将事件结果传递给响应的Handler,而Proactor模式是在内核中执行异步操作,异步茶走哦的实现需要借助<code>ChannelFuture</code>组件来通知异步操作的状态(成功/失败/取消).</p>
<ul>
<li>Channel是划分层次的</li>
</ul>
<p>在Netty实现中,客户端<code>SocketChannel</code>是通过服务端的<code>ServerSocketChannel</code>创建的,因此对于SocketChannel的上一个层级父类是<code>ServerSocketChannel</code>,也就是说通过<code>ScoektChannel</code>的<code>parent()</code>方法能够获取到<code>ServerSocketChannel</code>,这个是属于语义上的层次划分</p>
<ul>
<li>支持向下转换以便于于满足特殊传输协议的一些特有的方法</li>
</ul>
<p>比如可以向下转换为<code>DatagramChannel</code>来调用对应的join或者leave方法</p>
<ul>
<li>释放资源</li>
</ul>
<p>很重要一点就是当socket在对应的channel通过完成读写操作时,需要释放所有的资源以便于能够被系统回收.</p>
<h5 id="Netty自定义的ChannelFuture-重点"><a href="#Netty自定义的ChannelFuture-重点" class="headerlink" title="Netty自定义的ChannelFuture(重点)"></a>Netty自定义的ChannelFuture(重点)</h5><p>在并发线程库中,Future类提供了异步操作的实现,通过调用方法返回Future,以异步的方式处理完某个操作之后通知到当前的程序执行位置,由于jdk实现需要手动检测,即<code>future.get()</code>,此时如果操作完成就会返回结果,如果未完成将会同步阻塞于线程等待完成,Netty为了解决这个繁琐的操作,自定义实现了ChannelFuture类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与ChannelFuture相关的</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的ChannelFuture,表示具备可写特征,即客户端获取当前类之后是具备可更改属性操作的.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;&#125;	<span class="comment">// Future为java并发库下</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelPromise</span> <span class="keyword">extends</span> <span class="title">ChannelFuture</span>, <span class="title">Promise</span>&lt;<span class="title">Void</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ChannelFuture使用示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel channel = <span class="keyword">new</span> NioSocketChannel();</span><br><span class="line"><span class="comment">// 以异步的方式与远程服务建立连接</span></span><br><span class="line">ChannelFuture future = channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;192.168.10.110&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(future.future.isSuccess())&#123;</span><br><span class="line">         <span class="comment">// 建立连接成功</span></span><br><span class="line">        </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//建立连接失败</span></span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Channel的生命周期(摘录Netty实战)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_channel_state.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelUnregistered: Channel已将被创建,但是还未被注册到EventLoop组件上</span><br><span class="line">ChannelRegistered: Channel已经被注册到EventLoop组件上</span><br><span class="line">ChannelActive: Channel已经与服务端建立连接状态,处于活跃状态,可以进行发送和写出数据</span><br><span class="line">ChannelInActive: Channel与服务端没有建立连接状态</span><br></pre></td></tr></table></figure>

<h5 id="事件与ChannelHandler-重点"><a href="#事件与ChannelHandler-重点" class="headerlink" title="事件与ChannelHandler(重点)"></a>事件与ChannelHandler(重点)</h5><blockquote>
<p>Netty事件</p>
</blockquote>
<p>Netty网络框架中的事件是按照网络数据流的相关性质来定义区分,主要有入站事件以及出站事件</p>
<ul>
<li><p>Netty入站事件: 主要是入站数据或者是相关状态发生更改而触发的事件,就是socket有新连接或者新请求</p>
<ul>
<li>已经建立连接或者连接失效/超时</li>
<li>数据读取</li>
<li>用户事件,即应用程序给予事件响应完成的处理程序</li>
<li>异常错误事件</li>
</ul>
</li>
<li><p>Netty出站事件: 未来将会触发某个动作的结果,即程序主动向socket底层发起操作</p>
<ul>
<li>打开或者关闭socket远程节点的连接</li>
<li>将数据写出或者刷新到socket缓冲区中</li>
</ul>
</li>
</ul>
<blockquote>
<p>ChannelHandler</p>
</blockquote>
<p>在netty中对事件的响应最终会分发给ChannelHandler进行处理,每个ChannelHandler会通过一个pipeline链的方式连接起来,以下是展示ChannelHandler链式处理入站与出战事件的简要流程.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_channel_handler.jpg"></p>
<p>ChannelHandler在netty源码中主要有包含以下几个内容:</p>
<ul>
<li>交由具体子接口定义出入站事件处理方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 交由具体子接口定义出入站事件处理方法</span></span><br><span class="line"><span class="comment">// ChannelHandler并没有提供很多的方法声明,同时通过上述的入站和出站事件处理,我们也很容易想到ChannelHandler存在处理入站事件的ChannelInboundHandler以及出站事件的ChannelOutboundHandler,同时在netty中默认有对应实现方式</span></span><br><span class="line"><span class="comment">// ChannelInboundHandlerAdapter实现入站事件的处理</span></span><br><span class="line"><span class="comment">// ChannelOutboundHandlerAdapter实现出站事件的处理</span></span><br><span class="line"><span class="comment">// ChannelDuplexHandler能够同时处理入站和出站事件</span></span><br></pre></td></tr></table></figure>

<p>ChannelHandler类图组成结构如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_channelhandler_class.jpg"></p>
<ul>
<li>上下文对象,ChannelHandlerContext</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 上下文对象,ChannelHandlerContext</span></span><br><span class="line"><span class="comment">// 要想在上述ChannelHandler的链式事件处理流程,就必须满足两个条件,一个是如何在每个单独ChannelHandler的处理器传递事件,二是每个ChannelHandler是如何通过链式绑定关联的</span></span><br><span class="line"><span class="comment">// ChannelHandler通过ChannelHandlerContext为每个对应的Handler传递事件,因此ChannelHandler必然存在一个上下文对象负责事件传递,类似于EDA的事件通道</span></span><br><span class="line"><span class="comment">// netty中事件触发就会创建响应事件的ChannelHandler,并添加到ChannelPipeline中,通过链表的数据结构来维护每个Handler之间关联,同时将ChannelPipeline存储在上下文中,可以通过上下文对象获取管道对象</span></span><br></pre></td></tr></table></figure>

<p>ChannelHandler,ChannelHandlerContext以及ChannelPipeline之间的关联如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_channel_handler_dep.jpg"></p>
<ul>
<li>能够存储并管理有状态的信息</li>
</ul>
<p>如果在ChannelHandler定义专属于某一个连接的成员变量数据,即连接需要保持有状态数据,为了防止数据竞争产生数据不一致的问题,必须为每一个连接请求的处理操作创建一个新的handler对象去单独处理,保证业务的数据一致性.比如下面一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现定义一个需求:需要进行登录才能够获取数据,于是就有了以下的定义</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">  <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 存储有状态数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLogined;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Message msg)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(message <span class="keyword">instanceof</span> LoginMessage)&#123;</span><br><span class="line">       auth((LoginMessage)message);</span><br><span class="line">       isLogined = <span class="keyword">true</span>;</span><br><span class="line">  	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(message <span class="keyword">instanceof</span> GetDataMessage)&#123;</span><br><span class="line">       <span class="keyword">if</span>(isLogined)&#123;</span><br><span class="line">          ctx.writeAndFlush(fetchSecret((GetDataMessage) message));</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         fail();</span><br><span class="line">       &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免数据竞争产生数据不一致问题,避免上述需求中的非法登录用户获取到登录数据,必须为每个请求处理连接在提交给handler处理前保证handler是针对当前的连接是1:1的处理方式,即一个连接对应一个channel处理器,对此,需要在添加channel时通过以下的方式进行添加</span></span><br><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    channel.pipeline().addLast(<span class="keyword">new</span> DataServerHandler());</span><br><span class="line">    <span class="comment">// 如果一个连接需要用到多个handler协同处理,则只需要调用addLast添加即可</span></span><br><span class="line">    <span class="comment">// 这样每次有事件发生的时候,对应的一个请求处理连接的事件响应处理都会重新创建handler,即保证每个请求连接的事件响应handler都是新创建的,避免了数据竞争产生的数据不一致问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要保证handler只创建一次,那么就只需要进行调用childHandler添加对应实现的具体Handler实例</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用AttributeKey来存储信息</li>
</ul>
<p>尽管对于存储有状态的信息需要新创建channel去处理它,但是并不是所有情况都是需要创建一个新的handler去处理不同的连接,比如对于通用的共享数据,不存在于不同连接的状态变化,但是为了能够保证共享数据是安全的,为此可以使用AttribuiteKey存储这类数据信息,同时在每个handler中都会有一个上下文对象,而当前的AttributeKey能够通过上下文对象获取到,因此对于AttributeKey的获取在不同handler中可以通过上下文对象来获取,并且为对应的handler添加注解@Sharable能够保证线程是安全的,比如下面例子.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">  <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 存储有状态数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> sharedObject;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Message msg)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;()&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DataServerHandler SHARED = <span class="keyword">new</span> DataServerHandler();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这样保证在处理不同连接的处理链pipeline中存储的handler都是相同的,并且是线程安全的</span></span><br><span class="line">    channel.pipeline().addLast(SHARED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<ul>
<li>注解@Sharable</li>
</ul>
<p>根据上述的AttributeKey分析可知,对于注解为Sharable的说明如下:</p>
<ol>
<li>如果定义的Handler添加注解为@Sharable,则表示Handler在整个处理链pipeline中都是属于无竞争的环境,数据不存在线程安全问题,同时如果是无状态的数据可以通过只创建一次handler实例来完成整个事件处理链pipeline的handler处理.</li>
<li>如果没有添加注解说明,那么为了保证每个handler的共享数据是属于线程安全的,就必须为每次亲戚连接的操作创建新的handler,也就是说不同的连接的事件处理链pipeline存储的handler都是连接特有的,属于连接与handler的1:1模式,这样才能保证数据是线程安全.</li>
</ol>
<ul>
<li>ChannelHandler的方法回调机制</li>
</ul>
<p>Netty设计实现是基于Reactor模式实现,在上文已经模拟Reactor模式的实现原理,可以知道在事件触发之后就会回调执行ChannelHandler实现类中的方法执行响应事件的处理逻辑,即主要回调有以下方法:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_channel_callback.jpg"></p>
<p>根据上述的类图结构,netty默认实现有出站与入站的HandlerAdaper实现,以及含有出站和入站实现的<code>ChannelDuplexHandler</code>,因此在实际使用中可以继承上述相关类来重写部分方法以实现目标业务逻辑的处理程序.</p>
<ul>
<li>ChannelHanlder的生命周期</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handlerAdded: 当ChannelHandler添加到pipeline被调用</span></span><br><span class="line"><span class="comment">// handlerRemoved: 当ChannelHandler从pipeline中移除时被调用</span></span><br><span class="line"><span class="comment">// exceptionCaught: 在处理过程中ChannelPipeline发生异常时被调用</span></span><br></pre></td></tr></table></figure>

<h5 id="责任链ChannelPipeline与处理器上下文ChannelHandlerContext-重点"><a href="#责任链ChannelPipeline与处理器上下文ChannelHandlerContext-重点" class="headerlink" title="责任链ChannelPipeline与处理器上下文ChannelHandlerContext(重点)"></a>责任链ChannelPipeline与处理器上下文ChannelHandlerContext(重点)</h5><p>在讲述一个责任链与上下文对象前,先根据上述的Channel事件处理链pipeline演示一个责任链设计模式的代码实现原理.</p>
<ul>
<li>伪代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链设计:</span></span><br><span class="line"><span class="comment"> *    channel1 -&gt; channel2  -&gt; channel3 -&gt; ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// channel1处理完之后的结果将会传递给channel2进行处理,然后将channel2的处理结果传递给channel3再进行处理,那么什么时候结束呢?</span></span><br><span class="line"><span class="comment">//要么遍历到没有下一个channel节点为止就结束</span></span><br><span class="line"><span class="comment">//要么就是直接在当前节点中断不进行往下传播事件</span></span><br><span class="line"><span class="comment">// 根据netty的channel可知,pipeline需要依赖到一个上下文对象,通过上下文对象来实现责任链的数据传输,于是就有以下的定义.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 类比netty添加方式</span></span><br><span class="line">     HandlerPipeline pipeline = <span class="keyword">new</span> HandlerPipeline();</span><br><span class="line">     pipeline.addLast(<span class="keyword">new</span> HandlerTest());</span><br><span class="line">     pipeline.addLast(<span class="keyword">new</span> HandlerTest());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于链表结构存储handler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerPipeline</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HandlerContext head = <span class="keyword">new</span> HandlerContext(<span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(HandlerContext context, Object val)</span></span>&#123;</span><br><span class="line">        context.nextRun(val);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Handler handler)</span></span>&#123;</span><br><span class="line">     HandlerContext ctx = head;</span><br><span class="line">     <span class="keyword">while</span>(ctx.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">     &#125;</span><br><span class="line">    ctx.next = <span class="keyword">new</span> HandlerContext(handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上下文保存当前handler并传递数据到下一个context进行处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HandlerContext next;</span><br><span class="line">  <span class="keyword">private</span> Handler handler;</span><br><span class="line">  </span><br><span class="line">  HandlerContext(Handler handler)&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextRun</span><span class="params">(Object val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.next.handler(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler.doHandler(<span class="keyword">this</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler处理器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(HandlerContext context, Object val)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerTest</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(HandlerContext context, Object val)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 传播给下一个handler</span></span><br><span class="line">       context.nextRun(val);</span><br><span class="line">      <span class="comment">// 如果不传播,在当前handler停止,就无需调用nextRun方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Netty责任链运作流程</p>
<blockquote>
<p>责任链流程(摘录源码)</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*  +---------------------------------------------------+---------------+</span><br><span class="line">*  |                           ChannelPipeline         |               |</span><br><span class="line">*  |                                                  \|/              |</span><br><span class="line">*  |    +---------------------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  N  |            | Outbound Handler  <span class="number">1</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler N-<span class="number">1</span> |            | Outbound Handler  <span class="number">2</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  .               |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">*  |        [ method call]                       [method call]         |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  |               .                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">2</span>  |            | Outbound Handler M-<span class="number">1</span> |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">1</span>  |            | Outbound Handler  M  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*                  |                                  \|/</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*  |               |                                   |               |</span><br><span class="line">*  |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">*  |                                                                   |</span><br><span class="line">*  |  Netty Internal I/<span class="function">O <span class="title">Threads</span> <span class="params">(Transport Implementation)</span>            |</span></span><br><span class="line"><span class="function">*  +-------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>连接与事件处理链协作流程简要流程图</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_pipeline_context.jpg"></p>
<ul>
<li>Netty之ChannelPipeline源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.pipeline的创建</span></span><br><span class="line"><span class="comment">// 每个Channel都有自己的pipeline,并且当一个新的channel被创建的时候会自动创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 责任链流程 -- 见上述责任链流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. pipeline在上下文进行事件传播的方法</span></span><br><span class="line"><span class="comment">// 入站事件与出站事件</span></span><br><span class="line"> <span class="comment">/* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   * &lt;li&gt;Inbound event propagation methods:</span></span><br><span class="line"><span class="comment">   *     &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelRegistered()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelActive()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelRead(Object)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelReadComplete()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireExceptionCaught(Throwable)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireUserEventTriggered(Object)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelWritabilityChanged()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelInactive()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelUnregistered()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;li&gt;Outbound event propagation methods:</span></span><br><span class="line"><span class="comment">   *     &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#write(Object, ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#flush()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#read()&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#disconnect(ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#close(ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;li&gt;&#123;@link ChannelHandlerContext#deregister(ChannelPromise)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   *     &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/li&gt;</span></span><br><span class="line"><span class="comment">   * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 构建一个ChannelPipeline</span></span><br><span class="line"><span class="comment">// 当我们的web服务为每个请求处理对应的decode-process-encode时,对于执行比较耗时的操作需要将线程隔离处理,也就是需要有针对Group对process进行处理,而其他线程仍然可以处理decode以及encode非耗时逻辑,可以通过以下的方式:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> EventExecutorGroup group = <span class="keyword">new</span> DefaultEventExecutorGroup();</span><br><span class="line">pipeline = ch.pipeline();</span><br><span class="line">pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> MyProtocolDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> MyProtocolEncoder());</span><br><span class="line"><span class="comment">// 这个时候的process处理会单独放在以下的group进行处理</span></span><br><span class="line">pipeline.addLast(group, <span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> MyBusinessLogicHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. ChannelPipeline是属于线程安全类</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Netty之ChannelHandlerContext源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 通过唤醒回调后在pipeline流程链中向不同的handler传递信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 上下文存储的数据可以实现事件触发执行传递到不同的handler方法中,甚至可以是在不同线程中实现数据的共享,比如以下代码:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span></span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 可以在添加到pipeline之前保存ctx信息</span></span><br><span class="line">       <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, password)</span> </span>&#123;</span><br><span class="line">     		<span class="comment">// 将保存的ctx存储登录信息并将登录信息传递到责任链pipeline下后续的handler获取使用</span></span><br><span class="line">        ctx.write(<span class="keyword">new</span> LoginMessage(username, password));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 存储有状态的信息,详细可以查看上述的ChannelHandler使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 一个handler可以拥有多个context信息,因为一个handler可以添加到一个或者多个pipeline中,而每个pipeline都会对应着一个context,因而一个handler是可以拥有一个或者多个context,比如计算handler被添加到pipeline的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AttributeKey&lt;Integer&gt; counter = AttributeKey.valueOf(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">      Integer a = ctx.attr(counter).get();</span><br><span class="line">      <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     attr.set(a * (Integer)msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面将会进行4次计数器的计算,也就是一个handler实例添加到不同或者相同的active的pipeline中,其上下文对象是不一样的</span></span><br><span class="line">ChannelPipeline p1 = channel.pipeline();</span><br><span class="line">p1.addLast(<span class="string">&quot;f1&quot;</span>, fh);</span><br><span class="line">p1.addLast(<span class="string">&quot;f2&quot;</span>, fh);</span><br><span class="line"></span><br><span class="line">ChannelPipeline p2 = channel.pipeline();</span><br><span class="line">p1.addLast(<span class="string">&quot;f3&quot;</span>, fh);</span><br><span class="line">p1.addLast(<span class="string">&quot;f4&quot;</span>, fh);</span><br></pre></td></tr></table></figure>

<h5 id="ByteBuf组件-重点"><a href="#ByteBuf组件-重点" class="headerlink" title="ByteBuf组件(重点)"></a>ByteBuf组件(重点)</h5><blockquote>
<p>支持的API</p>
</blockquote>
<ul>
<li>可以被用户自定义的缓冲区扩展</li>
<li>通过内置的复合缓冲区实现透明的零拷贝</li>
<li>容量可以按需增长</li>
<li>拥有readerIndex与writeIndex,因而在读写之间不需要像NIO的ByteBuffer通过flip()方法进行切换</li>
<li>支持方法的链式调用</li>
<li>支持引用计数</li>
<li>使用池化技术</li>
</ul>
<blockquote>
<p>工作原理</p>
</blockquote>
<p>存在两个索引,一个是读取索引,一个写入索引,当使用ByteBuf调用read方法的时候,readIndex将会向前移动,即readIndex+1,同样地,对于写入数据的时候,对应的writeIndex也会增加,当<code>readIndex==writeIndex</code>也就意味着读取数据达到数组的末尾,再次进行读取时会发生IndexOutOfBoundsException,而对于<code>writeIndex==Capacity</code>即ByteBuf的容量大小时也会发生下标越界异常,名称以read或者write将会推进对应的索引数值,而名称以set或者get的方法调用时将不会对读取或者写入索引进行递增操作.</p>
<blockquote>
<p>字节级源码分析</p>
</blockquote>
<ul>
<li>随机访问: <code>ByteBuf</code>类似于一个字节数组,于数组索引具备相同的特征,即下标从0开始,以<code>capacity - 1</code>的下标为末尾索引,可以按照数组的方式对其通过下标随机访问,此时对于拥有readerIndex以及writeIndex值是不变,但可以通过调用<code>readerIndex(index)</code>或者<code>writeIndex(index)</code>来更改对应的索引值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); i++)&#123;</span><br><span class="line">   <span class="keyword">byte</span> b = buffer.getByte(i);</span><br><span class="line">   logger.info(<span class="string">&quot;char s is &quot;</span> + (<span class="keyword">char</span>)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序访问: 主要是通过<code>readerIndex</code>以及<code>writeIndex</code>两个索引值指针实现顺序访问,对于<code>ByteBuf</code>的顺序访问存在丢弃字节,可读字节以及可写字节的概念,对此摘录源码分析如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      | discardable bytes |  readable bytes  |  writable bytes  |</span></span><br><span class="line"><span class="comment"> *      |                   |     (CONTENT)    |                  |</span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      |                   |                  |                  |</span></span><br><span class="line"><span class="comment"> *      0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span></span><br><span class="line"><span class="comment"> *.   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 可读字节区域: 代表ByteBuf还未读取到ByteBuf的数据区域,在netty的ByteBuf中以read或者skip开头的读取数据的方法都会在指针readerIndex实现计数的自增加操作,对于可读指针取值范围: 0&lt;=readerIndex&lt;=writeIndex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写字节区域: 代表从writeIndex - capacity之间的区域为空闲区域,能够继续存储数据来填充区域,如果满足writeIndex &lt; capacity代表该ByteBuf拥有足够的区域进行写入数据.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢弃的字节区域: 表示已经被读取过的ByteBuf片段区域,初始化状态的时候,区域大小为0,如果数据一直在被读取,那么对应的区域大小会增加到writeIndex,也就是对于该区域满足: 0&lt;= size &lt;= writeIndex.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用discardReadBytes()方法的区域变化:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  BEFORE discardReadBytes()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      | discardable bytes |  readable bytes  |  writable bytes  |</span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      |                   |                  |                  |</span></span><br><span class="line"><span class="comment"> *      0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  AFTER discardReadBytes()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      +------------------+--------------------------------------+</span></span><br><span class="line"><span class="comment"> *      |  readable bytes  |    writable bytes (got more space)   |</span></span><br><span class="line"><span class="comment"> *      +------------------+--------------------------------------+</span></span><br><span class="line"><span class="comment"> *      |                  |                                      |</span></span><br><span class="line"><span class="comment"> * readerIndex (0) &lt;= writerIndex (decreased)        &lt;=        capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字节清除方法<code>clear</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于清除方法直接通过查看区域的变化即可</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  BEFORE clear()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      | discardable bytes |  readable bytes  |  writable bytes  |</span></span><br><span class="line"><span class="comment"> *      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="comment"> *      |                   |                  |                  |</span></span><br><span class="line"><span class="comment"> *      0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  AFTER clear()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      +---------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> *      |             writable bytes (got more space)             |</span></span><br><span class="line"><span class="comment"> *      +---------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> *      |                                                         |</span></span><br><span class="line"><span class="comment"> *      0 = readerIndex = writerIndex            &lt;=            capacity</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>搜索操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于一些普通字节的查询,可以调用indexOf(int, int, byte)或者是bytesBefore(int, int, byte)完成,bytesBefore这个方法尤其对于以一些特殊字符结尾的字符串尤其有用.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于更为复杂的操作,比较存在不同系统的特殊符号查询,可以通过ByteProcessor接口指定查询特定的符号内容,调用forEachByte(int, int, ByteProcessor)方法完成字节的搜索</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Derived Buffers(派生缓冲区)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过以下的方法创建一个新的ByteBuf缓冲区,每个派生出来的缓冲区都拥有自己的readerIndex,writeIndex以及标记索引,与NIO的buffer议案具备数据共享,因而当派生的缓冲区数据发生变化的时候,对应的源缓冲区也会发生变化.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要让数据不具备共享,可以通过使用copy()方法来实现一个新的数据副本,这个时候与派生的数据缓冲区区分在于copy()拥有独立的数据副本信息,可以通过以下的图示来分析,假设现在申请的一块源bytebuf是使用堆外内存存储数据的方式(堆内内存也是同理),这个时候派生的缓冲与copy的缓冲内存区域分布如下:</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_byte_silce_copy.jpg"></p>
<p>通过上述可知,在JVM堆内存中创建ByteBuf对象,分别指向对应数据存储的区域,对于Java程序而言,派生缓冲区对象在JVM中创建ByteBuf对象指向原有存储数据的内存区域,因而对于派生的缓冲区的数据如果发生变化,对应的源缓冲区数据也会发生变化,相比使用copy()的申请数据一份新的数据副本方式,减少了数据内存的复制操作,避免更多的内存占用冗余的数据.</p>
<ul>
<li>Netty的ByteBuf转换为JDK存在的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 转换为byte[]</span></span><br><span class="line"><span class="keyword">if</span>(byteBuff.hasArray())&#123;</span><br><span class="line">   <span class="keyword">byte</span>[] byteArr = byteBuff.array();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 转换为NIO的Buffers</span></span><br><span class="line"><span class="keyword">if</span>(byteBuff.nioBufferCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">   ByteBuffer nioByteBuffer = byteBuff.nioBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 转换为String</span></span><br><span class="line">String str = byteBuff.toString(Charset.forName(<span class="string">&quot;utf8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 转换为IO的字节流</span></span><br><span class="line">ByteBufInputStream in = <span class="keyword">new</span> ByteBufInputStream(byteBuff);</span><br><span class="line">ByteBufOutputStream out = <span class="keyword">new</span> ByteBufOutputStream(byteBuff);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ByteBuff使用模式</p>
</blockquote>
<ul>
<li>使用堆缓冲区</li>
</ul>
<p>将数据存储在JVM堆内存中,也就是从JVM的内存中申请内存区域来存放ByteBuff数据,这种模式称为支撑数组(Backing Array)</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_byte_buff_heap.jpg"></p>
<p>通过上述可知,在Java程序进行网络IO数据传输的时候,对于存储在堆内存的缓冲数据,不论是读取还是写入数据,都需要经过JVM堆内缓冲,然后将数据复制到操作系统内存的一块区域中,最后在刷新到网卡设备的时候,需要将内存数据复制到socket缓冲区再进行数据刷新.</p>
<ul>
<li>使用堆外缓冲区</li>
</ul>
<p>直接从操作系统中申请内存区域来存储ByteBuff数据,但是分配和释放内存相对会更为昂贵,同时如果这个时候不知道时候用于数组相关的数据操作而使用堆外内存的缓冲数据,那么这个时候就需要进行一次数据内存的复制,相比堆内存操作更为复杂.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现在有一数组数据</span></span><br><span class="line"><span class="keyword">byte</span>[] arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 这个时候要发送数据出去,可考虑使用堆外内存数据缓冲,避免数据缓冲多一次内存复制,将数据发送到网卡中</span></span><br><span class="line"><span class="comment">// 接收网卡数据的时候,如果这个时候知道接收的数据为数组且需要堆数组数据进行遍历,那么这个时候直接使用堆外内存存储,还需要再进行一次数据内容的复制,而如果使用堆内内存存储,直接可以通过直接获取到数据转换为数组进行操作</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_byte_buff_direct.jpg"></p>
<ul>
<li>复合缓冲区(零拷贝机制)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_compiste_byte_buff.jpg"></p>
<p>通过上述可知,复合缓冲区是将不同存储物理位置的缓冲区数据合并为单个缓冲区的虚拟表示,属于逻辑上述的缓冲区的数据合并,由此可知,如果程序中需要将一块有关联但存储物理位置不同的缓冲区数据进行一起操作的话,可以使用复合缓冲区方式将多个缓冲区数据进行合并,这个时候不存在数据的复制,即零拷贝机制,实现多个缓冲区数据合并为单个缓冲区,可以视为单个缓冲区进行操作.</p>
<blockquote>
<p>ByteBuff核心类图</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_byte_buff_class.jpg"></p>
<p>通过上述类图结构可知,ByteBuff划分为三个维度,即</p>
<ul>
<li>存储方面: 使用堆内与堆外内存存储</li>
<li>资源利用技术: 使用非池化与池化技术,池化技术与内存管理将在讲netty高性能会详细说明</li>
<li>直接通过底层操作内存: Unsafe操作</li>
</ul>
<blockquote>
<p>使用ByteBufHolder接口</p>
</blockquote>
<p>在一个web服务程序中,如果能够将一个http请求(请求头/请求体/状态码/cookie等信息)都封装一起以包的形式进行接收或者发送,那么对程序开发者而言将会带来很多的便利,对此,在netty框架提供了ByteBufHolder接口来存储ByteBuf之外的属性信息,同样提供了缓冲池化,底层访问数据以及引用计数的方法.对于网络编程中实现自定义的消息协议,可以采用ByteBufHolder接口来有效承载消息的信息.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_bufholder.jpg"></p>
<p>通过上述可知,ByteBuf具备引用计数(后续在高性能会写到)特性,能够在资源不被对象所持有时释放来优化内存使用和性能的技术.</p>
<blockquote>
<p>ByteBuf内存分配策略</p>
</blockquote>
<ul>
<li>按需分配:ByteBufAllocator接口</li>
</ul>
<p>主要实现类有池化与非池化技术实现UnpooledByteBufAllocator以及PooledByteBufAllocator类,netty默认使用使用PooledByteBufAllocator实现池化的ByteBuf,但是对于默认也存在以下的规则:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认创建池化且为堆外内存存储的ByteBuf,如果当前环境支持Unsafe底层操作,那么默认就会使用Unsafe+堆外存储+池化技术方式来创建ByteBuf</span></span><br><span class="line"><span class="comment">// 如果显示使用PreferHeapByteBufAllocator方式进行分配,则会创建堆内数据存储的ByteBuf</span></span><br></pre></td></tr></table></figure>

<p>ByteBufAllocator的类图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_bytebuf_allocation.jpg"></p>
<ul>
<li>Unpooled分配ByteBuf工具类</li>
</ul>
<p>对上述的ByteBufAllocator进一步封装,对外提供操作的工具类,关于核心API直接摘录《Netty实战》书籍:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/netty_unpooled.jpg"></p>
<ul>
<li>ByteBufUtil操作ByteBuf工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line"><span class="comment">// 1. hexDump: 以16进制形式打印ByteBuf内容</span></span><br><span class="line"><span class="comment">// ByteBuf内容为: [0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"><span class="comment">// 16进制打印出来的数据为: 00 00 00 01 02 03 04 05 06 07 08 09 0a 0b </span></span><br><span class="line"><span class="comment">// (空格是手动加的,实际为: 0000000102030405060708090a0b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较两个ByteBuf的存储的数据是否一致(内存 + 数据大小)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Netty事件流程分析(上)</title>
    <url>/2020/04/19/netty02/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="Netty框架核心内容"><a href="#Netty框架核心内容" class="headerlink" title="Netty框架核心内容"></a>Netty框架核心内容</h4><h5 id="丰富的Buffer数据结构"><a href="#丰富的Buffer数据结构" class="headerlink" title="丰富的Buffer数据结构"></a>丰富的Buffer数据结构</h5><p>Netty在NIO的ByteBuffer基础上自定义一套自己的Buffer API,其实现的Buffer API具备以下特性:</p>
<ul>
<li>如果需要可以自定义自己的buffer类型</li>
<li>内建composite buffer类型实现零拷贝机制(无需在内存实现数据复制)</li>
<li>可以支持动态扩容,类似于StringBuffer</li>
<li>不需要像NIO的Buffer需要每次调用flip(),Netty实现的Buffer通过readerIndex以及writeIndex避免flip()调用</li>
<li>通常会比ByteBuffer在性能上更好</li>
</ul>
<p>零拷贝示例,通过分割与组合:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设buffer1以及buffer2都存储在堆外内存,堆内内存同理(只是在JVM中)</span></span><br><span class="line">ByteBuf httpHeader = buffer1.silice(OFFSET_PAYLOAD, buffer1.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line">ByteBuf httpBody = buffer2.silice(OFFSET_PAYLOAD, buffer2.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line"></span><br><span class="line">ByteBuf http = ChannelBuffers.wrappedBuffer(httpHeader, httpBody);</span><br></pre></td></tr></table></figure>

<p>上述的零拷贝示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/zero_copy.jpg"></p>
<h5 id="使用异步IO的API"><a href="#使用异步IO的API" class="headerlink" title="使用异步IO的API"></a>使用异步IO的API</h5><ul>
<li>基于TCP/IP的NIO模式</li>
<li>基于TCP/IP的BIO模式</li>
<li>基于UDP/IP的BIO模式</li>
</ul>
<h5 id="基于事件驱动设计的责任链设计"><a href="#基于事件驱动设计的责任链设计" class="headerlink" title="基于事件驱动设计的责任链设计"></a>基于事件驱动设计的责任链设计</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/pipeline.jpg"></p>
<h5 id="支持特性组件-简化开发"><a href="#支持特性组件-简化开发" class="headerlink" title="支持特性组件,简化开发"></a>支持特性组件,简化开发</h5><ul>
<li>支持SSL/TLS安全协议</li>
<li>HTTP/WebSocket协议的实现</li>
<li>支持Google的Protocol协议</li>
<li>支持编解码器,Netty也有内置一些编解码器实现</li>
</ul>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>讲述Netty线程模型之前,摘录Netty官网的描述:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance and high-scalability protocol servers and clients.</span><br></pre></td></tr></table></figure>

<p>从上述官网可得到以下的信息:</p>
<ul>
<li>Netty是基于EDA事件驱动架构设计实现</li>
<li>Netty采用异步方式来完成事件通知,完成事件之后会进行回调唤醒Handler,可以理解为Proactor模式,或者是多线程异步执行的Reactor模型.</li>
<li>Netty是一个高性能高扩展性的web服务框架,可以在不影响性能情况快速实现web服务的开发</li>
</ul>
<p>在Netty组件分析中,EventLoop是一个线程池执行器,同时对于长时间的耗时Handler操作,会额外分配一个线程池执行器来负责处理handler相关的业务逻辑,于是基于Reactor/Proactor模型可知,Netty的一个线程模型如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/thread_model.jpg"></p>
<h4 id="Netty事件流程"><a href="#Netty事件流程" class="headerlink" title="Netty事件流程"></a>Netty事件流程</h4><p>基于上述的Netty线程模型的理解,现摘录官网的一个EchoServer例子来深入分析Netty事件流程,对应的EchoServer代码示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅摘录部分核心代码</span></span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline p = ch.pipeline();</span><br><span class="line">        <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">        <span class="comment">// 将处理读写事件的handler添加到责任链中</span></span><br><span class="line">        p.addLast(serverHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the server.</span></span><br><span class="line">  ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">  f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">  bossGroup.shutdownGracefully();</span><br><span class="line">  workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述的代码示例,其运作的核心流程如下:</p>
<ul>
<li>初始化Boss以及Worker的事件轮询NioEventLoop线程,即Reactor线程</li>
<li>创建服务启动类ServerBootsrtap</li>
<li>将Boss以及Worker的Reactor线程添加到服务启动类中</li>
<li>服务启动类创建并注册服务端的Channel</li>
<li>服务启动类为服务端的Channel配置可选属性</li>
<li>服务启动类添加一个通用共享且日志级别为INFO的处理器并应用在整个Netty的pipeline</li>
<li>基于之前的Channel组件分析,我们知道childChannel也就是对应客户端的SocketChannel,这个时候是服务启动类为SocketChannel添加一个初始化的Handler,并在后续基于事件触发完成之后执行责任链下的handler回调</li>
<li>至此,一系列的初始化操作完成,这个时候服务启动类开始为ServerChannel绑定端口开始对客户端连接进行监听</li>
<li>关闭连接的监听以及销毁Reactor线程释放空间</li>
</ul>
<p>对此,基于上述给出的完整服务端流程,现对上述流程结合源码进行分析与总结.</p>
<h5 id="EventLoopGroup与EventLoop初始化流程"><a href="#EventLoopGroup与EventLoop初始化流程" class="headerlink" title="EventLoopGroup与EventLoop初始化流程"></a>EventLoopGroup与EventLoop初始化流程</h5><blockquote>
<p>EventLoopGroup初始化流程</p>
</blockquote>
<ul>
<li>NioEventLoopGroup类图结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloopgroup_class.jpg"></p>
<ul>
<li>EventLoopGroup初始化源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NioEventLoopGroup构造器 </span></span><br><span class="line"><span class="comment">// NioEventLoopGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认使用阻塞式轮询策略</span></span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());   <span class="comment">// channel处理不过来的时候直接丢弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认线程数量为CPU*2 或者是通过 io.netty.eventLoopThreads进行配置</span></span><br><span class="line">  <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建默认事件执行选择器(从Group中选择一个EventLoop来处理Channel的策略选择器)</span></span><br><span class="line">  <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Group的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述可以看到初始化创建默认具备线程池的一些默认策略(线程大小/线程工厂/存储任务队列/丢弃策略)/创建默认的事件轮询选择器/默认的IO复用器提供者</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EventLoopGroup初始化的核心流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloopGroup_init.jpg"></p>
<p>根据上述可以知道,EventLoopGroup初始化的操作主要是初始化一组EventLoop的执行器,并创建选举EventLoop的选择器,并为每个EventLoop在销毁的时候添加监听器以便于程序能够获取当前EventLoop销毁情况,同时每个EventLoop对外提供服务都是只读模式,也就是选举EventLoop都是处于只读的稳定版本.</p>
<blockquote>
<p>EventLoop的创建流程</p>
</blockquote>
<p>EventLoop的创建流程包含在上述EventLoopGroup为每个执行器(EventLoop)进行初始化的过程,即在源代码中如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="comment">// 初始化执行器</span></span><br><span class="line">children[i] = newChild(executor, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// newChild的实现子类NioEventLoopGroup</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">                          ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">             EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">  <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),</span><br><span class="line">        rejectedExecutionHandler);</span><br><span class="line">  <span class="keyword">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">  <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">  <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">  <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EventLoop的初始化流程</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_init.jpg"></p>
<p>基于上述的EventLoopGroup与EventLoop的认知,我们来总结下EventLoopGroup,EventLoop,EventExecutor以及Thread之间的关系,首先先从源码开始分析如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="comment">// ThreadPerTaskExecutor看成线程池 - 对应默认的线程工厂类</span></span><br><span class="line">executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有多少个线程就有多少个EventLoop</span></span><br><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用线程池创建EventLoop</span></span><br><span class="line">children[i] = newChild(executor, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleThreadEventExecutor.java</span></span><br><span class="line"><span class="comment">// this为NioEventLoop</span></span><br><span class="line"><span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadExecutorMap.java</span></span><br><span class="line"><span class="comment">// 创建新的执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Executor executor, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// check not null ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ThreadPerTaskExecutor.execute -&gt; apply</span></span><br><span class="line">      <span class="comment">// 启动一个线程执行任务并传递事件轮询器</span></span><br><span class="line">      <span class="comment">// FastThreadLocalThread.run()</span></span><br><span class="line">      executor.execute(apply(command, eventExecutor));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新任务Task</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Runnable command, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(command, <span class="string">&quot;command&quot;</span>);</span><br><span class="line">  ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将EventLoop存储到FastThreadLocal(即保证FastThreadLocalThread独占持有自己的EventLoop)</span></span><br><span class="line">      setCurrentEventExecutor(eventExecutor);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        command.run();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务执行完之后释放独占EventLoop的资源</span></span><br><span class="line">        setCurrentEventExecutor(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentEventExecutor</span><span class="params">(EventExecutor executor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用FastThreadLocal来存储事件轮询器，保证每个事件轮询器都会有对应的一个线程来处理</span></span><br><span class="line">  mappings.set(executor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过上述的流程可知,在每个EventLoop都含有一个新的Executor</span></span><br><span class="line"><span class="comment">// 而每一个Executor都通过默认的线程工厂创建一个FastThreadLocalThread线程来处理task任务</span></span><br><span class="line"><span class="comment">// 此时的Task任务为一个新的任务task</span></span><br></pre></td></tr></table></figure>

<p>通过源码分析,可以得到以下简要的EventLoopGroup,Group下的线程池Executor,EventLoop与EventLoop下的Executor以及Thread之间的关系如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread.jpg"></p>
<p>通过上述示意图可知,每个EventLoop处理任务时都会通过Group下的Executor来创建对应的线程来执行EventLoop的事件任务,并且为了保证并发安全问题,在每次处理任务之前,将会把当前的EventLoop与Thread进行绑定,也就是当前EventLoop为当前执行的线程Thread所独占持有,通过FastThreadLocal来维护两者之间的关系,一旦EventLoop事件任务处理完成之后,将解除两者的绑定.同时也可以看到处理一组事件任务的Thread将通过线程组的方式进行维护和管理.</p>
<blockquote>
<p>Netty线程模型细化</p>
</blockquote>
<p>可以看到上述一个EventLoop绑定一个专有的线程,由专有的线程负责处理EventLoop的事件,且一个channel都会对应着一个EventLoop来负责处理channel相关的事件,同时一个EventLoop/Thread能够处理多个Channel需要依赖于AIO或者是NIO的API才能实现,AbstractBootstrap处理服务端Channel,ServerBootstrap处理客户端Channel,而对于BIO模型而言,只能一个EventLoop/Thread处理对应一个Channel,即摘录《Netty实战》关于NIO/OIO(old IO,BIO)模型如下:</p>
<ul>
<li>基于NIO/AIO的线程模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread_channel.jpg"></p>
<ul>
<li>基于BIO的线程模型(OIO为old IO,即使用BIO的API)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/group_thread_bio_channel.jpg"></p>
<ul>
<li>EventLoop启动任务的执行源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用以下的方法时执行流程</span></span><br><span class="line"><span class="comment">// SingleThreadEventExecutor.java</span></span><br><span class="line">eventLoop.execute(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的线程执行流程不弄清楚,后面的事件流程将很理解</span></span><br><span class="line"><span class="comment">// 根据类设计可知,execute为SingleThreadEventExecutor下的方法,结合上面的EventLoop初始化流程可知,每个EventLoop都拥有一个内置的Executor,而这个Executor用于创建FastThreadLocalThread线程来保证当前eventloop与当前线程之间的绑定关联,源码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断当前执行的线程是否与eventloop对应(EventLoop - Thread绑定一起）</span></span><br><span class="line">  <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">  <span class="comment">// 将任务添加到队列中,如果队列满则丢弃当前任务</span></span><br><span class="line">  addTask(task);</span><br><span class="line">  <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">    <span class="comment">// 启动一个线程,如果当前EventLoop持有的线程已经开启过则直接跳过,如果开启过线程,则执行doStartThread方法</span></span><br><span class="line">    startThread();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// EventLoop持有的executor来创建一个FastThreadLocalThread线程,在该线程中保证当前事件轮询器与线程处于线程安全,通过FastThreadLocal将线程与EventLoop进行关联</span></span><br><span class="line">  executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    	<span class="comment">//....</span></span><br><span class="line">  &#125;);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合EventLoop初始化对应的executor以及ThreadExecutorMap中的源码,现将一个不在当前线程的EventLoop提交任务时创建一个完整线程执行细节流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_thread_detail.jpg"></p>
<p>也就是说,最终处理任务task都在NioEventLoop执行的run方法中体现,或者更为严格意义上来取决于我们选择的EventLoop的IO操作模式,具体是交由EventLoop的IO操作模式的run方法通过队列中获取任务来进行处理,于是根据源码中提供的任务队列与拒绝策略,对于EventLoop处理任务的流程如下(摘录自《Netty实战》):</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_task_nettyinaction.jpg"></p>
<ul>
<li>与线程池不一样的是,EventLoop是与指定的线程绑定在一起,也就是一个线程处理一个EventLoop,并且在整个Web服务中EventLoop始终是由当前的专有线程负责事件的任务的处理</li>
<li>当添加任务到EventLoop执行的时候,需要校验当前的线程是不是持有之前分配好的EventLoop,如果不是那么就添加到任务队列进行等待EventLoop下一次处理事件时再执行,如果队列满了,那么此时就会触发拒绝策略丢弃任务,如果是之前分配好的EventLoop那么就会直接执行任务Task.</li>
</ul>
<blockquote>
<p>Netty之NIO事件轮询流程</p>
</blockquote>
<p>基于上述的线程任务流程分析之后,我们知道在EventLoop中最终会调用NioEventLoop下的run方法,对此,现该run方法执行的事件轮询操作流程进行分析.</p>
<ul>
<li>事件轮询源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.run()核心代码</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  	<span class="comment">// 检测当前的EventLoop的队列中是否有任务</span></span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">      strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 根据服务器配置eventloop的IO处理能力比率</span></span><br><span class="line">  <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果IO处理比率高，则同时处理就绪事件以及当前轮询器队列中的所有任务</span></span><br><span class="line">    <span class="comment">// 不然就分开处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理一系列的就绪事件</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">      <span class="comment">// 执行所有的任务</span></span><br><span class="line">      ranTasks = runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理就绪事件,处理ACCEPT/READ/WRITE事件</span></span><br><span class="line">      processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 在一定事件内处理队列中的任务</span></span><br><span class="line">      <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">      ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">    ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">  &#125;             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop的unsafe为NioMessageUnsafe</span></span><br><span class="line">processSelectedKeys()&#123;</span><br><span class="line">  <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">    unsafe.finishConnect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runAllTasks</span></span><br><span class="line">runAllTasks()&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) &#123;</span><br><span class="line">      ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!fetchedAll); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runAllTasksFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>&#123;</span><br><span class="line">  Runnable task = pollTaskFrom(taskQueue);</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 在当前EventLoop所在的线程执行run方法</span></span><br><span class="line">    <span class="comment">// task.run();</span></span><br><span class="line">    safeExecute(task);</span><br><span class="line">    task = pollTaskFrom(taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件轮询流程图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/eventloop_run.jpg"></p>
<h5 id="SeverBootstrap初始化流程"><a href="#SeverBootstrap初始化流程" class="headerlink" title="SeverBootstrap初始化流程"></a>SeverBootstrap初始化流程</h5><blockquote>
<p>Netty组件初始化流程</p>
</blockquote>
<p>在分析启动类初始化之前,我们先来查看下启动类的类图结构设计</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/boostrap_class.jpg"></p>
<p>根据类图结构,启动类比较简单,同时关于启动类的详细已经在先前组件分析过,现来看下启动类初始化Netty相关组件的源码</p>
<ul>
<li>EventLoopGroup添加到启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServerBootsrtap.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.group = group;</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上述可知并结合多Reactor模式可知</span></span><br><span class="line"><span class="comment">// ServerBootstrap持有childGroup,用于处理socketChannel的读写事件</span></span><br><span class="line"><span class="comment">// AbstractBootstrap持有parentGroup,用于处理serverChannel的accept事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将服务端的Channel类对象以及服务端配置添加到启动类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="comment">// 创建一个服务端的ServerChannel并指定其BACKLOG大小为100</span></span><br><span class="line">bootstrap.channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 通过传递的服务端Channel构造一个Channel创建工厂类,用于后续构建服务端的Channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">    ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端Channel的配置存储到容器Map中</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(option, <span class="string">&quot;option&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      options.remove(option);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      options.put(option, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将处理服务端的Handler添加到启动类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口程序类</span></span><br><span class="line">bootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 当前的服务端channelHandler存在于AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handler = ObjectUtil.checkNotNull(handler, <span class="string">&quot;handler&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将处理客户端channelHandler添加到启动类</li>
</ul>
<p>由于服务端程序启动服务端Channel之后会监听客户端SocketChannel的连接,一旦有连接进来这个时候就会注册绑定客户端的SocketChannel并监听读写事件,对此,对于使用Netty框架的服务端程序而言只需要关注处理读写事件的Handler即可,由于先前在组件源码分析中已经说明到,ServerChannel是作为客户端SocketChannel的语义层次上的父类,于是对于handler我们也可以理解childHandler是处理客户端读写事件的handler的处理器,其对应的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口类程序</span></span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; </span><br><span class="line">  <span class="comment">// 保证每一个socket channel都会对应着一个自己的channel handler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = ch.pipeline();</span><br><span class="line">    <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">      p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">    &#125;</span><br><span class="line">    p.addLast(serverHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// ServerBootstrap.java</span></span><br><span class="line"><span class="comment">// 将上述的childHandler绑定到ServerBootstrap,为ServerBootstrap所持有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.childHandler = ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Bootstrap初始化</li>
</ul>
<p>基于上述添加EventLoopGroup以及ChannelHandler,我们再来看下Bootsrtap启动类初始化的时候做了什么事情.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口程序</span></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上述执行初始化流程中,会在内部完成以下组件的初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>结合之前组件分析,我们知道Channel是存在语义上的层次关系,对此,我们关注ServerBootstrap与ServerBootstrapConfig, AbstractBootstrap与AbstractBootstrapConfig之间分别获取channel信息的区分,其类图组件如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_config_class.jpg"></p>
<p>通过上述的类图可以知道,ServerBootsrtap与SocketChannel进行关联,AbstractServerBootstrap与ServerSocketChannel进行关联,对于channel,ServerSocketChannel与SocketChannel是层次上的父子关系,对于Bootsrap类抑或是Config类,均通过子类获取与SocketChannel相关的信息,通过父类获取与ServerSocketChannel相关信息,层次划分明确,现将Bootstrap构造初始化操作事件流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_flow.jpg"></p>
<p>我们知道在Netty框架在处理服务端与客户端的事件是划分层次的,在语义层次上,服务端属于“父类”,客户端属于“子类”,两者之间的事件所依赖的组件也在语义上划分层次,对此,结合上述对EventLoopGroup与EventLoop的源码分析,现将启动类Bootstrap,EventLoopGroup,EventLoop,Channel以及Thread之间的关联示意图绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/bootstrap_group_thread_channel.jpg"></p>
<h5 id="启动类绑定端口事件流程"><a href="#启动类绑定端口事件流程" class="headerlink" title="启动类绑定端口事件流程"></a>启动类绑定端口事件流程</h5><p>入口程序源码分析如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口程序</span></span><br><span class="line">bootsrtap.bind(PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 通过类名称可知是创建服务端的Channel并注册Channel事件实现对客户端Channel连接的监听</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind包括: 创建channel -&gt; 初始化channel -&gt; 注册channel -&gt; channel绑定端口操作</span></span><br><span class="line">doBind(<span class="keyword">final</span> SocketAddress localAddress)&#123;</span><br><span class="line">  <span class="comment">// 由于注册绑定流程复杂,这里将绑定注册流程划分出来,摘录核心方法,Netty框架中使用EventLoop来处理每个channel事件,存在多线程异步执行的情况.对于异步返回的结果ChannelFuture已在Netty组件源码分析说明到,这里不再详述</span></span><br><span class="line"><span class="comment">// 初始化并注册服务端的channel</span></span><br><span class="line">initAndRegister();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果注册成功,执行服务端channel的绑定操作</span></span><br><span class="line">doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务端channel初始化与注册事件</p>
</blockquote>
<ul>
<li>创建服务端channel的流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="comment">// 使用channelFactory创建NioServerSocketChannel实例</span></span><br><span class="line">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure>

<p><code>NioServerSocketChannel</code>类图结构设计如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/nioserversocketchannel_class.jpg"></p>
<p>这个时候再来看创建<code>NioServerSocketChannel</code>实例都做了哪些事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建java的nio下的ServerSocketChannel并传递到当前的NioServerSocketChannel构造器中</span></span><br><span class="line">  <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 服务端监听Accept事件并保存,后续在进行注册的时候将会使用到OP_ACCEPT</span></span><br><span class="line">  	<span class="comment">// 1.设置channel的父类,如果当前为服务端的channel则为null</span></span><br><span class="line">  	<span class="comment">// 2.创建channelId</span></span><br><span class="line">    <span class="comment">// 3.创建Nio的Unsafe类</span></span><br><span class="line">    <span class="comment">// 4.创建channel的责任链pipeline,同时每个pipeline都会创建一个双端链表连接上下文对象</span></span><br><span class="line">  <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">  <span class="comment">// 1. 为当前的channel创建接收数据的ByteBuff分配器,即AdaptiveRecvByteBufAllocator,该分配器默认从1024kb开始创建缓冲区分配数据,最小为64kb,最多不超过65536kb</span></span><br><span class="line">  <span class="comment">// 2. 保存java对象的ServerSocketChannel</span></span><br><span class="line">  config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述源码可知,创建Channel时会将与操作Channel相关的组件也一起完成初始化操作,即创建操作缓冲区数据的Unsafe以及对缓冲区数据进行读写存储的ByteBuff分配器.</p>
<ul>
<li>服务端channel的初始化流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于上述完成channel的创建,接下来对channel进行初始化操作</span></span><br><span class="line"><span class="comment">// 对应的源码</span></span><br><span class="line"><span class="comment">// ServerBootstrap.java</span></span><br><span class="line">	<span class="comment">// 1. 为当前的channel设置option以及attributes</span></span><br><span class="line">  <span class="comment">// 2. 获取当前channel的责任链,为当前的责任添加初始化handler处理器</span></span><br><span class="line">init(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// init下初始化handler核心代码</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">    ChannelHandler handler = config.handler();</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pipeline.addLast(handler);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 在channel所在的eventloop创建一个线程来执行任务</span></span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在任务下为服务端的channel添加Acceptor处理器负责处理客户端channel连接进来的事件完成处理</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">          ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端channel的注册流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line"><span class="comment">// 获取boss NioEventLoopGroup,将channel注册到当前的group下</span></span><br><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据NioEventLoopGroup的继承类图,可知register方法是在MultithreadEventLoopGroup下</span></span><br><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 选举一个EventLoop来注册channel</span></span><br><span class="line">   <span class="comment">// 在初始化Group操作的时候已经完成选择器的初始化操作,这里调用选择器来选择一个EventLoop</span></span><br><span class="line">   <span class="comment">// 这里调用EventLoop的注册方法,在上述入口中使用NioEventLoop可知使用的register方法为SingleThreadEventLoop类下的方法,最终调用AbstractChannel下的register方法</span></span><br><span class="line">   <span class="comment">// 方法调用走向如下:</span></span><br><span class="line">   <span class="comment">// MultithreadEventLoopGroup.regitser() -&gt; SingleThreadEventLoop.regitser() -&gt; promise.channel().unsafe().register() -&gt; unsafe(NioMessageUnsafe).regitser() -&gt; AbstractNioUnsafe.regitser() -&gt; AbstractUnsafe.register() -&gt; AbstractUnsafe.register0()</span></span><br><span class="line">   <span class="keyword">return</span> next().register(channel);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractChannel.java下的AbstractUnsafe</span></span><br><span class="line">register0(promise);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述注册方法的核心步骤:</span></span><br><span class="line"><span class="comment">// 1. 将channel注册到复用器selector上</span></span><br><span class="line"><span class="comment">// 2. 注册完成之后唤醒回调责任链下所有先前已加入的channelHandler类下的handlerAdd方法</span></span><br><span class="line"><span class="comment">// 3. 注册完成之后将结果设置在promise中</span></span><br><span class="line"><span class="comment">// 4. 将注册结果传递到责任链pipeline中,并执行回调channelHandler(ChannelInboundHandler)类下的channelRegistered方法,链式回调执行</span></span><br><span class="line"><span class="comment">// 5. 如果channel为active状态,则继续传播结果事件到channelHandler(ChannelInboundHandler)类下的channelActive方法,链式回调执行</span></span><br><span class="line"><span class="comment">// 6. 5步骤是在第一次进行注册的时候会执行(表示channel已经打开),如果已经注册过,那么校验会自动开始数据读取操作,客户端channel注册读取OP_READ操作, 对应服务端的Channel而言就是监听客户端socket的连接ACCEPT事件</span></span><br></pre></td></tr></table></figure>

<p>在基于上述的线程执行任务细节基础之上,将服务端的初始化并注册流程示意图流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_create_init_register.jpg"></p>
<blockquote>
<p>执行端口绑定与监听操作</p>
</blockquote>
<ul>
<li>端口绑定源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上述channel注册成功之后,这个时候在上面流程只会触发Active事件,这个时候没有绑定端口没有触发监听事件</span></span><br><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line">doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  // channel所在的eventloop线程执行任务</span></span></span><br><span class="line"><span class="params"><span class="function">  channel.eventLoop()</span>.<span class="title">execute</span><span class="params">(new Runnable()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册成功将channel进行绑定操作</span></span><br><span class="line">      <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        promise.setFailure(regFuture.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannel.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在链表尾部添加绑定操作</span></span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="comment">// cancelled</span></span><br><span class="line">      <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 搜索outboundContext上下文</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">      <span class="comment">// 执行责任链pipeline 出站事件,从链表尾部开始搜索,因而最后的context是headContext</span></span><br><span class="line">      <span class="comment">// 执行headContext下的invokeBind方法,该方法还是属于当前类,对此查看下文</span></span><br><span class="line">      next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          next.invokeBind(localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, promise, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyOutboundHandlerException(t, promise);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// headContext的绑定方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// unsafe为NioMessageUnsafe,执行该类下的bind方法(AbstractUnsafe.java中定义)</span></span><br><span class="line">  <span class="comment">// 最后再执行channel下的doBind(localAddress);方法,即NioServerSocketChannel下的方法</span></span><br><span class="line">  <span class="meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 可以看到实现了端口的绑定操作</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">      javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 对此,基于上述源码的分析,我们绘制服务端channel的端口绑定流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_bind_flow.jpg"></p>
<h5 id="责任链创建执行流程"><a href="#责任链创建执行流程" class="headerlink" title="责任链创建执行流程"></a>责任链创建执行流程</h5><ul>
<li>基于ChannelInitial来初始化pipeline的handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加handler的入口程序</span></span><br><span class="line"><span class="comment">// 这里主要是捡重点说明</span></span><br><span class="line">ChannelPipeline p = channel.pipeline();</span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer()&#123;</span><br><span class="line">  <span class="comment">// 在源码中有如下说明:</span></span><br><span class="line">  <span class="comment">// 一旦channel注册将调用当前initChannel方法，方法执行完成之后将实例会从ChannelPipeline中移除</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">     pipeline.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 使用EventLoop添加</span></span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">          ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">  ObjectUtil.checkNotNull(handlers, <span class="string">&quot;handlers&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    checkMultiplicity(handler);</span><br><span class="line">		<span class="comment">// 创建一个上下文对象,默认为DefaultChannelHandlerContext</span></span><br><span class="line">    newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// head -&gt; handler1 --- handler - tail </span></span><br><span class="line">    addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">      <span class="comment">// channel还没有注册,设置当前handler处于等待状态</span></span><br><span class="line">      newCtx.setAddPending();</span><br><span class="line">      <span class="comment">// 将其添加到等待链表的尾部中</span></span><br><span class="line">      callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventExecutor executor = newCtx.executor();</span><br><span class="line">    <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">      callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHandlerAdded0(newCtx);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会当channel完成注册的时候会调用handlerAdd方法,而ChannelInitial的handlerAdd方法如下:</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">    <span class="comment">// 最终会调用initChannel方法</span></span><br><span class="line">    <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">      <span class="comment">// 完成channel的初始化链会将当前实例移除</span></span><br><span class="line">      removeState(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      initChannel((C) ctx.channel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">      exceptionCaught(ctx, cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 最后会在pipeline链中删除当前实例</span></span><br><span class="line">      ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">      <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>责任链添加处理器handler流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/pipeline_add_flow.jpg"></p>
<ul>
<li>channel事件与责任链生命周期联系</li>
</ul>
<p>通过上述可知,channel在注册前后过程中的pipeline存储的handler结构为:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_pipeline_flow.jpg"></p>
<h5 id="服务端接收客户端连接的事件流程"><a href="#服务端接收客户端连接的事件流程" class="headerlink" title="服务端接收客户端连接的事件流程"></a>服务端接收客户端连接的事件流程</h5><p>根据EventLoop的事件轮询流程可知,服务端监听的事件变化以及事件转发处理都在EventLoop.run方法中,对此,我们详细看下Netty的服务端是如何接收并处理客户端的连接事件以及对应的事件流程是如何的.</p>
<ul>
<li>Netty框架下的核心事件轮询run方法源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上述已经贴有源码,这里我们更关注细节问题,仅列出run方法的核心源码</span></span><br><span class="line"><span class="comment">// NioServerSocketChannel.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">  <span class="comment">// 服务端不断轮询监听事件</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行select操作</span></span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">      strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理任务队列中的任务</span></span><br><span class="line">    ranTasks = runAllTasks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然关注ACCEPT事件,这个时候我们需要知道服务端Channel在创建注册并绑定的时候初始化handler并将Acceptor添加到handler中,对此我们追踪下bind方法,最后查阅代码到init方法,其代码如下:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在先前分析可知,这里已经完成了channel的创建,且此时channel为NioServerSocketChannel事件</span></span><br><span class="line">  ChannelPipeline p = channel.pipeline();</span><br><span class="line">  p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">      <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">      ChannelHandler handler = config.handler();</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pipeline.addLast(handler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述源代码,服务端监听连接事件的流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_listen_flow.jpg"></p>
<p>其中关于创建和注册流程基本和上述服务端channel一致,这里绘制的时候直接简化,没有详细绘制出来.</p>
<h5 id="服务端处理客户端channel的读写事件流程"><a href="#服务端处理客户端channel的读写事件流程" class="headerlink" title="服务端处理客户端channel的读写事件流程"></a>服务端处理客户端channel的读写事件流程</h5><ul>
<li>读写事件源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这里关注的读写事件是NioSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">     ch.unsafe().forceFlush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">     unsafe.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioSocketChannel使用NioByteUnsafe来实现读写</span></span><br><span class="line"><span class="comment">// 先读后写</span></span><br><span class="line"><span class="comment">// 读取流程</span></span><br><span class="line"><span class="comment">// AbstractNioByteChannel.NioByteUnsafe</span></span><br><span class="line">read()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="comment">// 从socket中读取数据</span></span><br><span class="line">      doReadBytes(byteBuff);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传播数据</span></span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">    &#125;<span class="keyword">while</span>(continueReading())</span><br><span class="line">    	pipeline.fireChannelReadComplete();</span><br><span class="line">    	<span class="keyword">if</span>(close)&#123;</span><br><span class="line">      	closeOnRead(pipeline);</span><br><span class="line">    	&#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">//传播userEventTriggered</span></span><br><span class="line">    handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">      <span class="comment">// 取消读取操作</span></span><br><span class="line">      removeReadOp();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出流程</span></span><br><span class="line"><span class="comment">// 写出操作的触发点是在某个handler下的channelRead方法下手动执行write或者writeAndFlush方法</span></span><br><span class="line"><span class="comment">// handler 通过addLast方法添加,默认上下文对象为DefaultChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerRead</span><span class="params">(AbstractHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 执行写操作的流程说明责任链执行当前入站事件handler已经是最后一个,从当前handler的上下文对象开始执行出站事件</span></span><br><span class="line">  ctx.writeAndFlush(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行链为:</span></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.writeAndFlush() - invokeWriteAndFlush -&gt; handler.write()  - head.write() - AbstractUnsafe.write() - filterOutboundMessage() - AbstractNioByteChannel.filterOutboundMessage()[创建一个堆外内存] - addMessage() -&gt; incrementPendingOutboundBytes() -&gt; [newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()] -&gt; setUnwritable -&gt; fireChannelWritabilityChanged -&gt; head.fireChannelWritabilityChanged -&gt; handler.fireChannelWritabilityChanged -&gt; tail.fireChannelWritabilityChanged </span></span><br><span class="line"><span class="comment">// -&gt; invokeFlush0 -&gt; handler.flush()  -&gt; head.flush() -&gt; AbstractUnsafe.flush() -&gt; addFlush()  -&gt; flush0() -&gt;. NioSocketChannel.doWrite() -&gt; ch.write(nioBuffers, 0, nioBufferCnt) -&gt; incompleteWrite() -&gt; setOpWrite()[注册写事件] -&gt; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>读事件流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_read.jpg"></p>
<ul>
<li>写事件流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_write.jpg"></p>
<h5 id="ServerChannel-ChannelHandler-ChannelPipeline事件生命周期"><a href="#ServerChannel-ChannelHandler-ChannelPipeline事件生命周期" class="headerlink" title="ServerChannel/ChannelHandler/ChannelPipeline事件生命周期"></a>ServerChannel/ChannelHandler/ChannelPipeline事件生命周期</h5><p>结合之前组件的源码以及上述的事件流程分析,关于channel事件与pipeline责任链回调执行生命周期流程总结如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event/channel_pipeline_life.jpg"></p>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Netty事件流程分析(下)</title>
    <url>/2020/04/24/netty03/</url>
    <content><![CDATA[<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/title2.jpg" alt="title2"></p>
<p>继上篇Netty事件分析,本文主要讲述Netty的责任链流程,Channel与Handler生命周期以及网络IO事件分析流程,最后对Netty事件流程进行一个总结梳理.</p>
<h4 id="pipeline责任链流程分析"><a href="#pipeline责任链流程分析" class="headerlink" title="pipeline责任链流程分析"></a>pipeline责任链流程分析</h4><h5 id="责任链创建流程"><a href="#责任链创建流程" class="headerlink" title="责任链创建流程"></a>责任链创建流程</h5><ul>
<li>入口程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 责任链的创建是在Channel的初始化的时候进行的</span></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前为服务端的channel，则parent=null</span></span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="comment">// 创建channelId</span></span><br><span class="line">  id = newId();</span><br><span class="line">  <span class="comment">// 使用NioServerSocketChannel父类的AbstractNioMessageChannel下的NioMessageUnsafe</span></span><br><span class="line">  <span class="comment">// 使用NioSocketChannel父类的AbstractNioByteChannel下的AbstractNioUnsafe</span></span><br><span class="line">  unsafe = newUnsafe();</span><br><span class="line">  <span class="comment">// 创建channel的责任链,DefaultChannelPipeline</span></span><br><span class="line">  pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建默认的责任链实例对象</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Channel的类关系图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_class.jpg"></p>
<p>通过源码与类图可知,不论是服务端Channel的创建还是客户端Channel的创建,其默认的pipeline均通过AbstractChannel的构造方法来初始化一个责任链实例,且默认为<code>DefaultChannelPipeline</code>,接下来我们来看下责任链创建的流程</p>
<ul>
<li>创建源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前的责任链保存对应的channel信息</span></span><br><span class="line">  <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// channel在整个责任链处理正常返回的成功结果对象Future</span></span><br><span class="line">  succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对channel在整个责任链处理添加监听,负责异常的捕获</span></span><br><span class="line">  voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建上下文对象，每个上下文对象都包含当前pipeline实例对象</span></span><br><span class="line">  tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">  head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在逻辑结构上通过双端链表的方式存储上文对象</span></span><br><span class="line">  head.next = tail;</span><br><span class="line">  tail.prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于HeadContext与TailContext特殊上下文的创建</span></span><br><span class="line"><span class="comment">// 上下文创建</span></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line">HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">  <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, HeadContext.class);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据channel的类型来区分,服务端为NioMessageUnsafe</span></span><br><span class="line">  <span class="comment">// 客户端为NioSocketChannelUnsafe</span></span><br><span class="line">  unsafe = pipeline.channel().unsafe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证handler调用方法的顺序，可以理解为handler执行的生命周期，通过状态机来控制生命周期</span></span><br><span class="line">  setAddComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">   <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, TailContext.class);</span><br><span class="line">   setAddComplete();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于Netty责任链使用的EventLoop是属于有序的执行器,为了保证handlerAdd与handlerRemove的执行存在先后关系,通过以下的状态机来控制,即handler方法执行的生命周期保证,如果EventLoop不保证有序的话,只需要通过ADD_COMPLETE或者REMOVE_COMPLETE来告知方法是否被调用即可</span></span><br><span class="line"><span class="comment">// 初始化状态,创建责任链的时候上下文的handlerState默认为初始化,表示handlerAdd/handlerRemove均没有被调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// handlerAdded即将被调用(实际还没有调用,准备就绪,可以被调用),一般是在不需要保证有序的情况下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD_PENDING = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// handlerAdd已经被调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD_COMPLETE = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// handlerRemoved已经被调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVE_COMPLETE = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>相比其他的handler的上下文创建,HeadContext与TailContext在构建方法中多了一个动作<code>setAddComplete()</code>,主要目的是由于双端链表的head与tail都是在初始化channel的时候构建而不是通过addLast或者是addFirst的方式构建,为了保证handler方法执行的有序性,于是在构建上下文的时候多添加一个步骤,接下来我们可以看到普通的handler添加方式,会在addLast中也调用上述<code>setAddComplete()</code>相应的方法执行.</p>
<ul>
<li>创建流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/pipeline_init.jpg"></p>
<h5 id="添加handler流程"><a href="#添加handler流程" class="headerlink" title="添加handler流程"></a>添加handler流程</h5><ul>
<li>程序入口代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的责任链pipeline</span></span><br><span class="line">Pipeline pipeline = channel.pipeline();</span><br><span class="line"><span class="comment">// 添加handler,这里以特殊的initHandler添加为准来说明,摘录启动类的init方法</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">  <span class="comment">// ChannelInitializer是一个特殊的入站事件，添加到channel中的pipeline中</span></span><br><span class="line">  <span class="comment">//  一旦channel已经注册到EventLoop中就会触发执行</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">    ChannelHandler handler = config.handler();</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pipeline.addLast(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">          ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>addLast()</code>源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    checkMultiplicity(handler);</span><br><span class="line">		<span class="comment">// 创建一个上下文对象,默认为DefaultChannelHandlerContext</span></span><br><span class="line">    newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 将上下文对象添加到责任链尾部</span></span><br><span class="line">    addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">      <span class="comment">// channel还没有注册,设置当前handler处于等待状态</span></span><br><span class="line">      newCtx.setAddPending();</span><br><span class="line">      <span class="comment">// 将其添加到等待链表的尾部中</span></span><br><span class="line">      callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventExecutor executor = newCtx.executor();</span><br><span class="line">    <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">      <span class="comment">// 当前线程持有的eventloop非独占,需要将其添加到任务队列中</span></span><br><span class="line">      callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 核心方法</span></span><br><span class="line">  callHandlerAdded0(newCtx);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callHandlerAdded0下会执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ctx.callHandlerAdded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 可以看到在执行handlerAdd方法之前会调用setAddComplete方法</span></span><br><span class="line">  <span class="keyword">if</span> (setAddComplete()) &#123;</span><br><span class="line">    handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会当channel完成注册的时候会调用handlerAdd方法,而ChannelInitial的handlerAdd方法如下:</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">    <span class="comment">// 调用initChannel方法</span></span><br><span class="line">    <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">      <span class="comment">// 完成channel的初始化链会将当前实例移除</span></span><br><span class="line">      removeState(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模板(钩子hook)方法,也就是我们上述的入口程序添加initHandler重载的initChannel方法</span></span><br><span class="line">      initChannel((C) ctx.channel());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">      exceptionCaught(ctx, cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 最后会在pipeline链中删除当前实例</span></span><br><span class="line">      ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">      <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加handler的流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/pipeline_add_flow.jpg"></p>
<p>通过上述流程图可知,初始化initHandler在channel注册之后责任链pipeline会将initHandler从中移除并将用户添加的handler添加到责)</p>
<h5 id="责任链销毁流程"><a href="#责任链销毁流程" class="headerlink" title="责任链销毁流程"></a>责任链销毁流程</h5><p>在查看责任链销毁的源代码之前,我们是否应该先思考是什么样的动作行为会销毁pipeline责任链,如果想不出来,我们换另一个思路,责任链是什么时候创建的,根据上述的分析,责任链pipeline是创建channel的时候创建的,那么我们是否可以推测销毁时机是不是在channel销毁的时候对应的pipeline也将会销毁呢?那么channel是在什么时候销毁的呢,我们可以考虑一个已熟知的数据库连接connection创建与销毁,什么时候需要销毁connection,自然是调用<code>close()</code>方法的时候,这个时候connection要么等待被JVM回收要么就是存放到回收资源池中,对此关于责任链的销毁分析如下</p>
<ul>
<li>入口程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端channel销毁,也就是服务端channel调用close()关闭服务</span></span><br><span class="line"><span class="comment">// 对于客户端channel,自然是断开与服务端的连接</span></span><br><span class="line"><span class="comment">// channel的关闭是属于事件触发,于是我们直接定位到事件轮询器下的方法processSelectedKey,该方法负责处理就绪事件</span></span><br><span class="line"><span class="comment">// 对于NIO的api,每个socket的就绪事件都存储在SelectionKey中,如果channel销毁,当前的SelectionKey也将会在销毁之前取消事件监听</span></span><br><span class="line"><span class="comment">// NioEventLoop.javas</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unsafe.close(unsafe.voidPromise());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">    unsafe.close(unsafe.voidPromise());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过代码定位最终会执行以下代码块</span></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 调用java饿的socket进行关闭</span></span><br><span class="line">  doClose0(promise);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Call invokeLater so closeAndDeregister is executed in the EventLoop again!</span></span><br><span class="line">  invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (outboundBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Fail all the queued messages</span></span><br><span class="line">        outboundBuffer.failFlushed(cause, notify);</span><br><span class="line">        outboundBuffer.close(closeCause);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将channel事件传播到责任链中</span></span><br><span class="line">      fireChannelInactiveAndDeregister(wasActive);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>销毁流程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/pipeline_destroy.jpg"></p>
<h4 id="IO事件流程分析"><a href="#IO事件流程分析" class="headerlink" title="IO事件流程分析"></a>IO事件流程分析</h4><h5 id="监听连接事件"><a href="#监听连接事件" class="headerlink" title="监听连接事件"></a>监听连接事件</h5><p>基于上一篇的Netty事件流程分析中的事件轮询说明可知,服务端监听的事件变化以及事件转发处理都在EventLoop.run方法中,对此,我们详细看下Netty的服务端是如何接收并处理客户端的连接事件以及对应的事件流程是如何的.</p>
<ul>
<li>Netty框架下的核心事件轮询run方法源代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅贴出部分核心代码</span></span><br><span class="line"><span class="comment">// NioServerSocketChannel.java</span></span><br><span class="line">run()&#123;</span><br><span class="line">  <span class="comment">// 服务端不断轮询监听事件</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行select操作</span></span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">      strategy = select(curDeadlineNanos);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理任务队列中的任务</span></span><br><span class="line">    ranTasks = runAllTasks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然关注ACCEPT事件,这个时候我们需要知道服务端Channel在创建注册并绑定的时候初始化handler并将Acceptor添加到handler中,对此我们追踪下bind方法,最后查阅代码到init方法,其代码如下:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在先前分析可知,这里已经完成了channel的创建,且此时channel为NioServerSocketChannel事件</span></span><br><span class="line">  ChannelPipeline p = channel.pipeline();</span><br><span class="line">  p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">      <span class="comment">// 获取服务端channel的handler处理类</span></span><br><span class="line">      ChannelHandler handler = config.handler();</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pipeline.addLast(handler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ServerBootstrapAcceptor监听连接的源码</li>
</ul>
<p>在上一篇的事件分析中,我们对服务端的一个绑定事件进行了分析(包括服务端channel的创建/初始化与注册,客户端的channel基本与服务端一致,这里也不再详细说明),最终的监听连接的事件将会调用<code>unsafe.read()</code>方法并且会将事件通过责任链pipeline传播到channelRead方法下,对此,我们关注Acceptor处理连接可以通过查看handler实现的<code>channelRead()</code>方法即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServerBootstrapAcceptor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">  <span class="comment">// 将处理客户端channel的handler添加到责任链pipeline中</span></span><br><span class="line">  child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">  setChannelOptions(child, childOptions, logger);</span><br><span class="line">  setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端channel注册到EventLoop,注册流程与之前服务端注册流程基本一致,这里不再详述</span></span><br><span class="line">    childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">          forceClose(child, future.cause());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    forceClose(child, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>监听连接的事件流程</li>
</ul>
<p>通过上述源码以及责任链添加handler的流程可知,当服务端channel完成之后,pipeline链将会是<code>head -&gt; handlers -&gt; ServerBootstrapAcceptor -&gt; tail</code>,因而我们根据现有的线索以及上述源码,对监听连接事件流程绘制如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_listen_flow.jpg"></p>
<h5 id="请求读取事件"><a href="#请求读取事件" class="headerlink" title="请求读取事件"></a>请求读取事件</h5><ul>
<li>入口程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.run()方法</span></span><br><span class="line"><span class="comment">// 在这里关注的读写事件是NioSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">     ch.unsafe().forceFlush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于处理请求,我们需要关注NioSocketChannel处理读取事件流程</span></span><br><span class="line">  <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">     unsafe.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>NioSocketChannel的类图组件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/nio_socket_channel_class.jpg"></p>
<ul>
<li>读取事件实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据上述代码以及类图可知,NioSocketChannel使用初始化safe实现类为NioSocketChannelUnsafe</span></span><br><span class="line"><span class="comment">// 于是查看其的源码实现,但是方法NioSocketChannelUnsafe并没有read方法,而是在NioByteUnsafe类中,因而找到对应的read方法,摘录部分核心代码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="comment">// 从socket中读取数据</span></span><br><span class="line">      doReadBytes(byteBuff);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传播读取事件到责任链中</span></span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">    &#125;<span class="keyword">while</span>(continueReading())</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 传播读取完成事件到责任链中</span></span><br><span class="line">    	pipeline.fireChannelReadComplete();</span><br><span class="line">    	<span class="keyword">if</span>(close)&#123;</span><br><span class="line">      	closeOnRead(pipeline);</span><br><span class="line">    	&#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">//传播事件异常以及userEventTriggered</span></span><br><span class="line">    handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">      <span class="comment">// 取消读取操作</span></span><br><span class="line">      removeReadOp();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>请求读取流程示意图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_read.jpg"></p>
<h5 id="数据写出事件"><a href="#数据写出事件" class="headerlink" title="数据写出事件"></a>数据写出事件</h5><ul>
<li>入口程序代码</li>
</ul>
<p>对于写出操作,主要在开发者实现Channel的channelRead或者channelReadCompleted方法下手动调用方法执行写出操作,即入口程序代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写出操作的触发点是在某个handler下的channelRead方法下手动执行write或者writeAndFlush方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerRead</span><span class="params">(AbstractHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 执行写操作的流程说明责任链执行当前入站事件handler已经是最后一个,从当前handler的上下文对象开始执行出站事件</span></span><br><span class="line">  ctx.writeAndFlush(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,写出操作是调用上下文对象的写出操作,基于这个线索,先来查看上下文对象的类图设计关系.</p>
<ul>
<li>上下文对象类设计图</li>
</ul>
<p>在添加handler的时候,我们通过源码看到addLast方法内部的实现中,默认上下文对象为DefaultChannelHandlerContext,于是对应的类图关系如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/context_class.jpg"></p>
<p>通过上述的类图可知,上下文对象有一个父类<code>AbstractChannelHandlerContext</code>来实现通用的方法,同时上下文对象具备出入站事件,因此我们可以在handler中对接收到的上下文对象ctx手动处理出站或入站事件的传播,对此当我们调用<code>ctx.writeAndFlush()</code>方法的时候也将会触发对应的一个handler触发事件(通过源码分析是属于出站事件)</p>
<ul>
<li>源码分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">    <span class="comment">// 负责将写出的数据存储到OutboundBuffer缓冲区</span></span><br><span class="line">    invokeWrite0(msg, promise);</span><br><span class="line">    <span class="comment">// 执行刷新操作</span></span><br><span class="line">    invokeFlush0();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeAndFlush(msg, promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过责任链传播写出事件,</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    notifyOutboundHandlerException(t, promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过责任链传播刷新事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    notifyHandlerException(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据责任链执行流程可知,最终会执行headContext下write以及flush的方法</span></span><br><span class="line"><span class="comment">// HeadContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">  unsafe.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后会调用AbstractUnsafe的write以及flush方法(这里就不贴出代码.直接查看流程图)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写出事件执行流程图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_write.jpg"></p>
<h4 id="Channel与Handler生命周期小结"><a href="#Channel与Handler生命周期小结" class="headerlink" title="Channel与Handler生命周期小结"></a>Channel与Handler生命周期小结</h4><h5 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h5><p>结合上一篇的事件流程分析,channel主要经历创建 - 初始化 - 注册 - 事件接收处理 - 销毁过程,其经历的流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_flow.jpg"></p>
<ul>
<li>Channel生命周期</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channel_lifetime.jpg"></p>
<h5 id="Handler的生命周期"><a href="#Handler的生命周期" class="headerlink" title="Handler的生命周期"></a>Handler的生命周期</h5><ul>
<li>handler类设计图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/handler_class.jpg"></p>
<ul>
<li>Handler生命周期</li>
</ul>
<p>根据上述类图可知,ChannelHandler定义了handlerAdd以及handlerRemoved并且结合上述责任链的流程分析可知,handler是通过上下文对象来传播事件并回调方法,并且上下文对象通过handlerState以及channel事件流程来保证上述方法执行的先后顺序,从而保证handler的执行生命周期</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/handler_lifetime.jpg"></p>
<h5 id="Handler方法回调与生命周期联系"><a href="#Handler方法回调与生命周期联系" class="headerlink" title="Handler方法回调与生命周期联系"></a>Handler方法回调与生命周期联系</h5><p>最后,根据前面分析的事件流程以及上述的Channel生命周期,对Channel与handler执行回调方法作一个小结,如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/event2/channle_life.jpg"></p>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析Netty核心特性</title>
    <url>/2020/05/01/netty04/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="深入分析Netty高性能特性"><a href="#深入分析Netty高性能特性" class="headerlink" title="深入分析Netty高性能特性"></a>深入分析Netty高性能特性</h3><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_title.jpg"></p>
<p>在讲述Netty的高性能特性之前,基于之前的epoll技术分析中谈到C10K问题与高性能IO设计文章的认知,对于C10K问题其实是属于一个优化问题,目的是为了能够在单台机器上支撑更多的并发连接调度所做的性能优化,为了达到上述目标,需要要求我们设计的web服务采用合理的IO模型,并在对应的IO模型基础上引入多线程与并发库技术的使用来支撑更多的连接调度,同时考虑到计算机资源的限制,我们需要在设计web服务的时候合理对资源进行分配优化,比如内存,网络带宽以及CPU核数的充分利用,也就是说我们还需要考虑到可伸缩性的问题,通过增加资源来使得我们的web服务能够得到线性提升效果.接下来我们就来结合源码分析Netty技术是如何体现高性能这一个特性.</p>
<h4 id="C10K与C10M问题"><a href="#C10K与C10M问题" class="headerlink" title="C10K与C10M问题"></a>C10K与C10M问题</h4><h5 id="C10K-amp-C10M解决方案"><a href="#C10K-amp-C10M解决方案" class="headerlink" title="C10K&amp;C10M解决方案"></a>C10K&amp;C10M解决方案</h5><blockquote>
<p>C10K问题</p>
</blockquote>
<p>关于C10K的问题,在先前的epoll技术分析文章已经有讲述过,C10K是属于一个优化问题,即要让单个web服务支撑1w的并发连接,关于C10K的性能与可伸缩性问题,摘录C100M的博文并加入自己的理解:</p>
<ul>
<li>采用线程连接架构TBA模型,也就是1个客户端连接对应1个线程,那么对于内核而言,假设这个时候需要10k个连接,那么也就意味着要10k个线程,此时内核需要从这个10k个线程中轮询遍历哪个线程是有数据流量进来的,对于服务器本身而言,不论线程数量多少,线程上下文切换的时间是恒定的,即使再多的连接分配给再多的线程,其性能也不会上去,线程调度仍然无法扩展,除了本身线程资源的瓶颈之外,我们可以看到的一个现场就是线程调度无法扩展.</li>
<li>相对地,采用选择/轮询来处理连接事件,也就是面向事件驱动设计EDA模式,我们在分析select/poll/epoll技术中讲到,它们都是对一个socket集合fds进行监听,每个数据包都会经过socket套接字,即使套接字增加,我们同样可以通过选择和轮询的方式来遍历socket数据流量进来的事件,这个时候单线程是可以完成一个选择和轮询就绪事件的操作,同时还可以实现连接的扩展性,随着IO技术的发展,现代服务器都会引入可扩展的epoll技术与异步IO Compeletion Port在指定时间内查询就绪的socket集合并返回给应用程序.</li>
</ul>
<p>因此,优化一个C10K的问题可以从以下几个方面考虑:</p>
<ul>
<li>选用的IO模型能够支持web实现可伸缩性</li>
<li>结合IO模型设计的线程模型,能够通过增加适当的线程数量来支撑web服务更多的并发连接</li>
<li>最后一个可以理解为性能问题,一个Web服务的性能可以参考以下几个因素: <strong>数据复制拷贝问题/线程上下文切换问题/内存分配问题以及锁争用(无锁编程是一个我们理想的选择)</strong></li>
</ul>
<blockquote>
<p>C10M问题</p>
</blockquote>
<p>同理地,C10K问题的解决,随着互联网技术发展,又提出了一个C10M的优化问题,即如何让我们的单台机器支撑1000w的并发连接,这个时候Errata Security首席执行官Robert Graham从历史的角度出发讲述Unix最开始设计不是通用的服务器OS,而是作为电话网络的控制系统,实际上是电话网络在控制数据传输,因而控制平面与数据平面存在清晰的分隔,于是指出一个问题,即当前我们使用的Unix服务器是作为数据平面的一部分,这也是他所说的内核不是解决方案,而是问题所在,什么意思呢?<strong>不要让内核承担所有繁重的工作</strong>.将数据包处理,内存管理和处理器调度从内核中移出,并将其放入应用程序中,可以在其中高效地完成它.让Linux处理控制平面,让应用程序处理数据平面.对此,一个C10M关注的问题有以下几个方面:</p>
<ul>
<li>1000w个并发连接</li>
<li>支撑一个持续时间约为10s的100w并发连接</li>
<li>1000万个数据包/秒-期望当前的服务器每秒处理5万个数据包，这将达到更高的水平。过去服务器每秒能够处理100K次中断，每个数据包都会引起中断。</li>
<li>10微秒延迟-可伸缩服务器可能会处理规模，但延迟会增加。</li>
<li>10微秒抖动-限制最大延迟</li>
<li>10个连贯的CPU内核-软件应扩展到更大数量的内核。通常，软件只能轻松扩展到四个内核。服务器可以扩展到更多的内核，因此需要重写软件以支持更大的内核计算机</li>
</ul>
<p>基于上述的叙述,为了构建一个能够支撑1000w/s的并发连接系统,我们需要让数据平面系统能够处理1000w/s个数据包,而对于一个控制平面系统而言,持续10s的最多也就只能处理100w个并发连接,为了实现这个目标,我们借鉴C10K问题的解决方案,C10K问题主要是从构建一个可伸缩性的IO模型的web服务来达到支撑10K并发连接的目的,同时也引入线程模型与性能优化手段来配合实现达到目的,从这里我们也可以看到可伸缩性是我们设计的目标,同时为了支撑1000w的连接,我们不能将性能优化外包给操作系统,那么我们要编写一个可伸缩性的软件来达到上述的目标就需要解决以下的问题:</p>
<ul>
<li>数据包可扩展: 编写一个自定义驱动程序以绕过TCP堆栈,直接将数据包发送到应用程序.如PF_RING，Netmap，Intel DPDK</li>
<li>多核可扩展: 多核编码并不是多线程编码,而是让我们的应用程序分布在每个CPU核心上,保证我们能够随着内核的增加以线性扩展我们应用程序的处理能力.即一个是保持每个cpu核数的数据结构,一个是每个cpu保证原子性操作,一个是使用无锁技术的数据结构,一个是使用线程模型完成流水工作,最后一个是利用处理器的亲和力,即保持运行在每个cpu核数上分配的线程是固定的,即每个cpu对应着专有的线程来完成工作.</li>
<li>内存可扩展: 一个是使用连续内存分配技术,增加数据的缓存命中率,一个是分页表运用高效的缓存数据结果并对数据压缩,一个是使用池化技术管理内存,一个是合理分配线程以降低内存访问延迟,最后一个是使用预分配的内存技术.</li>
</ul>
<p>因此,我们可以借鉴C10K与C10M的优化思路来推导一个具备高并发,高性能且可伸缩性的web服务设计思路展开,高并发连接调度我们可以从IO模型以及线程模型思考,高性能的指标我们可以从计算机资源分配管理与优化方面思考(比如内存/无锁编程),而一个可伸缩性的web服务我们会从物理资源角度来考虑,通过增加相关的资源配置是否能够得到线性的性能提升.接接下来我们开始分析Netty是如何实现高并发,高性能以及如何体现可伸缩性的.</p>
<h5 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h5><blockquote>
<p>高并发关注指标</p>
</blockquote>
<ul>
<li>响应时间(Response Time):发起一个request请求,执行这个request请求从开始到最后返回响应结果所花费的总体时间,也就是客户端发起请求到最后收到服务端返回响应结果的时间.比如http请求响应时间为200ms,200ms表示RT.</li>
<li>每秒并发连接(并发用户数): 每秒可支撑的连接调度/同时承载正常使用系统功能的用户数量,并发连接/用户数更关注的是能够处理调度连接而不在于处理速度.</li>
<li>QPS/TPS(每秒查询量/每秒事物处理量): 比如现在客户端发起一个下单操作(用户鉴权/订单校验/下单操作三个步骤),这个下单操作形成一个TPS,而下单里的每个步骤形成一个QPS,也就是说TPS包含3个QPS操作,因而对于TPS理解是一个完整的事物请求的操作结果,而QPS是针对一个request请求的操作结果,对此TPS是衡量软件测试结果的度量单位,而QPS是特定的查询服务器在指定的时间段内处理流量度量标准的数量,域名服务器的机器性能通常用QPS来衡量,QPS与TPS更关注处理速度.</li>
<li>吞吐量(Throughput): 取决于我们关注系统的业务指标,比如我们关注的是软件测量结果相关的处理能力(处理速度),那么这个时候的吞吐量我们需要关注的是TPS,如果是关注机器性能的流量,那么我们关注的吞吐量是QPS,如果我们对接的是接入层的服务,那么我们可能需要关注的是并发连接的调度,此时关注的吞吐量是支撑的并发连接调度数据.</li>
</ul>
<blockquote>
<p>并发连接/QPS/TPS</p>
</blockquote>
<p>基于上述的高并发指标的理解,现将并发连接/QPS/TPS的区分通过以下图解的方式展开:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/connections_qps_tps.jpg"></p>
<ul>
<li>并发连接: 主要体现在服务端程序高效的连接调度机制上,也就是说服务端能够在一定的时间段内能够正确地响应给每个连接的请求即可,至于何时响应以及如何响应不是并发连接关注的事情.</li>
<li>QPS/TPS: 主要体现在处理速度上,要求能够正常完成对请求响应的处理,不仅是要对请求结果正确响应,同时还要求处理能力能够尽可能快速.</li>
</ul>
<blockquote>
<p>IO与线程模型实现高并发连接调度</p>
</blockquote>
<ul>
<li>基于先前的高性能IO编程设计并结合上述的C10K与C10M问题,实现一个支撑高并发连接调度的web服务需要借助具备可伸缩性的NIO或者AIO技术完成,通过监听socket的数据流量出入事件来响应给应用程序,并且轮询事件通过单线程的方式也能够处理,还能实现扩展,只要操作系统的fd资源配置足够大即可.</li>
<li>其次,为了支撑更多更快的响应连接调度处理,我们可以适当地加入多线程处理方式来扩展上述单线程处理连接事件的能力.同时也会看到在IO相关设计,基于事件的编程,为了简化应用开发者编写代码的复杂度以及具备更好的扩展性,引入了基于EDA的Reactor与Proactor的模式设计.</li>
</ul>
<h5 id="C10K与C10M提升性能优化因素"><a href="#C10K与C10M提升性能优化因素" class="headerlink" title="C10K与C10M提升性能优化因素"></a>C10K与C10M提升性能优化因素</h5><p>结合之前的高性能IO编程文章以及C10K与C10M问题,我们可以考虑设计一个高性能的Web服务可以从以下几个方面思考:</p>
<blockquote>
<p>数据包的存储</p>
</blockquote>
<ul>
<li>socket接收数据流量的时候我们要考虑如何将数据包直接传输到应用程序,尽量避免数据的拷贝问题.</li>
<li>应用程序接收数据包的时候能不能缓存起来,同时如果加入缓存的话,有没有办法提高命中率.</li>
<li>数据存储的区域能否重复利用,即使用池化技术进行管理分配,减少向计算机申请资源的性能.</li>
</ul>
<blockquote>
<p>应用程序的处理能力</p>
</blockquote>
<p>对于处理处理能力,我们可以用一个词来说明,那就是吞吐量,既然想要提升吞吐量,那么我们的目标其实也是很明确的,即“快”.</p>
<ul>
<li>充分利用CPU资源,避免CPU一直处于空闲假死状态(线程阻塞/空轮询/线程过多)</li>
<li>根据高性能IO设计的一文,我们可以在竞争环境下使用并发库,底层原子操作等手段有助于提升IO的吞吐量</li>
<li>同步环境下能够使用无锁来处理任务</li>
</ul>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>在Netty技术中主要是采用NIO实现多连接的单线程复用机制以及借助多线程异步处理方式来提升支撑并发连接调度的处理能力,在C10M问题中已经指出,为了优化C10M问题,我们应该考虑在应用程序方面去设计数据平面系统来构建一个支撑1000W并发连接的调度处理机制.</p>
<h5 id="可伸缩的IO模型"><a href="#可伸缩的IO模型" class="headerlink" title="可伸缩的IO模型"></a>可伸缩的IO模型</h5><ul>
<li>NIO多路复用技术具备可伸缩性,通过C10K问题的分析,我们知道单线程能够处理更多的socket就绪事件,也就是说单线程面向事件驱动设计的复用技术实现可扩展性且能支撑更多并发连接的请求调度处理,这里与线程连接不同的是我们关注的是事件而不是线程本身,因而不会受限于线程资源以及线程的调度分配问题.</li>
<li>其次Netty框架是基于Reactor模式进行演变,但于Reactor模式不同的是Netty是多线程异步处理,更像是Proactor模式,但异步处理是在应用程序通过回调的方式完成的,而Proactor是基于AIO的方式将异步操作传输到内核并在内核中进行回调返回.</li>
</ul>
<h5 id="Netty之Reactor模式"><a href="#Netty之Reactor模式" class="headerlink" title="Netty之Reactor模式"></a>Netty之Reactor模式</h5><p>关于Netty框架的线程模式架构设计图如下所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_model.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_model2.jpg"></p>
<p>现在我们基于宏观上对Netty的线程模型有一个基本认知之后,结合先前文章对Netty组件源码以及事件流程的分析可知,在Netty中存在EventLoopGroup,通过EventLoopGroup来分配EventLoop,而每一个EventLoop既具备线程池的功能又承担着事件轮询的工作,同时每个EventLoop都分配对应的一个FastThread专有线程来负责对处理当前EventLoop的pipeline的流水工作,由于每一个启动EventLoop都绑定专有的一个线程FastThread,那么对于EventLoop处理的一系列流水工作也将会在当前的线程执行,从而保证了单线程资源无竞争高效串行化流水任务的执行,简单点就是无锁流水工作,这个在我们上述讲到的C10M优化方案中体现的一个多核扩展问题,Netty框架很好地运用这一理念来提升我们web服务支撑高并发连接的调度处理.</p>
<p>关于Netty处理的单线程无锁串行化的流水工作流程示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_safe_pipeline.jpg"></p>
<p>在了解上述的无锁串行化任务执行流程之后,我们还需要关注Netty另一个问题,即在多Reactor模式中,我们看到服务端channel其实只完成一次创建,初始化以及注册,相比客户端channel,提供给客户端的EventLoopGroup由于在客户端有新连接进来的时候就会在Acceptor进行注册,而我们也分析channel的注册流程,注册的时候会在EventLoopGroup根据选举策略分配一个EventLoop来完成channel到EventLoop的绑定,对此,我们知道对于客户端channel而言,EventLoopGroup的作用是类似于我们分布式的“集群”机器服务来对外提供服务的,分担高并发的连接压力,那么对于服务端channel而言呢,提供EventLoopGroup如果指定的线程数量大于1,这个时候EventLoopGroup又起到什么作用呢?其实对于服务端的channel,我们很多时候并不仅仅是处理连接的接收,还要在处理连接之前做一些鉴权校验抑或是风控等安全措施的处理,如果这些过程会比较耗时,那么就需要在我们处理的handler上添加从Group选举一个新的EventLoop事件轮询活动来缓解我们并发连接调度处理能力,其实说到底Group还是类似于分布式系统中的“集群”来缓解并发调度的压力.</p>
<p>于是基于上述的分析,我们对Netty支撑高并发采用的技术手段总结如下:</p>
<ul>
<li>使用NIO模型实现多连接的可伸缩性扩展,同时引入Reactor模式以及责任链设计在原有的基础上使得Netty可伸缩性更为灵活,能够支撑更多的并发连接调度.</li>
<li>其次,Netty设计通过为每个执行的事件轮询EventLoop分配独有的线程,保证了每个事件轮询器之间处理的流水工作相互独立,同时也保证了在当前EventLoop下执行的所有流水工作都是专属于专有的线程,不存在资源竞争以及锁争用的情况,基于此,在多核环境下我们可以充分利用多核技术进一步去提升我们的并发连接调度处理能力.</li>
<li>最后一个就是Netty通过EventLoopGroup的“集群”手段来分担我们web服务的并发连接调度处理能力,有效缓解对单个线程处理并发连接的压力,提升并发连接调度的处理能力.</li>
</ul>
<h4 id="Netty高性能之ByteBuf"><a href="#Netty高性能之ByteBuf" class="headerlink" title="Netty高性能之ByteBuf"></a>Netty高性能之ByteBuf</h4><h5 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h5><p>对于linux操作系统读取数据块一般流程是:先从硬件设备将数据块加载数据到内核缓冲区,然后由内核将内核缓冲区的数据复制到用户空间的缓冲区,最后唤醒应用程序读取用户空间的缓冲区,对于Java程序而言,其无法直接操作OS系统内存区域,必须通过JVM堆申请内存区域来存放数据块,于是需要再从OS内存中的数据缓冲区将数据块复制到JVM堆中才能够进行操作数据,于是对于JVM操作socket的数据包,数据包拷贝的路径如下图示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_direct_bytebuf.jpg"></p>
<p>网卡设备接收到数据包流量事件,内核将数据块加载到内核缓冲区中,并且通过socket传输数据到用户空间的缓冲区,最后JVM要操作socket缓冲区的数据,需要将其读取到JVM堆中存储,这个时候需要再JVM堆中申请一个内存区域用于存放数据包数据,而如果直接通过堆外内存读取数据,则可以减少一次数据的拷贝以及内存资源的损耗,如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_direct_references.jpg"></p>
<p>Netty的堆外内存操作通过底层操作系统Unsfe的方式获取其内存位置来直接操作内存,相比使用堆内存分配更为高性能便利,同时也减少了数据拷贝,直接通过Unsafe指向的堆外内存引用来进行操作.</p>
<h5 id="零拷贝机制"><a href="#零拷贝机制" class="headerlink" title="零拷贝机制"></a>零拷贝机制</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设buffer1以及buffer2都存储在堆外内存,堆内内存同理(只是在JVM中)</span></span><br><span class="line">ByteBuf httpHeader = buffer1.silice(OFFSET_PAYLOAD, buffer1.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line">ByteBuf httpBody = buffer2.silice(OFFSET_PAYLOAD, buffer2.readableBytes() - OFFSET_PAYLOAD);</span><br><span class="line"><span class="comment">// 逻辑上的复制,header与body仍然存储在原有的内存区域中,http为JVM在堆中创建的对象,指向一个逻辑结构上的ByteBuf</span></span><br><span class="line">ByteBuf http = ChannelBuffers.wrappedBuffer(httpHeader, httpBody);</span><br></pre></td></tr></table></figure>

<p>上述的零拷贝机制示意图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/zero_copy.jpg"></p>
<p>这个时候在应用程序中可以直接通过http的ByteBuf操作合并之后的header+body的ByteBuf缓冲区,http的byteBuf是属于逻辑上的合并,实际上并没有发生数据拷贝,只是在JVM中创建一个http的ByteBuf引用指向并操作合并之后的bytebuf.</p>
<h5 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h5><blockquote>
<p>核心源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        checkPositiveOrZero(minNewCapacity, <span class="string">&quot;minNewCapacity&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,</span><br><span class="line">                    minNewCapacity, maxCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> threshold;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">        <span class="comment">//  &gt; 4M</span></span><br><span class="line">        <span class="comment">// cap / 4 * 4 + 4</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">                newCapacity = maxCapacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newCapacity += threshold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">        <span class="comment">// &lt; 4M 进行以2的倍数进行增长</span></span><br><span class="line">        <span class="comment">// 2096，此时分配的内存为3072byte</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上述源码可知:</p>
</blockquote>
<ul>
<li>当写出的数据不足4M的时候,将以64byte为起始值,以2的倍数进行增长扩容</li>
<li>当写出的数据大于4M的时候,将以一个公式<code>newCapacity = capacity/4*4+4</code>进行计算</li>
<li>当写出的数据为4M的时候,直接返回4M预定的默认空间大小</li>
</ul>
<h5 id="引用计数与资源管理"><a href="#引用计数与资源管理" class="headerlink" title="引用计数与资源管理"></a>引用计数与资源管理</h5><p>在ByteBuf添加引用计数能够计算当前对象持有的资源引用活动情况,通常以活动的引用计数为1作为开始,当引用计数大于0的时候,就能够保证对象不会被释放,当引用计数减少到0的时候说明当前对象实例就会被释放,将会被JVM的GC进行回收,对于池化技术而言则是存放到内存池中以便于重复利用.因此使用池化技术的<code>PooledByteBufAllocator</code>而言,使用引用计数能够降低内存分配的开销,有助于优化内存使用和性能的提升.</p>
<ul>
<li>ByteBuf的实现接口ReferenceCounted</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ByteBuf.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuf</span> <span class="keyword">implements</span> <span class="title">ReferenceCounted</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteBuf</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> refCnt() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractByteBuf.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title">ByteBuf</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于引用计数为0的实例将无法访问,会抛出异常IllegalReferenceCountException</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkAccessible &amp;&amp; !isAccessible()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReferenceCounted.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReferenceCounted</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用retain(increament) 将会增加引用计数increament</span></span><br><span class="line">   <span class="comment">// 调用release(increament)将会减少引用计数increament</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ChannelHandler的资源管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于入站事件,如果当前消费入站数据并且没有事件进行传播的话,那么就需要手动释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// not call fireChannelRead,事件传播在当前handler终止,这个时候需要手动清除</span></span><br><span class="line">  ReferenceCountUtil.release(msg);</span><br><span class="line">  <span class="comment">// SimpleChannelInboundHandler能够手动清除,但是一般入站事件我个人习惯用ChannelInboundHandlerAdapter并且自己手动管理,方法单一,处理简单,可以手动管理,同理出站事件也是用Adapter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于出站事件,如果当前需要对非法消息采取丢弃操作,则也需要手动进行处理释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWrite</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span>&#123;</span><br><span class="line">  ReferenceCountUtil.release(msg);</span><br><span class="line">  promise.setSuccess(); <span class="comment">// 丢弃消息意味着不会将数据传输到出站事件的责任链上,这个时候FutureListener无法监听到消息处理情况,需要手动通知处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Netty的资源监控类ResourceLeakDetector</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 关于监控类的级别详细查看Netty类下的ResourceLeakDetector</span></span><br><span class="line"><span class="comment">## 通过java配置并执行可以查看资源泄漏情况以及输出报告</span></span><br><span class="line">java -Dio.netty.leakDetection.level=ADVANCED</span><br></pre></td></tr></table></figure>

<h5 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h5><ul>
<li>入口程序</li>
</ul>
<p>首先,Netty处理读写事件默认分配的内存Allocator源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Channel的时候会创建默认的AdaptiveRecvByteBufAllocator,不论是客户端还是服务端channel</span></span><br><span class="line"><span class="comment">// DefaultChannelConfig.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelConfig</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(channel, <span class="keyword">new</span> AdaptiveRecvByteBufAllocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的DefaultChannelConfig类图如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/config_class.jpg"></p>
<p>其次,我们关注socket的读写事件,也就是NioSocketChannel的相关事件,在NioEventLoop下的run方法定位到对应的unsafe的read方法,如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioByteChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 根据上述的config可以定位到是默认使用池化的内存分配器,默认为池化分配且为堆外内存分配</span></span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// RecvByteBufAllocator默认为AdaptiveRecvByteBufAllocator</span></span><br><span class="line">  <span class="comment">// allocHandle为AdaptiveRecvByteBufAllocator下的HandleImp,而HandleImp继承MaxMessageHandle</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//我们关注byteBuf的分配,调用上述的handler的allocate方法</span></span><br><span class="line">  byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxMessageHandle.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用池化的分配器创建ioBuffer</span></span><br><span class="line">  <span class="comment">// 根据数据包的大小计算要申请的内存区域大小,每个区域大小都存储在一个table表中进行存储,每次计算都会通过二分查找来搜索适合当前数据包存储的数据</span></span><br><span class="line">  <span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着,我们现在需要关注的是池化分配器的ioBuffer方法,其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractByteBufAllocator.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据上述传递进来的数据包进行创建</span></span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">    <span class="comment">// 默认执行方式</span></span><br><span class="line">    <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledByteBufAllocator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBufAllocator</span> <span class="keyword">extends</span> <span class="title">AbstractByteBufAllocator</span> <span class="keyword">implements</span> <span class="title">ByteBufAllocatorMetricProvider</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 默认使用堆外内存策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PooledByteBufAllocator DEFAULT =</span><br><span class="line">            <span class="keyword">new</span> PooledByteBufAllocator(PlatformDependent.directBufferPreferred());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配bytebuf策略</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用线程缓存技术,类似于jemalloc的可伸缩的内存分配策略</span></span><br><span class="line">        PoolThreadCache cache = threadCache.get();</span><br><span class="line">        PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">        <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                    <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们可以看到,Netty采用的ByteBuf是使用池化且堆外内存分配的方式,如果OS支持Unsafe操作则默认为Unsafe操作,接下来我们来关注分配算法的核心代码</p>
<ul>
<li>内存分配算法的核心代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span></span><br><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">  allocate(cache, buf, reqCapacity);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到上述存在两个部分,一个是创建池化的ByteBuf,一个是从内存中申请资源存储数据</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建池化的ByteBuf源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">    <span class="comment">// 直接创建一个ByteBuf</span></span><br><span class="line">    <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledUnsafeDirectByteBuf.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里面的代码不深挖</span></span><br><span class="line">  <span class="comment">// 核心处理流程: 先从线程缓存获取栈，从栈获取buf，如果不存在则将创建ByteBuf并存储栈中,最后更新栈数据并一并更新到到线程的cache中</span></span><br><span class="line">  PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">  <span class="comment">// 重置buf的引用计数</span></span><br><span class="line">  buf.reuse(maxCapacity);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分配内存算法源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算合适的一个区域</span></span><br><span class="line">  <span class="comment">// 比如现在申请一个资源为19byte,则会为其创建一个2的临近整数方,这个时候会分配一个32byte的数据</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请的容量小于8kb</span></span><br><span class="line">  <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; </span><br><span class="line">    <span class="keyword">int</span> tableIdx;</span><br><span class="line">    PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">    <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">    <span class="comment">// 容量小于512byte</span></span><br><span class="line">    <span class="keyword">if</span> (tiny) &#123;</span><br><span class="line">      <span class="comment">// 从缓存中获取</span></span><br><span class="line">      <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tableIdx = tinyIdx(normCapacity);</span><br><span class="line">      table = tinySubpagePools;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分配的容量大于512byte小于8kb</span></span><br><span class="line">      <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tableIdx = smallIdx(normCapacity);</span><br><span class="line">      table = smallSubpagePools;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">      <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">      <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">        <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">        <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">        <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">        s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity);</span><br><span class="line">        incTinySmallAllocation(tiny);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incTinySmallAllocation(tiny);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 容量大于等于8kb小于16M</span></span><br><span class="line">  <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">      ++allocationsNormal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &gt; 16M,直接从操作系统中申请资源并且不做缓存和池化处理,于是不会添加到arena中</span></span><br><span class="line">    <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">    allocateHuge(buf, reqCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>摘录实际分配内存源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PoolArena.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">       q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">       q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add a new chunk.</span></span><br><span class="line">   <span class="comment">// pageSize = 8kb</span></span><br><span class="line">   <span class="comment">// maxOrder = 11</span></span><br><span class="line">   <span class="comment">// pageShifts = 18</span></span><br><span class="line">   <span class="comment">// chunkSize = 16M</span></span><br><span class="line">   PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">   <span class="keyword">boolean</span> success = c.allocate(buf, reqCapacity, normCapacity);</span><br><span class="line">   <span class="keyword">assert</span> success;</span><br><span class="line">   qInit.add(c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoolChunk.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个subpage</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> handle;</span><br><span class="line">  <span class="keyword">if</span> ((normCapacity &amp; subpageOverflowMask) != <span class="number">0</span>) &#123; <span class="comment">// &gt;= pageSize</span></span><br><span class="line">    handle =  allocateRun(normCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &lt; 8kb</span></span><br><span class="line">    handle = allocateSubpage(normCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存队列获取nioBuffer</span></span><br><span class="line">  ByteBuffer nioBuffer = cachedNioBuffers != <span class="keyword">null</span> ? cachedNioBuffers.pollLast() : <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 填充实际数据</span></span><br><span class="line">  initBuf(buf, nioBuffer, handle, reqCapacity);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注allocateSubpage以及allocateRun方法,最终会执行allocateNode,这里只分析allocateSubpage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从arena查询对应的区域类型的PoolSubPage</span></span><br><span class="line">  PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">  <span class="keyword">int</span> d = maxOrder; </span><br><span class="line">  <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储subpage的池大小为8kb</span></span><br><span class="line">    <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line">    freeBytes -= pageSize;</span><br><span class="line">    <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">    PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">    <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建一个容量大小为normCapacity的subpage来存储数据</span></span><br><span class="line">      subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">      subpages[subpageIdx] = subpage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      subpage.init(head, normCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成分配并返回subpage的bitmap</span></span><br><span class="line">    <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>分配的数据存储到线程缓存的源码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于池化技术,有一点就是一旦数据释放的时候将会将资源进行回收重复利用.于是当调用byteBuf进行数据回收的时候,会执行以下动作</span></span><br><span class="line"><span class="comment">// 入口代码</span></span><br><span class="line">ReferenceCountUtil.release(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上述我们已经知道默认使用PooledByteBuf,于是如果msg为PooledByteBuf,当进行资源回收的时候,就会执行以下的动作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledByteBuf</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">    <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">    memory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里进行资源回收</span></span><br><span class="line">    chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);</span><br><span class="line">    tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">    chunk = <span class="keyword">null</span>;</span><br><span class="line">    recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">    destroyChunk(chunk);</span><br><span class="line">    activeBytesHuge.add(-size);</span><br><span class="line">    deallocationsHuge.increment();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">    <span class="comment">// 可以看到这里将数据添加到线程缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">      <span class="comment">// cached so not free it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeChunk(chunk, handle, sizeClass, nioBuffer, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此,Netty从分配到回收一个池化的ByteBuf工作流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_cache_flow.jpg"></p>
<p>Netty内存分配逻辑结构视图:</p>
<ol>
<li>从宏观上看,线程与Arena之间的关系:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_arena.jpg"></p>
<ol start="2">
<li>从微观上看每个arena存储数据过程,在上述源码中我们看到在没有使用线程缓存的时候,会创建一个PoolChunk对象,在这个PoolChunk中对于小于8kb的数据会通过维护着一个subpage类型的数组来组成一个page,我们可以认为把存储数据的buffer存放在一个chunk的一个page,并且每个page的容量都是2幂次方且单位为byte,在chunk为了便于搜索可用的page,于是在逻辑上将page以完全二叉树的数据结构进行存储,方便进行搜索查询,每个二叉树节点存储对应一个可分配的容量,根容量为16M,深度每增加1,容量就减半.如下图所示:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_chunk.jpg"></p>
<ol start="3">
<li>最后我们看下线程缓存存储的逻辑结构(基于可伸缩性的jemalloc算法):</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_thread_cache.jpg"></p>
<p>上述的Tiny MemoryRegionCache对应于TinySubPageCache,Small MemoryRegionCache对应于SmallSubPageCache,而Normal MemoryRegionCache对应于NormalCache.</p>
<p>最后,我们根据源码将内存分配策略如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_cache_memory.jpg"></p>
<blockquote>
<p>jemalloc算法</p>
</blockquote>
<ul>
<li>工作原理</li>
</ul>
<ol>
<li>按照对象的大小划分存储对象等级区域,比如tiny对象,Small对象,Normal对象以及Large对象等</li>
<li>划分尺寸等级,根据传递分配对象大小来技计算合适当前对象存储的区域,比如7kb与5kb的数据都会存储在一个大小为8kb的chunk的内存区域,且每个chunk的内存区域都是连续并且组成一个page.</li>
<li>控制分配器元数据的开销并严格限制为少于总内存的2%</li>
<li>最小化活动页面集,在操作系统内核中,通常是4kb来管理虚拟内存,即将所有数据集中到尽可能少地页存储,好比上述第2点所讲的,多个chunk组成一个page.</li>
<li>最小化锁争用,为了保证并发读写数据的效率,需要为执行的线程指定特定的线程缓存,避免线程操作同一个内存区域时竞争锁导致性能下降.</li>
<li>能够提供可扩展性的分配器,即可以有开发人员指定也可以由部分技术框架默认提供.</li>
</ol>
<ul>
<li>数据大小类别</li>
</ul>
<ol>
<li>Small: [8], [16, 32, 48, …, 128], [192, 256, 320, …, 512], [768, 1024, 1280, …, 3840]<br>2 .Large: [4 KiB, 8 KiB, 12 KiB, …, 4072 KiB]</li>
<li>Huge: [4 MiB, 8 MiB, 12 MiB, …]</li>
</ol>
<ul>
<li>逻辑视图:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/jemalloc_arean.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/thread_cache_arena.jpg"></p>
<h4 id="Netty高效处理机制"><a href="#Netty高效处理机制" class="headerlink" title="Netty高效处理机制"></a>Netty高效处理机制</h4><h5 id="解决空轮询的源码"><a href="#解决空轮询的源码" class="headerlink" title="解决空轮询的源码"></a>解决空轮询的源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.java</span></span><br><span class="line"><span class="comment">// 仅摘录部分代码</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  <span class="comment">// 可配置select的循环次数,当网络数据包一直不可达的时候,通过次数控制减少当前selector不断无结果的空轮询,一旦超过次数将会重建selector,将原有的selector关闭,避免cpu飙升.</span></span><br><span class="line">    <span class="keyword">int</span> selectorAutoRebuildThreshold = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.selectorAutoRebuildThreshold&quot;</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (selectorAutoRebuildThreshold &lt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">      selectorAutoRebuildThreshold = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">       select();</span><br><span class="line">     &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">     selectCnt++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪事件</span></span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    ranTasks = runAllTasks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ranTasks || strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">       logger.debug(...);</span><br><span class="line">      selectCnt = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="comment">// Unexpected wakeup (unusual case)</span></span><br><span class="line">      selectCnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unexpectedSelectorWakeup方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unexpectedSelectorWakeup</span><span class="params">(<span class="keyword">int</span> selectCnt)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">    <span class="comment">// 超过一定的次数之后重建selector,如何重建这里不贴代码</span></span><br><span class="line">    rebuildSelector();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用责任链机制实现无锁串行化任务"><a href="#使用责任链机制实现无锁串行化任务" class="headerlink" title="使用责任链机制实现无锁串行化任务"></a>使用责任链机制实现无锁串行化任务</h5><p>基于事件轮询器的源码与线程模型可知,分配给每个EventLoop的专属线程都会负责处理select之后的就绪事件集合以及所有在阻塞队列中的任务,且线程与EventLoop通过FastThreadLocal进行绑定,也就是说所有事件的处理与任务的执行都是处于一个线程中,从而保证事件处理与任务处理都是保持在同一个线程中,同时与了保持一个channelHandler实例能够共享于多个pipeline中,需要通过注解@Shareble方式来保证线程安全.于是对于Netty处理的任务还是channelHandler下的完成事件处理都是能够得到线程安全的保证,于是对于无锁串行化的描述如下图:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_unlock_pipeline.jpg"></p>
<h5 id="使用并发库"><a href="#使用并发库" class="headerlink" title="使用并发库"></a>使用并发库</h5><p>在先前的高性能IO设计一文中有说到,在资源竞争的环境下,使用并发库甚至是无锁编程能够提升程序的性能,避免锁的争抢与等待.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_java_cocurrent.jpg"></p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/netty/feature/netty_java_cocurrent1.jpg"></p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote>
<p>C10K &amp; C10M</p>
</blockquote>
<ul>
<li><a href="http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html">http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/C10k_problem">https://en.wikipedia.org/wiki/C10k_problem</a></li>
</ul>
<blockquote>
<p>高性能</p>
</blockquote>
<ul>
<li><a href="http://pl.atyp.us/content/tech/servers.html">http://pl.atyp.us/content/tech/servers.html</a></li>
</ul>
<blockquote>
<p>基于可伸缩性的jemalloc算法</p>
</blockquote>
<ul>
<li><a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf</a></li>
<li><a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919</a></li>
</ul>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO事件驱动设计实现</title>
    <url>/2020/04/23/proactor/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="事件驱动架构EDA"><a href="#事件驱动架构EDA" class="headerlink" title="事件驱动架构EDA"></a>事件驱动架构EDA</h3><h4 id="EDA组件"><a href="#EDA组件" class="headerlink" title="EDA组件"></a>EDA组件</h4><ul>
<li>事件源/发起器(event emitters): 负责轮询检测事件状态的变化</li>
<li>解复用器(Demultiplexer): 等待从事件源上获取就绪事件的集合,并将就绪事件通过转发器分发给响应就绪事件的处理器进行回调处理</li>
<li>事件处理引擎(event handlers): 响应就绪事件发生的处理程序,由开发人员在应用程序上进行定义并针对就绪事件发生的状态进行注册绑定</li>
<li>事件队列(event queue): 或者称为事件通道,可以理解为注册绑定对应的事件存储的位置,一旦就绪事件发生,解复用器就会从事件队列中检测并返回对应的就绪事件</li>
</ul>
<h4 id="EDA组件运作与设计"><a href="#EDA组件运作与设计" class="headerlink" title="EDA组件运作与设计"></a>EDA组件运作与设计</h4><h5 id="简要流程"><a href="#简要流程" class="headerlink" title="简要流程"></a>简要流程</h5><p><img src="https://img-blog.csdnimg.cn/20200410121142540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="AWT完整事件流程"><a href="#AWT完整事件流程" class="headerlink" title="AWT完整事件流程"></a>AWT完整事件流程</h5><p><img src="https://img-blog.csdnimg.cn/20200410121157805.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于AWT事件的设计需要有客户端,事件源(发生器),事件通道,事件处理器以及事件对象组件一起配合完成完整的点击事件流程,基于监听者模式的设计思路如下:</p>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要注册和绑定处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取事件源</span></span><br><span class="line">   	Button button = <span class="keyword">new</span> Button();</span><br><span class="line">    <span class="comment">// 绑定事件源</span></span><br><span class="line">    button.bind(<span class="string">&quot;click&quot;</span>, <span class="keyword">new</span> ClickHandler());</span><br><span class="line">    <span class="comment">// 执行点击事件</span></span><br><span class="line">    button.click();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件处理器定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ActionHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(ActionEvent e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickListener</span> <span class="keyword">implements</span> <span class="title">ActionHandler</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 类似于上述的handler,用于处理点击事件的响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件源定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个时候Button只是一个普通class,我们知道事件源需要具备检测监听的行为,对此继承监听者的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这个时候click只是一个普通方法  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在上述事件流程可知,要让click事件被传播,需要借助事件通道进行传播执行回调,此时触发监听传播</span></span><br><span class="line">  	 <span class="keyword">this</span>.trigger(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 事件源还需要具备绑定具体的动作行为</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String type, ActionHandler handler)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在上述的事件流程中,将其绑定到事件通道中</span></span><br><span class="line">    <span class="comment">// 存储哪个事件源 哪个事件行为类型, 对应的处理动作</span></span><br><span class="line">    <span class="keyword">this</span>.store(<span class="keyword">this</span>, type, handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件通道组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为通道组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义map存储事件类型以及对应的事件,作为存储事件的通道</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, ActionEvent&gt; events = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(Object source, String type, ActionHandler hander)</span></span>&#123;</span><br><span class="line">    events.put(type, <span class="keyword">new</span> ActionEvent(source, handler, type));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trigger</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从事件通道中搜索事件,并回调执行事件</span></span><br><span class="line">    ActionEvent event = map.get(type);</span><br><span class="line">    Object target = event.getTarget();</span><br><span class="line">    Method callback = target.getClass(),getDeclaredMethod(<span class="string">&quot;handler&quot;</span>, ActionEvent.class);</span><br><span class="line">    callback.invoke(target, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过上述的事件通道组件可知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionEvent</span></span>&#123;</span><br><span class="line">   <span class="comment">// 定义事件源</span></span><br><span class="line">  <span class="keyword">private</span> Object source;</span><br><span class="line">  <span class="comment">// 定义处理事件的目标处理器</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="comment">// 定义事件的类型</span></span><br><span class="line">  <span class="keyword">private</span> String eventType;</span><br><span class="line">  <span class="comment">// ..others such as status, timestamp, id etc....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后,关于编程设计的一个思考,就是在推导设计的时候,可以尝试借用TDD的方式进行编程设计,先预先定义自己想要实现的效果,一步步从最简单的目标效果思考逼近最终的设计。<br>好了言归正传,通过上述的一个设计思路,我们接下来要思考如何实现一个IO事件驱动设计呢?对此,先从简单的网络NIO事件处理流程开始.</p>
<h5 id="网络NIO事件处理流程"><a href="#网络NIO事件处理流程" class="headerlink" title="网络NIO事件处理流程"></a>网络NIO事件处理流程</h5><p>对于web服务设计,主要处理服务端监听连接并接收客户端连接事件以及客户端发起服务端读取事件,这里主要以服务端的设计为准.</p>
<ul>
<li>服务端监听连接事件流程 – Accept事件流程</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200410121227737.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>上述的Accept监听是对服务端的ServerSocket进行连接事件的监听.</p>
<ul>
<li>服务端读取事件流程 – 响应IO事件流程</li>
</ul>
<p>在先前的Unix的IO模型中,真正进行IO操作的是调用<code>recvfrom</code>方法产生阻塞,对于非阻塞IO是当内核真正接收到可操作的IO事件时候才发起<code>recvfrom</code>方法,对此这里的事件是指对客户端socket的读取事件进行监听,在上述建立连接监听的基础上,事件读取流程如下<br><img src="https://img-blog.csdnimg.cn/20200410121253498.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>上述是一个完整的IO事件连接与读取流程,可以看出,最左边的一个是事件处理器负责处理事件状态发生变化的一个响应,而右边的一侧则是属于处理网络IO事件的监听,此时所有的资源都阻塞该非阻塞IO的API调用,通过接收到就绪事件的通知由内核发起唤醒回调并返回就绪事件集合,然后传输给响应事件的处理器,于是也就有了Reactor反应器设计.</p>
<h4 id="Reactor设计原理"><a href="#Reactor设计原理" class="headerlink" title="Reactor设计原理"></a>Reactor设计原理</h4><h5 id="Reactor运作流程"><a href="#Reactor运作流程" class="headerlink" title="Reactor运作流程"></a>Reactor运作流程</h5><p>通过上述的NIO事件流程可知,对于web服务端而言,一个是我们需要关注IO轮询就绪事件以及获取就绪事件集合的操作,另一个是关注响应IO就绪事件的处理,主要包含连接的响应处理以及读取请求处理的响应处理,可以从宏观上,引入中间组件分别处理上述事件的轮询监听以及事件响应操作,在Reactor设计中,Reactor组件负责实现事件的轮询监听操作,Handler负责就绪事件的响应操作,对此,一个Reactor模式的简要事件流程如下:<br><img src="https://img-blog.csdnimg.cn/2020041012131717.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>对此,一个Reactor模式的web服务设计实现需要两个核心组件,即:Handler以及Reactor:</p>
<ul>
<li>Handler则需要拆分伪<code>RequestHandler</code>以及<code>Acceptor</code>两个处理器,</li>
<li>Reactor组件中,参与的工作有注册绑定操作,IO事件的监测以及就绪事件的转发操作,同时也可以看到Reactor与系统内核之间都通过socket事件源来感知到事件状态的变化,是系统内核与Reactor之间通信的一个重要渠道,即网络设备接收到连接或者请求操作唤醒socket然后异步回调让Reactor获取CPU执行权,这个时候Reactor获取到socket事件为就绪事件.</li>
</ul>
<h5 id="Reactor组件具体实现"><a href="#Reactor组件具体实现" class="headerlink" title="Reactor组件具体实现"></a>Reactor组件具体实现</h5><p>现理清Reactor整个事件流程之后,接下来要思考如何实现,先从一个服务端入口程序开始一步步往后推导.</p>
<ul>
<li>服务端入口程序(也可以称为客户端)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用java实现一个简易版本的Reactor模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOReactorServer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">     	<span class="comment">// ServerSocketChannel 类似Button</span></span><br><span class="line">      ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">      server.bind(<span class="keyword">new</span> InetSocketAddress(port), MaxBackLogs);</span><br><span class="line">      server.configurable(<span class="keyword">false</span>);</span><br><span class="line">     <span class="comment">// 类似于button.bind操作</span></span><br><span class="line">      Reactor reactor = <span class="keyword">new</span> Reactor();</span><br><span class="line">      Handler request = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">      reactor.register(ACCEPT, server, <span class="keyword">new</span> Acceptor(request));</span><br><span class="line">     <span class="comment">// 类似于button.click();只不过这里是处于阻塞等待事件</span></span><br><span class="line">      reactor.handle_events();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义事件处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptorHandler</span><span class="params">(SelectableChannel server)</span></span>&#123;</span><br><span class="line">       <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestHandler</span><span class="params">(SelectableChannel client)</span></span>&#123;</span><br><span class="line">       <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端处理Acceptor服务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Handler handler;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(Hanlder handler)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptorHandler</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 需要从server中获取客户端的socket</span></span><br><span class="line">       Socket client = key.channel().accept();</span><br><span class="line">       <span class="comment">// 重新注册到reactor上</span></span><br><span class="line">       reactor.register(READ, client, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端处理Request请求操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestHandler</span><span class="params">(Request req,Response resp)</span></span>&#123;</span><br><span class="line">      <span class="comment">// decode </span></span><br><span class="line">      <span class="comment">// process</span></span><br><span class="line">      <span class="comment">// encode </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Reactor组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了保证实现的Reactor是通用的,这里不使用java的NIO实现,仅用java伪代码实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 事件通道,在Java中是使用SelectionKey保存每个socket事件</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;SelectionKey, Invoker&gt; acceptMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;SelectionKey, Invoker&gt; readMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Selector demultiplexer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.demultiplexer = Selector.open();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String type,SelectableChannel socket, Handler handler)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 向系统内核注册socket事件并投递到事件等待队列中</span></span><br><span class="line">      <span class="keyword">if</span> (ACCEPT.equals(type))&#123;</span><br><span class="line">        socket.register(demultiplexer, SelectionKey.ACCEPT);</span><br><span class="line">        map.put(socket, <span class="keyword">new</span> Invoker(ACCEPT,handler));</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(READ.equals(type))&#123;</span><br><span class="line">        socket.register(demultiplexer, SelectionKey.READ, <span class="keyword">new</span> Request());</span><br><span class="line">        map.put(socket, <span class="keyword">new</span> Invoker(READ,handler));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; readySet = demultiplexer.select();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = readySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">          SelectionKey key = it.next();</span><br><span class="line">          it.remove();</span><br><span class="line">            <span class="keyword">if</span> (acceptMap.keys().contains(key))&#123;</span><br><span class="line">               dispatch(ACCEPT, key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(readMap.keys().contains(key))&#123;</span><br><span class="line">                dispatch(READ, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       readySet.clear();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String type,Selection key)</span></span>&#123;</span><br><span class="line">    Invoker invoker = <span class="keyword">null</span>;</span><br><span class="line">    Method method = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ACCEPT == type)&#123;</span><br><span class="line">         invoker = acceptMap.get(key);</span><br><span class="line">         method = invoker.getCallbackMethod();</span><br><span class="line">        <span class="comment">// method callback</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(READ == type)&#123;</span><br><span class="line">         invoker = readMap.get(key);</span><br><span class="line">         method = invoker.getCallbackMethod();</span><br><span class="line">         <span class="comment">// read data ...</span></span><br><span class="line">         Request req = (Request)key.attachement();</span><br><span class="line">         req.setData(readData);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// using method callback (pass req and resp)</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// write data ...</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以理解为事件通道</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Handler handler;</span><br><span class="line">   <span class="keyword">private</span> Method method;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(String type,Handler handler)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    <span class="keyword">if</span>(ACCEPT == type)&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = <span class="keyword">this</span>.handler.getClass().getDeclaredMethod(<span class="string">&quot;acceptHandler&quot;</span>, SelectionKey.class);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(READ == type)&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = <span class="keyword">this</span>.handler.getClass().getDeclaredMethod(<span class="string">&quot;requestHandler&quot;</span>, Request.class, Response.class);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.handler;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Method <span class="title">getCallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过上述部分伪代码的设计实现,一个通用的NIO设计组件结构如下所示:</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200410121338567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>关于Reactor使用Java的NIO实现,后面讲述netty的时候会更为详细,这里主要是说明Reactor设计的实现思路,最后通过实现Reactor时序展示运作流程,以epoll/kqueue为准,如果为select,那么图中的第2步和下面的事件轮询都是合并在同一步操作中</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200410121352233.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们可以来了解下IO事件驱动设计的异步实现原理,即Proactor模式实现</p>
<h4 id="Proactor设计原理"><a href="#Proactor设计原理" class="headerlink" title="Proactor设计原理"></a>Proactor设计原理</h4><h5 id="AIO模型以及API"><a href="#AIO模型以及API" class="headerlink" title="AIO模型以及API"></a>AIO模型以及API</h5><p>在IO事件驱动设计实现,还有另一种实现模式,即Proactor模式,以网络AIO模型为基础,面向IO事件编程的一种模式</p>
<ul>
<li>AIO使用的API</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将处理请求入队进行异步读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb *aiocbp)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回aio的处理结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">aio_return</span><span class="params">(struct aiocb *aiocbp)</span></span>;</span><br><span class="line"><span class="comment">// 将处理请求入队进行异步写出</span></span><br><span class="line"><span class="built_in">aio_write</span>()</span><br><span class="line"><span class="comment">// 对一个IO同步操作入队并通过异步的方式执行</span></span><br><span class="line"><span class="built_in">aio_fsync</span>()</span><br><span class="line"><span class="comment">// 返回入队异步执行请求的错误</span></span><br><span class="line"><span class="built_in">aio_error</span>()</span><br><span class="line"><span class="comment">// 挂起调用者直到有一个或者多个就绪事件发生  </span></span><br><span class="line"><span class="built_in">aio_suspend</span>()</span><br><span class="line"><span class="comment">// 尝试取消IO操作</span></span><br><span class="line"><span class="built_in">aio_cancel</span>()</span><br><span class="line"><span class="comment">// 使用单个函数调用已入队的多个IO请求</span></span><br><span class="line"><span class="built_in">lio_listio</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 携带的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             aio_fildes;     <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">off_t</span>           aio_offset;     <span class="comment">/* IO操作执行的文件位置 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">void</span>  *aio_buf;        <span class="comment">/* 实现数据交换的buffer */</span></span><br><span class="line">    <span class="keyword">size_t</span>          aio_nbytes;     <span class="comment">/* buffer大小 */</span></span><br><span class="line">    <span class="keyword">int</span>             aio_reqprio;    <span class="comment">/* 执行请求的优先级 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>   <span class="comment">/* IO操作完成的时候进行异步回调通知的方法 */</span></span><br><span class="line">    <span class="keyword">int</span>             aio_lio_opcode; <span class="comment">/* 操作类型,仅用于lio_listio*/</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>AIO模型</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200410121416891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Unix网络IO模型中,AIO的工作原理是由应用进程定义好一个异步操作并通过<code>aio_read</code>方法的调用告知内核启动某个操作(异步操作)并在整个操作(等待数据+数据copy)完成之后通知应用进程,同时需要向内核传递文件描述符,缓冲区引用和其大小以及文件的偏移offset,并告知内核完成操作之后如何通知应用进程.</p>
<h5 id="Proactor运作流程"><a href="#Proactor运作流程" class="headerlink" title="Proactor运作流程"></a>Proactor运作流程</h5><p>通过上述的AIO模型分析,我们可以类比Proactor与Reactor实现模式,对于Proactor模式而言,只是使用的IO策略不同,因而在设计的实现细节也会有所不同,可以通过Reactor事件流程,我们可以推测Proactor模式的事件流程如下:<br><img src="https://img-blog.csdnimg.cn/20200410121433152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>通过上述可以粗略看到Proactor模式与Reactor模式在设计思路上是基本一致:</p>
<ul>
<li>1)都是基于事件驱动设计实现,同时将Handler与关注的IO事件操作分离,</li>
<li>2)开发者可以更加集中于Handler的业务实现逻辑,重要的区分在于Reactor依赖的是同步IO的复用器</li>
<li>3)Proactor依赖的是异步IO的复用器实现.同时Proactor的核心操作主要有注册异步操作以及业务处理的Handler</li>
<li>4)异步接收完成操作的通知以及获取就绪事件和对应的完成结果的集合,而Handler与Reactor模式基本一致.</li>
</ul>
<h5 id="Proactor组件具体实现"><a href="#Proactor组件具体实现" class="headerlink" title="Proactor组件具体实现"></a>Proactor组件具体实现</h5><blockquote>
<p>Proactor组件运作流程</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200410121448179.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Proactor组件参与者</p>
</blockquote>
<ul>
<li>Handle: 可以理解为事件源,在这里表示网络socket对象</li>
<li>Completion Handler: 定义一系列接口模板方法用于处理异步操作完成的结果处理逻辑</li>
<li>Proactor: 提供应用程序的事件循环，将完成事件分解为相关的完成处理程序，并分派抽象模板方法来处理结果</li>
<li>Asynchronous Event Demultiplexer: 异步多路复用器,阻塞等待添加到完成队列中的完成事件,并将它们返回给调用者</li>
<li>Completion Event Queue: 对等待多路复用器的完成事件进行缓冲,以便于完成事件的处理Handler能够从队列缓冲中获取相应的completion event进行处理.</li>
<li>异步操作: 主要用于处理程序中长时间持续操作</li>
<li>异步处理器: 绑定在Handle上,负责对监听到Handle执行进行回调唤醒对应的异步操作,生成对应的CompletionEvent并添加到事件的缓冲队列中</li>
<li>Initiator: 本地应用程序服务入口,初始化一个异步操作并注册一个完成处理程序和一个带有异步操作处理器的Proactor,当操作完成时通知它</li>
</ul>
<blockquote>
<p>具体实现</p>
</blockquote>
<p>通过上述组件的协作流程以及Proactor的组件说明,对此,我们可以从主程序入口开始推导Proactor的实现流程.</p>
<ul>
<li>主程序入口Initiator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用java伪代码模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 保存异步操作产生的CompletionEvent</span></span><br><span class="line">    <span class="keyword">final</span> Queue&lt;CompletionEvent&lt;Object&gt;&gt; completedEventQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 初始化一个异步操作,提交给内核接收到事件变化执行异步操作</span></span><br><span class="line">    AsyncOperactionProcessor&lt;Object&gt; processor = <span class="keyword">new</span> AsyncOperactionProcessor&lt;&gt;()&#123;</span><br><span class="line">    		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncOprAccept</span><span class="params">(AsyncChannel channel, Handler&lt;V,A&gt; handler, Object attach)</span></span>&#123;</span><br><span class="line">           <span class="comment">// 操作完成之后创建CompletionEvent</span></span><br><span class="line">           CompletionEvent event = <span class="keyword">new</span> CompletionEvent(channel, handler, attach);</span><br><span class="line">           <span class="comment">// 新的连接</span></span><br><span class="line">           event.setResult(channel);</span><br><span class="line">           <span class="comment">//添加到队列中以便于处理CompletionHandler能够进行处理</span></span><br><span class="line">           completedEventQueue.add(event); </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncRead</span><span class="params">(AsyncChannel channel, Handler&lt;V,A&gt; handler, ByteBuffer result, Object attach)</span></span>&#123;</span><br><span class="line">          <span class="comment">// 操作完成之后创建CompletionEvent</span></span><br><span class="line">          CompletionEvent event = <span class="keyword">new</span> CompletionEvent(channel, handler, attach);</span><br><span class="line">          <span class="comment">// 请求操作</span></span><br><span class="line">          <span class="comment">// 发起读取操作</span></span><br><span class="line">          channel.read(result);</span><br><span class="line">          event.setResult(read.size());</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// write opr ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建server</span></span><br><span class="line">    AsyncServerSocketChannel server = AsyncServerSocketChannel.open().bind(<span class="number">9999</span>);</span><br><span class="line">   	 <span class="comment">// 创建Proactor并注册一个处理Accept的完成事件的Handler</span></span><br><span class="line">    Proactor proactor = <span class="keyword">new</span> Proactor(server, processor, <span class="keyword">new</span> Acceptor(server,processor));</span><br><span class="line">    <span class="comment">// 监听socket事件并处理socket事件</span></span><br><span class="line">    proactor.handle_events();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步操作处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义异步处理器接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncOperactionProcessor</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">asyncAccept</span><span class="params">(AsyncChannel channel, Handler&lt;V,A&gt; handler, A attach)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">asyncRead</span><span class="params">(AsyncChannel channel, Handler&lt;V,A&gt; handler, ByteBuffer result, A attach)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// write opr ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Proactor组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码实现Proactor组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proactor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> AsyncOperactionProcessor processor; </span><br><span class="line">   <span class="keyword">private</span> Handler handler;</span><br><span class="line">   <span class="keyword">private</span> AsyncServerSocketChannel server;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Proactor</span><span class="params">(AsyncServerSocketChannel server, AsyncOperactionProcessor processor, Handler handler)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.server = server;</span><br><span class="line">       <span class="keyword">this</span>.processor = processor;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       	 <span class="comment">// 接收客户端新的请求</span></span><br><span class="line">         Future&lt;Queue&lt;CompletionEvent&gt;&gt; result = <span class="keyword">this</span>.server.accept(<span class="keyword">this</span>.processor, <span class="keyword">this</span>.handler);</span><br><span class="line">         Queue&lt;CompletionEvent&gt; queue = result.get();</span><br><span class="line">         CompletionEvent event = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>((event = queue.pop()) != <span class="keyword">null</span>)&#123; </span><br><span class="line">             dispatch(event);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(CompletionEvent event)</span></span>&#123;</span><br><span class="line">      Handler handler = event.getHandler();</span><br><span class="line">      ParameterizedType type = event.getHandler().getClass().getGenericInterfaces();</span><br><span class="line">      Class&lt;?&gt; resultClass = (Class&lt;?&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">      Class&lt;?&gt; attachClass = (Class&lt;?&gt;) type.getActualTypeArguments()[<span class="number">1</span>];</span><br><span class="line">      Method method = event.getClass().getDeclaredMethod(<span class="string">&quot;completed&quot;</span>, event.getResult(), attachClass);</span><br><span class="line">      method.invoke(handler, event.getResult(), event.getAttachment());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CompletionEvent组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompletionEvent</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> AsyncChannel channel;</span><br><span class="line">   <span class="keyword">private</span> Handle&lt;V, A&gt; handler;</span><br><span class="line">   <span class="keyword">private</span> A attach;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CompletionEvent</span><span class="params">(AsyncChannel channel, Handle&lt;V, A&gt; handler, A attach)</span></span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Handler组件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span>&lt;<span class="title">V</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(V result, A attach)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acceptor类实现Handler,处理对应的业务,即实现客户端socket的注册流程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span>&lt;<span class="title">AsyncSocketChannel</span>, <span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">AcceptorHandler</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> AsyncServerChannel server;</span><br><span class="line">   <span class="keyword">private</span> AsyncOperactionProcessor processor;</span><br><span class="line">     </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(AsyncServerChannel server, AsyncOperactionProcessor processor)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.server = server;</span><br><span class="line">     <span class="keyword">this</span>.processor = processor;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsyncSocketChannel socketChannel, Object attch)</span></span>&#123;</span><br><span class="line">      	ByteBuffer buffer = ByteBuffer.allocate(MAX_SIZEs);</span><br><span class="line">        Handler reqHandler = <span class="keyword">new</span> ReqHandler(<span class="keyword">this</span>.processor, client, read);</span><br><span class="line">        <span class="comment">// val根据业务自定义,可以定义为存储Session信息</span></span><br><span class="line">        <span class="comment">// 注册读取事件并执行异步的读取操作</span></span><br><span class="line">        socketChannel.read(<span class="keyword">this</span>.processor, reqHandler, read, attch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestHandler类实现Handler,处理的对应业务,即处理decode-process-encode操作,同时注册写操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> AsyncSocketChannel client;</span><br><span class="line">   <span class="keyword">private</span> ByteBuffer read; </span><br><span class="line">   <span class="keyword">private</span> AsyncOperactionProcessor&lt;CompletionEvent&gt; processor;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer buffSize, Object attch)</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[buffSize];</span><br><span class="line">        read.flip();</span><br><span class="line">         <span class="comment">// Rewind the input buffer to read from the beginning</span></span><br><span class="line">        read.get(buffer);</span><br><span class="line">        <span class="comment">// deocde </span></span><br><span class="line">        <span class="comment">// process</span></span><br><span class="line">        <span class="comment">// encode</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册写出事件,并以异步的方式执行写出操作</span></span><br><span class="line">        Handler writeHandler = <span class="keyword">new</span> WriteHandler(client);</span><br><span class="line">        ByteBuffer output = ByteBuffer.wrap(buffer);</span><br><span class="line">        client.write(<span class="keyword">this</span>.processor, writeHandler, output, attch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Proactor核心组件都用java模拟出来,主要目的是为了能够更好地去理解Proactor模式,同时对于一个异步处理器以及其中的异步操作,可以将其绑定在对应的AsyncChannel上,由AsyncChannel去实现相应的异步操作就可以将上述的设计变得更为简单,不需要再传递对应的异步操作处理器processor,绑定在channel能够直接传递到系统内核中,当有事件就绪的时候内核直接触发异步操作然后唤醒到应用程序执行操作后的结果处理Handler.在Java的AIO使用的API是<code>CompletionHandler</code>以及<code>AsynchronousChannel</code>之间的协作.最后,基于上述的代码实现,对一个通用的Proactor模式组件设计类图如下:</p>
<p><img src="https://img-blog.csdnimg.cn/20200410121514146.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="Reactor-amp-Proactor小结"><a href="#Reactor-amp-Proactor小结" class="headerlink" title="Reactor&amp;Proactor小结"></a>Reactor&amp;Proactor小结</h4><h5 id="Reactor模式与Proactor模式对比"><a href="#Reactor模式与Proactor模式对比" class="headerlink" title="Reactor模式与Proactor模式对比"></a>Reactor模式与Proactor模式对比</h5><blockquote>
<p>相同点</p>
</blockquote>
<ul>
<li>均是基于事件驱动设计模式的解决方案来设计支持并发连接的web服务,指示如何在网络IO环境中发起,接收就绪事件,解复用事件,分发以及执行不同类型的事件.</li>
<li>提供可重用以及可配置的解决方案和应用程序组件,通过组件分离不同事件的关注点,有助于针对相应的关注点进行调试和优化</li>
</ul>
<blockquote>
<p>不同点</p>
</blockquote>
<ul>
<li>Reactor模式是基于同步多路复用器,使用的非阻塞同步IO的API协作完成,Proactor模式是基于异步多路复用器,使用的是异步IO的API协作完成,整个执行过程都是异步化.</li>
<li>对于异步读取数据(从内核数据复制到用户缓存区)是持续不间断执行,因此会对内存空间的缓存区域造成很大的压力,存储的数据会越来越多,不知道数据什么时候能够被消费完成释放空间,而Reactor模式属于同步读取,不存在对缓存空间的内存压力.</li>
<li>Reactor模式本质上是属于同步操作,而Proactor是属于异步操作,在先前的高性能IO中表述到,同步存在以下几个问题,一个是同步在资源竞争环境下性能会比异步更差些,二是存在可伸缩性问题,Reactor模式是在原有的连接线程架构分离关注点优化,但是在处理有业务逻辑的相关处理时候仍然存在同步的移植以及伸缩问题,也就是对于并发连接的优化上去了,但是对于复杂的QPS仍然会是一个瓶颈.对于Proactor模式的异步操作,其运作效率依赖于内核执行效率,和操作系统有关,无法控制被调度的异步操作以及难以对程序进行调试排错.</li>
<li>Reactor模式是等待就绪事件发生然后依次顺序处理就绪事件,Proactor模式是等待就绪事件完成处理完成之后的</li>
</ul>
<h5 id="Reactor-amp-Proactor使用库"><a href="#Reactor-amp-Proactor使用库" class="headerlink" title="Reactor&amp;Proactor使用库"></a>Reactor&amp;Proactor使用库</h5><ul>
<li>ACE框架: 提供Reactor以及Proactor模式实现,可以了解下UniPi项目,一个并行环境使用ACE的Reactor模式实现并发通信的分布式程序.</li>
<li>Boost.Asio库: 基于Proactor模式提供同步与异步操作提供并行支持</li>
<li>TProactor: 模拟Proactor</li>
</ul>
<blockquote>
<p>一个关于TProactor的性能分析对比如下</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200410121706901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>最后关于Java相关NIO的API</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.oracle.com/javase/7/docs/api/java/nio/package-summary.html</span><br><span class="line">https://www.ibm.com/developerworks/java/library/j-nio2-1/index.html</span><br><span class="line">https://www.javacodegeeks.com/2012/08/io-demystified.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能IO编程设计</title>
    <url>/2020/03/14/reactor/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://dzone.com/articles/understanding-reactor-pattern-thread-based-and-eve</span><br><span class="line">https://en.wikipedia.org/wiki/Reactor_pattern#Structure</span><br><span class="line">https://en.wikipedia.org/wiki/Event_loop</span><br><span class="line">https://en.wikipedia.org/wiki/Proactor_pattern</span><br><span class="line">https://en.wikipedia.org/wiki/Event-driven_architecture</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/pattern_title.jpg"></p>
<p>首先,在讲述高性能IO编程设计的时候,我们先思考一下何为“高性能”呢,如果自己来设计一个web体系服务,选择BIO还是NIO的编程方式呢?其次,我们可以了解下构建一个web体系服务中,为了能够支撑更多的并发连接数,一般会有两种web架构设计方案,即线程架构以及事件驱动设计,在Java的IO设计演进文章已对线程架构设计方案进行详细的阐述,本文主要以事件驱动设计具体实现技术展开讨论.</p>
<h4 id="web体系设计"><a href="#web体系设计" class="headerlink" title="web体系设计"></a>web体系设计</h4><h5 id="何为高性能"><a href="#何为高性能" class="headerlink" title="何为高性能"></a>何为高性能</h5><p>在epoll技术原理分析文章中讲到C10K的优化问题,需要从文件描述符限制,线程资源,内存资源,网络数据包大小传输等方面进行优化,目的是提升web服务的连接调度处理能力,支撑更多的客户端并发连接响应,因此高性能的IO设计意味着(实现IO高性能的目标)需要考虑以下几个方面,即:</p>
<ul>
<li>可以实现并发连接的响应调度,那么web服务可能需要借助多线程技术</li>
<li>在上述基础上可以支撑更多的连接处理,那么web服务能够实现可伸缩</li>
<li>充分利用计算机资源并减少资源的空闲浪费,那么web服务需要尽可能地合理利用CPU/带宽/内存等资源</li>
</ul>
<h5 id="BIO与NIO性能区分"><a href="#BIO与NIO性能区分" class="headerlink" title="BIO与NIO性能区分"></a>BIO与NIO性能区分</h5><p>为了达到web服务的高性能设计目标,我们需要考虑技术落地方案的选择,现有方案有基于’one thread one connection’的BIO以及’one thread one server’的NIO技术实现方式,其次,在这里需要声明一点就是BIO视为单线程的同步操作,NIO视为单线程的异步操作,同时我们也需要关注两种不同IO的实现在性能测试中的结果是如何的,才能有效地帮助我们实现高性能的目标,以下是摘录《 Thousands of Threads and Blocking I/O》的性能测试结果数据,现分析如下:</p>
<blockquote>
<p>异步web与同步web的吞吐量</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/io_straight.jpg"></p>
<p>通过上述可知,在相同的操作系统环境下,同步web的IO吞吐量更高,主要包含以下方面:<br>同步Web的IO模型吞吐量性能要比NIO高出25%-35%,即使使用多个selector的NIO实现方式也无法比基于Linux的NPLT实现同步操作的性能更快</p>
<p>其次,linux内核使用epoll的技术主要是解决poll本身性能以及可伸缩性问题,epoll在技术实现也将通过创建少量线程的方式来提升性能,增加吞吐量的处理能力</p>
<blockquote>
<p>编程方式</p>
</blockquote>
<ul>
<li>NIO编程伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 调用select()</span></span><br><span class="line">    <span class="keyword">int</span> rs = select();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  如果rs没有对应的就绪事件个数，继续select()</span></span><br><span class="line">    <span class="keyword">if</span> (rs &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取可用的key</span></span><br><span class="line">    Set&lt;Keys&gt; keySet = selectKeys();</span><br><span class="line">    <span class="keyword">for</span>(Key key: keySet)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">            client = accept();</span><br><span class="line">            <span class="comment">// register and save the key</span></span><br><span class="line">            client.register(...);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">            <span class="comment">// read();</span></span><br><span class="line">            <span class="comment">// decode();</span></span><br><span class="line">            <span class="comment">// process();</span></span><br><span class="line">            <span class="comment">// encode();</span></span><br><span class="line">            <span class="comment">// write();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BIO编程伪代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    client = accept();</span><br><span class="line">    client.read();</span><br><span class="line">    <span class="comment">// decode();</span></span><br><span class="line">    <span class="comment">// process();</span></span><br><span class="line">    <span class="comment">// encode();</span></span><br><span class="line">    <span class="comment">// write();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述可以看出,BIO是面向单连接处理的编程方式,调用accept以及read方法都需要进行等待就绪状态才能进行下一步操作,而NIO则是面向单线程处理多连接的编程方式(严格意义上是基于事件编程),通过轮询以及就绪事件的遍历来处理就绪事件,相比BIO在实现上会更为复杂些,然而对于实现高性能的IO设计,我们还需要借助多线程技术来实现,下面针对多线程的同步与异步方式进行对比与分析</p>
<blockquote>
<p>多线程环境下同步与异步性能对比</p>
</blockquote>
<p>linux在内核2.6版本之后使用NPTL的规范实现线程技术，空闲的线程成本接近为0，同时线程上下文能够实现更快切换以及尽可能地运行更多线程，如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/thread_context_switch.jpg"></p>
<p>通过上述可知,多线程环境下使用同一个类库进行测试的性能,1000个与1个线程执行的性能效率上相差不大,因此线程上下文切换的成本其实不高<br>然而对于多线程环境的同步操作如下图:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/thread_context_switch2.jpg"></p>
<p>通过上述可知,syncHashMap与HashTable随着增加的线程数,其执行的性能耗时更高,因为同步操作的hashtable和syncHashMap是在线程级别加锁实现顺序的写操作,因此需要等待其他线程执行完成才能被唤醒执行,对于具备“异步”特性的类库则是通过多线程并发方式对容器实现写操作,即同一个时刻可以有多个线程对容器实现写操作.<br>多核环境下的同步与异步性能对比</p>
<blockquote>
<p>单核环境</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/core1.jpg"></p>
<blockquote>
<p>多核环境</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/core2.jpg"></p>
<p>通过上述可知,具备‘异步‘的并发类库不论是在单核还是多核环境下性能基本差不多,但是对于实现同步hashtable的性能在多核环境充分利用cpu核数提升性能,但是在上述我们注意到SyncHashMap执行的性能会更差,为什么?个人理解上述的map类库都是放在相同环境并发执行,而并发环境必然存在资源的竞争,因此对于在激烈的并发竞争环境中,同步操作的成本会更高.</p>
<blockquote>
<p>BIO与NIO分析小结</p>
</blockquote>
<ul>
<li>BIO在吞吐量性能上比NIO的方式更好</li>
<li>BIO编程相比NIO更为简单</li>
<li>对于同步与异步操作,无竞争的同步操作性能更好,而存在竞争的同步操作会降低执行的性能,此时进行同步操作成本更高</li>
<li>线程上下文切换的成本其实并不是特别高,但是在多线程的同步环境下性能损耗的成本更高</li>
<li>另外可以看到并发类库具备更好伸缩性,比如concurrenthashmap与hashtable执行内存IO的写操作,后者需要通过加锁实现线程同步,而前者同样是加锁,但却是分片加锁,使得线程可异步化执行,即同一个对象可以让不同线程进行写操作,这个时候性能上的提升并不依赖于线程资源.</li>
<li>同步操作能够充分利用多核cpu资源来提升性能</li>
</ul>
<p>简而言之,高性能IO设计可以运用分散的思想并借助并发多线程技术以及充分利用计算机资源技术手段来达到目标,同时为了保证web服务可伸缩性,可以考虑引入中间层的思想来解决现有无法扩展的问题,接下来,我们开始进入web服务设计,为了能够支撑更多的并发连接数,一般会有两种web体系架构设计模式,一种是基于线程的架构,另一种是基于事件驱动架构设计.现针对上述两种架构展开分析.</p>
<h5 id="基于线程连接架构-TBA"><a href="#基于线程连接架构-TBA" class="headerlink" title="基于线程连接架构(TBA)"></a>基于线程连接架构(TBA)</h5><p>线程连接架构是基于”每个连接对应每个线程”的设计思想,这样设计主要有以下几个方面考虑：</p>
<ul>
<li>它适用于那些为了与非线程安全的库兼容而需要避免线程化的站点,比如每个线程连接可以使用hashmap来处理当前线程的业务数据等操作,避免产生线程安全问题</li>
<li>使用多模块处理机制隔离每个请求,保证每个请求request之间是相互独立不干扰的</li>
</ul>
<blockquote>
<p>线程与连接1:1模式</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/1_1_thread.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/1_1_thread2.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/1_1_thread3.jpg"></p>
<ul>
<li>上述每一个连接请求都需要创建相应的线程资源来处理对应的每个连接任务</li>
<li>如果需要支撑的连接成千上万,将会导致创建的线程资源个数达到瓶颈,无法满足每连接每线程的目标</li>
<li>创建与销毁线程产生的开销也将会影响性能,执行期间有可能会导致其他线程处于idle状态,浪费资源空间</li>
</ul>
<blockquote>
<p>线程与连接N:M模式</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/m_n_thread.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/m_n_thread2.jpg"><br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/m_n_thread3.jpg"></p>
<ul>
<li>对于线程池技术,如果创建的线程无法来得及处理连接请求那么此时将会把还未处理的连接添加到阻塞队列中,如果是有界队列,那么超出的连接怎么处理,如果是无界队列,那么连接堆积,内存资源以及cpu资源都会成为瓶颈,这些都无法满足我们对于一个高性能web服务的要求,即阻塞队列要应该设置多大才合适?</li>
<li>如果线程池所有的线程处理的连接都保持”keep alive”却没有任何其他业务操作,这个时候也会造成线程空闲,也会导致阻塞队列上的连接一直没有被执行而处于等待状态,出现”假死”状态,即线程池调整的线程数量应当设置多大才能保证被充分利用?</li>
</ul>
<p>基于上述线程架构的问题,引入事件驱动设计方案,接下来我们来看下事件驱动设计是什么,如何解决上述的问题.</p>
<h5 id="事件驱动架构-EDA"><a href="#事件驱动架构-EDA" class="headerlink" title="事件驱动架构(EDA)"></a>事件驱动架构(EDA)</h5><p>在讲述事件驱动设计之前,可以先通过一个简单的示例展开.当我们在前端页面触发点击事件的时候,就会调用对应的一个触发函数来响应对应的点击事件,也就是说开发人员需要通过以下方式来完成一个点击事件的注册与绑定操作:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取button组件</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定点击事件</span></span><br><span class="line">login.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// login process</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对此,我们先梳理下什么是事件,事件系统有哪些组成,最后再根据上述的点击事件将整个事件处理流程以时序图的方式展开.</p>
<blockquote>
<p>事件定义与结构组成</p>
</blockquote>
<ul>
<li>什么是事件:在网络编程中,一个事件可以被定义为网络socket有新的连接,有数据可读,有数据可写等状态的变更,即socket从等待到就绪状态的变化过程,一个事件结构包含事件header以及事件body</li>
<li>事件header: 主要包含事件信息,比如事件名称,发生事件的时间戳以及事件类型</li>
<li>事件body: 提供检测到状态变更的详细信息</li>
<li>事件通知: 事件的变更可以让体系内的其他应用程序知道事件的状态变化,事件通知在事件产生,发布事件,传输事件,检测事件以及事件处理等流程进行传递,事件通知一般是以异步消息方式进行传递</li>
</ul>
<blockquote>
<p>事件流层</p>
</blockquote>
<ul>
<li>事件发射器(event emitters): 负责检测，收集以及传输事件</li>
<li>事件消费者/接收者(event consumer): 负责对产生的事件作出响应(对产生的事件进行处理并响应)或者反应(只负责对产生的事件进行过滤或者验证并传递事件到下一个活动接收者进行处理并响应)</li>
<li>事件通道(event channel): 负责事件传输的组件(事件发送器传输到接收者的管道),可以是TCP/IP连接通道,也可以是通过消息中间件进行传输,还可以是邮件或者是输入文件等形式</li>
</ul>
<p>至此,我们对事件的定义有了基本认知之后,那么对于上述的一个完整的点击事件流程是如何进行运作的呢,现如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/login_event.jpg"></p>
<p>对于EDA的NIO而言,相比上述事件设计是运用相同的思路,但是具体实现的技术方案略有不同,EDA的NIO技术实现是基于Reactor模式,现展开NIO编程的Reactor模式进行分析.</p>
<h4 id="高性能之Reactor设计"><a href="#高性能之Reactor设计" class="headerlink" title="高性能之Reactor设计"></a>高性能之Reactor设计</h4><h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>在一个通用的web服务中,一般具备以下的几方面的特征:</p>
<ul>
<li>web服务实现可扩展,需要借助分散设计的思想来实现</li>
<li>大部分web服务具备的通用逻辑有: 读取请求,对请求数据进行拆包,处理请求业务逻辑,结果返回的数据进行粘包,最后将数据发送到客户端.</li>
<li>对于web服务而言,不同协议在处理拆包-业务处理-粘包过程的实现方式以及成本都会有所不同</li>
</ul>
<p>一般地,对于经典的TBA架构的web服务如下图:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/classic.jpg"></p>
<p>在上述图中看到每个线程处理每个handler,且不讨论先前TBA存在的问题,就可扩展性而言就存在局限性,尤其是针对部分线程执行decode-compute-encode过程中出现耗时缓慢情况时,很难对其进行优化操作,甚至无法通过服务进行配置调优,没有达到高性能的可伸缩性要求.</p>
<h5 id="可伸缩web服务目标"><a href="#可伸缩web服务目标" class="headerlink" title="可伸缩web服务目标"></a>可伸缩web服务目标</h5><ul>
<li>一旦负载过多的时候,能够实现对客户端的降级操作</li>
<li>可以通过增加资源来改进或者完善现有的web服务性能,比如cpu/内存/网络带宽/磁盘IO读写能力等</li>
<li>还要满足低延迟,支撑高峰要求以及服务可用性</li>
<li>可伸缩实现的手段一般采用分而治之的设计思想来解决</li>
</ul>
<h5 id="IO事件驱动架构"><a href="#IO事件驱动架构" class="headerlink" title="IO事件驱动架构"></a>IO事件驱动架构</h5><p>对于一个高性能的IO事件驱动设计,主要包含有以下三个内容:</p>
<ul>
<li>基于上述的事件驱动架构(EDA)原理</li>
<li>借助NIO中非阻塞的API</li>
<li>分而治之的设计思想实现web可伸缩性</li>
</ul>
<p>对于IO事件驱动架构实现的技术主要是使用Reactor模式,现开始进入Reactor模式的分析</p>
<blockquote>
<p>Reactor定义</p>
</blockquote>
<p>反应器设计模式是一个事件处理模式，用于处理一个或多个输入并发地传递给服务处理程序的服务请求。然后，服务处理程序对传入请求进行多路复用，并将它们同步分派给相关的请求处理程序.</p>
<ul>
<li>反应器模式是事件驱动架构的一种实现技术.简而言之,它使用单线程事件循环对资源发出的事件进行阻塞,并将其分配给相应的处理程序和回调.</li>
<li>只要注册了事件的处理程序和回调来处理它们,就不需要阻塞IO.事件是指实例,例如新的传入连接,可以读取,可以写入等操作.这些处理程序或者回调函数可以在多核环境中利用线程池方式实现</li>
<li>这种模式将模块化应用程序级代码与可重复使用的反应堆实现解耦</li>
</ul>
<blockquote>
<p>Reactor组成结构</p>
</blockquote>
<ul>
<li>请求资源:可以为系统提供输入的资源,可以是读取外部文件,接收的网络数据报,其他或当前系统输出资源都可以作为系统输入的资源,在网络编程中请求资源为发起网络请求的socket</li>
<li>同步事件多路复用器:所有的请求资源都阻塞于事件轮询,通过事件轮询检测请求资源是否处于就绪状态,一旦处于就绪状态,多路复用器就会启动资源同步操作,将就绪资源发送到调度程序中处理请求</li>
<li>请求转发器:负责接收多路复用器的就绪资源,并根据请求的资源进行注册或注销对应的请求处理器,交由对应的处理器负责处理请求</li>
<li>请求处理器:在应用程序中定义对应请求资源的请求处理器来完成相应的业务请求并给予请求响应</li>
</ul>
<p>Reactor设计示意图如下</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/reactor_design.jpg"></p>
<p>通过上述示意图可知,Reactor模式在应用程序级别代码交由handler进行处理,而对于整个网络的复用操作交由多路复用器进行处理,实现反应堆的复用与应用程序业务逻辑的解耦,同时可以针对handler处理器进行调优处理以达到handler能够更快速地响应真正的IO事件并返回给客户端程序响应结果.</p>
<h5 id="Reactor核心原理"><a href="#Reactor核心原理" class="headerlink" title="Reactor核心原理"></a>Reactor核心原理</h5><blockquote>
<p>Reactor的事件轮询</p>
</blockquote>
<p>通过上述可知,在事件轮询中包含以下三个步骤:</p>
<ul>
<li>查找所有处于活动状态且未锁定的处理程序,或将其委托给dispatcher实现</li>
<li>依次执行这些处理程序直到完成或者到达它们被阻塞的点.完成的处理程序将会被停用并允许事件循环继续.</li>
<li>重复执行第一个步骤</li>
</ul>
<blockquote>
<p>两个核心参与者</p>
</blockquote>
<ul>
<li>Reactor反应器:也可称为多路复用器,即在单独的线程中运行,它是通过将工作分派给适当的处理程序来响应IO事件.</li>
<li>Handler处理器:处理程序执行与I/O事件有关的实际工作,反应堆通过分派适当的处理程序来响应I/O事件,即处理程序执行非阻塞操作.</li>
</ul>
<blockquote>
<p>Reactor处理流程</p>
</blockquote>
<ul>
<li>Java的Reactor反应器通过调用select()不断监听socket事件的变化,通过NIO的SelectionKey保存当前socket事件变化状态.</li>
<li>当创建服务端socket的时候会将服务端socket进行注册与端口绑定操作,实现端口的监听事件</li>
<li>当客户端与服务端建立连接的时候,服务端socket端口监听到事件变化,此时将客户端的socket注册并保存到SelectionKey中,即Acceptor操作</li>
<li>当客户端发起请求操作时,服务端保存的客户端socket监听到可读事件,将会在Reactor中添加对应的事件响应处理器Handler并由内部的转发器分发到对应的Handler进行处理</li>
<li>Reactor相当于事件的发起器,SelectionKey相当于事件通道,用于保存和投递消息通知,Handler相当于事件消费者,也有称为事件处理引擎.</li>
</ul>
<p>下游事件反应器为可选,主要用于处理返回的结果呈现,可以理解为前端结果展示的组件.</p>
<h5 id="Reactor技术演进"><a href="#Reactor技术演进" class="headerlink" title="Reactor技术演进"></a>Reactor技术演进</h5><p>在文章开头部分讲述到实现高性能的目标,通过对比NIO与BIO的编程设计分析,我们基本上都会基于NIO模式来设计一个高性能的web服务,而一般地,对于NIO服务设计具备高性能的目标,需要借助以下的技术手辅助段来达到目标.</p>
<blockquote>
<p>实现高性能手段</p>
</blockquote>
<ul>
<li>线程池技术:需要关注线程池核数,线程池最大线程数,超时时间,阻塞队列存储的策略,连接负载过多处理策略</li>
<li>NIO提供非阻塞技术:即保证accept以及read操作为非阻塞</li>
<li>NIO提供的内存优化技术:以字节byte为单位使用byteBuffer缓存或发送数据</li>
<li>可以使用并发库技术:在上述中对比异步与同步的性能分析,可以使用并发库来实现多线程环境下的异步操作</li>
</ul>
<blockquote>
<p>一个单线程NIO服务通用设计</p>
</blockquote>
<ul>
<li>处理select的轮询调用</li>
<li>读取request数据</li>
<li>写出response数据</li>
<li>后台业务核心数据处理逻辑,即DB数据的读写/网络数据的读写/磁盘数据的读写/内存数据的读写</li>
</ul>
<p>在上述过程,业务核心数据逻辑具备多样性,需要针对不同的场景来进行分析,因此影响性能的处理步骤往往在于最后一步,由此可通过Reactor与多线程技术来进一步提升web服务的处理性能</p>
<blockquote>
<p>Reactor技术演进</p>
</blockquote>
<p>接下来以图解的方式来查看Reactor与多线程技术的演进过程.以下图解均来自《Scale IO in Java》以及github上的gnet库来演示.<br>单Reactor + 单线程模式</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/single_reactor.jpg"></p>
<p>单Reactor + 多线程模式</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/single_reactor_workers.jpg"></p>
<p>多Reactor + 多线程模式</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/multiple_reactors.jpg"></p>
<p>gnet库实现的一种Reactors模式</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/reactor/multiple_reactors2.jpg"></p>
<p>最后,我们单从Reactor技术变化来看,其设计的目的无非包含以下几个方面:</p>
<ul>
<li>反应器体系结构模式允许事件驱动的应用程序对来自一个或多个客户机的服务请求进行多路复用和分派,即支持更多的客户端连接请求调度.</li>
<li>反应器模式是一种用于同步解复用和事件到达时的顺序的设计模式,通过轮询不断寻找就绪事件,并在事件触发时通知相应的事件处理程序来处理它,引入新的对象组件Reactor与Handler,实现程序业务逻辑与socket的IO复用事件处理逻辑解耦.</li>
<li>它接收来自多个并发客户机的消息、请求和连接，并使用事件处理程序顺序处理这些帖子.反应器设计模式的目的是避免为每个消息、请求和连接创建线程的常见问题</li>
<li>它从一组处理程序接收事件，并将它们按顺序分发到相应的事件处理程序,同时可以看到采用分而治之的设计思路来实现可web服务的伸缩性.</li>
</ul>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析Select/Epoll原理</title>
    <url>/2020/03/08/select2poll/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="Linux内核的休眠与唤醒机制"><a href="#Linux内核的休眠与唤醒机制" class="headerlink" title="Linux内核的休眠与唤醒机制"></a>Linux内核的休眠与唤醒机制</h5><p>在Linux内核中存在着等待队列的数据结构,该数据结构是基于双端链表实现,Linux内核通过将阻塞的进程任务添加到等待队列中,而进程任务被唤醒则是在队列轮询遍历检测是否处于就绪状态,如果是那么会等待队列中删除等待节点并通过节点上的回调函数进行通知然后加入到cpu就绪队列中等待cpu调度执行.其具体流程主要包含以下两个处理逻辑,即休眠逻辑以及唤醒逻辑.</p>
<blockquote>
<p>休眠逻辑</p>
</blockquote>
<ul>
<li><p>linux 内核休眠逻辑核心代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中cmd = schedule(), 即一个调用schedule函数的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq_head, condition, state, exclusive, ret, cmd)</span></span><br><span class="line">(&#123;										</span><br><span class="line">	__label__ __out;							</span><br><span class="line">	struct wait_queue_entry __wq_entry;					</span><br><span class="line">	<span class="keyword">long</span> __ret = ret;	<span class="comment">/* explicit shadow */</span>				</span><br><span class="line">	<span class="comment">// 初始化过程(内部代码这里省略,直接说明)</span></span><br><span class="line">	<span class="comment">// 1. 设置独占标志到当前节点entry</span></span><br><span class="line">	<span class="comment">// 2. 将当前任务task指向节点的private</span></span><br><span class="line">	<span class="comment">// 3. 同时为当前entry节点传递一个唤醒的回调函数autoremove_wake_function,一旦唤醒将会自动被删除</span></span><br><span class="line">	init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : <span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 防止队列中没有entry产生不断的轮询,主要处理wait_queue与entry节点添加或者删除</span></span><br><span class="line">		<span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);</span><br><span class="line">		<span class="comment">// 事件轮询检查是否事件有被唤醒							</span></span><br><span class="line">		<span class="keyword">if</span> (condition)							</span><br><span class="line">			<span class="keyword">break</span>;							</span><br><span class="line">										</span><br><span class="line">		<span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;			</span><br><span class="line">			__ret = __int;						</span><br><span class="line">			<span class="keyword">goto</span> __out;						</span><br><span class="line">		&#125;								</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 调用schedule()方法						</span></span><br><span class="line">		cmd;								</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 事件被唤醒,将当前的entry从队列中移除				</span></span><br><span class="line">	finish_wait(&amp;wq_head, &amp;__wq_entry);					</span><br><span class="line">__out:	__ret;									</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对此,我们可以总结如下:</p>
<ul>
<li>在linux内核中某一个进程任务task执行需要等待某个条件condition被触发执行之前,首先会在内核中创建一个等待节点entry,然后初始化entry相关属性信息,其中将进程任务存放在entry节点并同时存储一个wake_callback函数并挂起当前进程</li>
<li>其次不断轮询检查当前进程任务task执行的condition是否满足,如果不满足则调用schedule()进入休眠状态</li>
<li>最后如果满足condition的话,就会将entry从队列中移除,也就是说这个时候事件已经被唤醒,进程处于就绪状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>唤醒逻辑</p>
</blockquote>
<ul>
<li><p>linux内核的唤醒核心代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">			<span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 省略其他非核心代码...</span></span><br><span class="line">	<span class="comment">// 循环遍历整个等待队列</span></span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用唤醒的函数</span></span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查当前节点是否为独占节点,如果是,即nr_exclusive = 0退出循环遍历</span></span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">void</span>			*<span class="keyword">private</span>;</span><br><span class="line">	<span class="comment">// 这里的func就是上述休眠的时候在init_wait_entry传递autoremove_wake_function</span></span><br><span class="line">	<span class="keyword">wait_queue_func_t</span>	func;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">autoremove_wake_function</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 公用的唤醒函数逻辑</span></span><br><span class="line">	<span class="comment">// 内部执行try_to_wake_up, 也就是将wq_entry的private(当前进程)添加到cpu的执行队列中,让cpu能够调度task执行</span></span><br><span class="line">	<span class="keyword">int</span> ret = default_wake_function(wq_entry, mode, sync, key);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 其他为当前唤醒函数私有逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(autoremove_wake_function);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对此,基于上述的唤醒逻辑可以总结如下:</p>
<ul>
<li>在等待队列中循环遍历所有的entry节点,并执行回调函数,直到当前entry为排他节点的时候退出循环遍历</li>
<li>执行的回调函数中,存在私有逻辑与公用逻辑,类似模板方法设计模式</li>
<li>对于default_wake_function的唤醒回调函数主要是将entry的进程任务task添加到cpu就绪队列中等待cpu调度执行任务task</li>
</ul>
</li>
</ul>
<p>至此,linux内核的休眠与唤醒机制有了上述认知之后,接下来揭开IO复用模型设计的本质就相对会比较容易理解</p>
<h5 id="IO复用模型本质"><a href="#IO复用模型本质" class="headerlink" title="IO复用模型本质"></a>IO复用模型本质</h5><p><img src="https://img-blog.csdnimg.cn/20200306232219394.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="IO复用模型"></p>
<p>在讲述IO复用模型之前,我们先简单回顾下IO复用模型的思路,从上述的IO复用模型图看出,一个进程可以处理N个socket描述符的操作,等待对应的socket为可读的时候就会执行对应的read_process处理逻辑,也就是说这个时候我们站在read_process的角度去考虑,我只需要关注socket是不是可读状态,如果不可读那么我就休眠,如果可读你要通知我,这个时候我再调用recvfrom去读取数据就不会因内核没有准备数据处于等待,这个时候只需要等待内核将数据复制到用户空间的缓冲区中就可以了.那么对于read_process而言,要实现复用该如何设计才能达到上述的效果呢?</p>
<blockquote>
<p>复用本质</p>
</blockquote>
<ul>
<li>摘录电子通信工程中术语,“在一个通信频道中传递多个信号的技术”, 可简单理解: 为了提升设备使用效率,尽可能使用最少的设备资源传递更多信号的技术</li>
<li>回到上述的IO复用模型,也就是说这里复用是实现一个进程处理任务能够接收N个socket并对这N个socket进行操作的技术</li>
</ul>
<blockquote>
<p>复用设计原理</p>
</blockquote>
<p>在上述的IO复用模型中一个进程要处理N个scoket事件,也会对应着N个read_process,但是这里的read_process都是向内核发起读取操作的处理逻辑,它是属于进程程序中的一段子程序,换言之这里是实现read_process的复用,即N个socket中只要满足有不少于一个socket事件是具备可读状态,read_process都能够被触发执行,联想到Linux内核中的sleep &amp; wakeup机制,read_process的复用是可以实现的,这里的socket描述符可读在Linux内核称为事件,其设计实现的逻辑图如下所示:<br><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/writing2images/io/io_select_flow.jpg" alt="IO复用设计模型"></p>
<ul>
<li>用户进程向内核发起select函数的调用,并携带socket描述符集合从用户空间复制到内核空间,由内核对socket集合进行可读状态的监控.</li>
<li>其次当前内核没有数据可达的时候,将注册的socket集合分别以entry节点的方式添加到链表结构的等待队列中等待数据报可达.</li>
<li>这个时候网卡设备接收到网络发起的数据请求数据,内核接收到数据报,这个时候就通过轮询唤醒的方式(内核并不知道是哪个socket可读)逐个进行唤醒通知,直到当前socket描述符有可读状态的时候就退出轮询然后从等待队列移除对应的socket节点entry,并且这个时候内核将会更新fd集合中的描述符的状态,以便于用户进程知道是哪些socket是具备可读性从而方便后续进行数据读取操作</li>
<li>同时在轮询唤醒的过程中,如果有对应的socket描述符是可读的,那么此时会将read_process加入到cpu就绪队列中,让cpu能够调度执行read_process任务</li>
<li>最后是用户进程调用select函数返回成功,此时用户进程会在socket描述符结合中进行轮询遍历具备可读的socket,此时也就意味着数据此时在内核已经准备就绪,用户进程可以向内核发起数据读取操作,也就是执行上述的read_process任务操作</li>
</ul>
<h5 id="IO复用模型实现"><a href="#IO复用模型实现" class="headerlink" title="IO复用模型实现"></a>IO复用模型实现</h5><p>基于上述IO复用模型实现的认知,对于IO复用模型实现的技术select/poll/epoll也应具备上述两个核心的逻辑,即等待逻辑以及唤醒逻辑,对此用伪代码来还原select/poll/epoll的设计原理.</p>
<blockquote>
<p>select/poll/epoll的等待逻辑</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;maxfds,i++)&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 检测当前fd是否就绪</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fd[i].poll())&#123;</span><br><span class="line">           <span class="comment">// 更新事件状态,让用户进程知道当前socket状态是可读状态</span></span><br><span class="line">            fd_sock.event |= POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res | tiemout | expr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    schdule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>select/poll/epoll的唤醒逻辑</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foreach(entry as waiter_queues)&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒通知并将任务task加入cpu就绪队列中</span></span><br><span class="line">    res = callback();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 说明当前节点为独占节点,只能唤醒一次,因此需要退出循环</span></span><br><span class="line">    <span class="keyword">if</span>(res &amp;&amp; current == EXCLUSIVE)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="select-技术"><a href="#select-技术" class="headerlink" title="select 技术"></a>select 技术</h6><blockquote>
<p>select 函数定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd1,							<span class="comment">// 最大文件描述符个数,传输的时候需要+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *readset,						<span class="comment">// 读描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *writeset,					<span class="comment">// 写描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *exceptset,					<span class="comment">// 异常描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct timeval *timeout)</span></span>;		<span class="comment">// 超时时间</span></span><br><span class="line"><span class="comment">// timeout的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">// 单位为秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;		<span class="comment">// 单位微秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// select函数返回结果</span></span><br><span class="line"><span class="comment">//select() &gt; 0: 表示当前调用select监视到有描述符就绪状态的描述符索引值,意味着可以开始读取/写入/异常处理等操作</span></span><br><span class="line"><span class="comment">//select() = 0: 表示当前调用select发生超时,在最后的一个参数指定</span></span><br><span class="line"><span class="comment">//select() = -1: 表示当前调用select发生异常错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在很多Unix/Liunx版本使用pselect函数,最新版本(5.6.2)的select已经弃用</span></span><br><span class="line"><span class="comment">// 其定义如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfd1,							<span class="comment">// 最大文件描述符个数,传输的时候需要+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *readset,						<span class="comment">// 读描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *writeset,					<span class="comment">// 写描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   fd_set *exceptset,					<span class="comment">// 异常描述符集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct timespec *timeout,		<span class="comment">// 超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct <span class="keyword">sigset_t</span> *sigmask)</span></span>;		<span class="comment">// 信号掩码指针		</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">// 单位为秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_nsec;		<span class="comment">// 单位纳秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>select/pselect技术等待逻辑</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于POSIX协议</span></span><br><span class="line"><span class="comment">// posix_type.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024  <span class="comment">// 最大文件描述符为1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只关注socket可读状态,以下主要是休眠逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 与上述休眠逻辑初始化等待节点操作类似</span></span><br><span class="line">	poll_initwait(&amp;table);	</span><br><span class="line">	wait = &amp;table.pt;<span class="comment">// 获取创建之后的等待节点</span></span><br><span class="line">	</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	n = retval;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 操作返回值</span></span><br><span class="line">	retval = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="comment">// 监控可读的描述符</span></span><br><span class="line">		inp = fds-&gt;in;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">				bit = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// BITS_PER_LONG若处理器为32bit则BITS_PER_LONG=32,否则BITS_PER_LONG=64;</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				f = fdget(i);</span><br><span class="line">				wait_key_set(wait, in, out, bit,</span><br><span class="line">						     busy_flag);</span><br><span class="line">				<span class="comment">// 检测当前等待节点是否可读</span></span><br><span class="line">				mask = vfs_poll(f.file, wait);</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="comment">// 当前等待节点是否可读</span></span><br><span class="line">				<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">					res_in |= bit;</span><br><span class="line">					retval++;</span><br><span class="line">					wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 说明有存在可读节点退出节点遍历</span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 调度带有超时事件的schedule</span></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除队列中的等待节点</span></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>select/pselect技术唤醒逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在poll_initwait -&gt;  __pollwait --&gt; pollwake 的方法,主要关注pollwake方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> wait-&gt;<span class="keyword">private</span>;</span><br><span class="line">	DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);</span><br><span class="line"></span><br><span class="line">	smp_wmb();	<span class="comment">// 与sheculde_time_out中的smp_store_mb方法相呼应,一旦触发那个方法,就会调用执行到这里</span></span><br><span class="line">	pwq-&gt;triggered = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 与linux内核中的唤醒机制一样,下面的方法是内核执行的,不过多关心,有兴趣可以看源码core.c下面定义</span></span><br><span class="line">	<span class="comment">// 就是polling_task也就是read_process添加到cpu就绪队列中,让cpu进行调度</span></span><br><span class="line">	<span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于上述的代码,现总结如下: </p>
<ul>
<li>select技术的实现也是基于Linux内核的等待与唤醒机制实现,对于等待与唤醒逻辑主要细节也在上文中讲述,这里不再阐述</li>
<li>其次可以通过源码知道,在Linux中基于POSIX协议定义的select技术最大可支持的描述符个数为1024个,虽然现代操作系统支持更多的描述符,但是对于select技术增加描述符的话,需要更改POSIX协议中描述符个数的定义,但是此时需要重新编译内核,对于互联网的高并发连接应用是远远不够的</li>
<li>另外一个是用户进程调用select的时候需要将一整个fd集合的大块内存从用户空间拷贝到内核中,期间用户空间与内核空间来回切换开销非常大,再加上调用select的频率本身非常频繁,这样导致高频率调用且大内存数据的拷贝,严重影响性能</li>
<li>最后唤醒逻辑的处理,select技术在等待过程如果监控到至少有一个socket事件是可读的时候将会唤醒整个等待队列,告知当前等待队列中有存在就绪事件的socket,但是具体是哪个socket不知道,必须通过轮询的方式逐个遍历进行回调通知,也就是唤醒逻辑轮询节点包含了就绪和等待通知的socket事件,如果每次只有一个socket事件可读,那么每次轮询遍历的事件复杂度是O(n),影响到性能</li>
</ul>
</li>
</ul>
<h6 id="poll-技术"><a href="#poll-技术" class="headerlink" title="poll 技术"></a>poll 技术</h6><p>poll技术与select技术实现逻辑基本一致,重要区别在于poll技术使用链表的方式存储描述符fd,不受数组大小影响,对此,现对poll技术进行分析如下:</p>
<blockquote>
<p>poll定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// poll已经被弃用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, 		<span class="comment">// fd的文件集合改成自定义结构体,不再是数组的方式,不受限于FD_SIZE</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, 		<span class="comment">// 最大描述符个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">int</span> timeout)</span></span>;		<span class="comment">// 超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;				<span class="comment">// fd索引值</span></span><br><span class="line">	<span class="keyword">short</span> events;		<span class="comment">// 输入事件</span></span><br><span class="line">	<span class="keyword">short</span> revents;		<span class="comment">// 结果输出事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前查看的linux版本(5.6.2)使用ppoll方式,与pselect差不多,其他细节不多关注</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(struct pollfd *fds, 			<span class="comment">// fd的文件集合改成自定义结构体,不再是数组的方式,不受限于FD_SIZE</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, 				<span class="comment">// 最大描述符个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 struct timespec timeout,			<span class="comment">// 超时时间,与pselect一样</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">const</span> struct <span class="keyword">sigset_t</span> sigmask,		<span class="comment">// 信号指针掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">		 struct <span class="keyword">size_t</span> sigsetsize)</span></span>;			<span class="comment">// 信号大小</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>poll技术实现的核心代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于poll与select实现的机制差不多,因此不过多贴代码,只简单列出核心点即可</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 从用户空间将fdset拷贝到内核中</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">					<span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 和select一样,初始化等待节点的操作</span></span><br><span class="line">		poll_initwait(&amp;table);</span><br><span class="line">		<span class="comment">// do_poll的处理逻辑与do_select逻辑基本一致,只是这里用链表的方式遍历,do_select用数组的方式</span></span><br><span class="line">		<span class="comment">// 链表可以无限增加节点,数组有指定大小,受到FD_SIZE的限制</span></span><br><span class="line">		fdcount = do_poll(head, &amp;table, end_time);</span><br><span class="line">		<span class="comment">// 从等待队列移除等待节点</span></span><br><span class="line">		poll_freewait(&amp;table);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结: poll技术使用链表结构的方式来存储fdset的集合,相比select而言,链表不受限于FD_SIZE的个数限制,但是对于select存在的性能并没有解决,即一个是存在大内存数据拷贝的问题,一个是轮询遍历整个等待队列的每个节点并逐个通过回调函数来实现读取任务的唤醒</p>
<h6 id="epoll技术"><a href="#epoll技术" class="headerlink" title="epoll技术"></a>epoll技术</h6><p>为了解决select&amp;poll技术存在的两个性能问题,对于大内存数据拷贝问题,epoll通过epoll_create函数创建epoll空间(相当于一个容器管理),在内核中只存储一份数据来维护N个socket事件的变化,通过epoll_ctl函数来实现对socket事件的增删改操作,并且在内核底层使用虚拟内存的管理方式保证用户空间与内核空间对该内存是具备可见性,直接通过指针引用的方式进行操作,避免了大内存数据的拷贝导致的空间切换性能问题,对于轮询等待事件通过epoll_wait的方式来实现对socket事件的监听,将不断轮询等待高频事件wait与低频socket注册事件两个操作分离开,同时会对监听就绪的socket事件添加到就绪队列中,也就保证唤醒轮询的事件都是具备可读的,现对epoll技术分析如下:</p>
<blockquote>
<p>epoll技术定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建保存epoll文件描述符的空间,该空间也称为“epoll例程”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;    <span class="comment">// 使用链表,现在已经弃用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;    <span class="comment">// 使用红黑树的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll注册/修改/删除 fd的操作</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,                        <span class="comment">// 上述epoll空间的fd索引值</span></span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> op,                         <span class="comment">// 操作识别，EPOLL_CTL_ADD |  EPOLL_CTL_MOD  |  EPOLL_CTL_DEL</span></span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> fd,                          <span class="comment">// 注册的fd</span></span></span></span><br><span class="line"><span class="params"><span class="function">               struct epoll_event *event)</span></span>;      <span class="comment">// epoll监听事件的变化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="keyword">__poll_t</span> events;</span><br><span class="line">	__u64 data;</span><br><span class="line">&#125; EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll等待，与select/poll的逻辑一致</span></span><br><span class="line">epoll_wait(<span class="keyword">int</span> epfd,                            <span class="comment">// epoll空间</span></span><br><span class="line">           struct epoll_event *events,           <span class="comment">// epoll监听事件的变化</span></span><br><span class="line">           <span class="keyword">int</span> maxevents,                        <span class="comment">// epoll可以保存的最大事件数</span></span><br><span class="line">        <span class="keyword">int</span> timeout);                         <span class="comment">// 超时时间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>epoll技术实现细节</p>
</blockquote>
<ul>
<li>epoll_ctl函数处理socket描述符fd注册问题,关注epoll_ctl的ADD方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 摘取核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *epds,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">bool</span> nonblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在红黑树中查找存储file对应的epitem，添加的时候会将epitem加到红黑树节点中</span></span><br><span class="line">	epi = ep_find(ep, tf.file, fd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对于EPOLL_CTL_ADD模式,使用mtx加锁添加到wakeup队列中</span></span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">	    <span class="comment">// fd注册操作</span></span><br><span class="line">		<span class="comment">// epds-&gt;events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line">		<span class="comment">// error = ep_insert(ep, epds, tf.file, fd, full_check);</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">	    <span class="comment">// // 删除操作：存储epitem容器移除epitem信息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 对注册的fd进行修改,但epoll的模式为EPOLLEXCLUSIVE是无法进行操作的</span></span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">	    <span class="comment">// 修改操作,内核监听到事件变化执行修改</span></span><br><span class="line">            <span class="comment">//error = ep_modify(ep, epi, epds);			</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放资源逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>EPOLL_CTL_ADD核心代码逻辑</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, <span class="keyword">const</span> struct epoll_event *event,</span></span></span><br><span class="line"><span class="params"><span class="function">		     struct file *tfile, <span class="keyword">int</span> fd, <span class="keyword">int</span> full_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将fd包装在epitem的epollfile中</span></span><br><span class="line">	epi-&gt;ep = ep;</span><br><span class="line">	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	epi-&gt;event = *event;</span><br><span class="line">	epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">	epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果当前监听到事件变化，那么创建wakeup执行的source</span></span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">		error = ep_create_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> error_create_wakeup_source;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化回调函数并与当前的epitem进行绑定添并将callback添加到poll table中，每一个epitem都有对应的callback，并添加到等待队列ep_pqueue</span></span><br><span class="line">	<span class="comment">// 注意这里每次添加fd都会有对应的epitem以及ep_pqueue，而一个ep_pqueue与一个callback进行绑定</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 轮询检测epitem中的事件，在内部会对epoll空间的ready list进行扫描，会触发执行回调函数并将已经唤醒就绪的fdset从epoll空间中拷贝到</span></span><br><span class="line">       <span class="comment">// epitem中的ready_list</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将epitem插入到红黑树中	</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有ready_list 则执行唤醒逻辑wakeup，这个是linux内核的唤醒机制，会将read_process添加到就绪队列中让cpu调度执行</span></span><br><span class="line">	<span class="keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存在预唤醒，则唤醒轮询等待节点</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">	    ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goto statement code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述的代码中存在两个核心逻辑(注册&amp;唤醒逻辑)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 队列回调添加注册逻辑 ep_ptable_queue_proc</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,</span><br><span class="line">				 poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">	struct epitem *epi = ep_item_from_epqueue(pt);</span><br><span class="line">	struct eppoll_entry *pwq;</span><br><span class="line"></span><br><span class="line">	if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">		pwq-&gt;whead = whead;</span><br><span class="line">		pwq-&gt;base = epi;</span><br><span class="line">		if (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		else</span><br><span class="line">			add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">		epi-&gt;nwait++;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* We have to signal that an error occurred */</span><br><span class="line">		epi-&gt;nwait = -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> locked;</span><br><span class="line"></span><br><span class="line">	pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">		<span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">	ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">	poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">	locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">				  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">				  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll_wait还有这个方法</span></span><br><span class="line"><span class="comment">// 执行ep_ptable_queue_proc队列回调函数</span></span><br><span class="line">p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ep_read_events_proc:监控ep空间事件是否可读的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_read_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="keyword">int</span> depth = *(<span class="keyword">int</span> *)priv;</span><br><span class="line"></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line">	depth++;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ep_item_poll(epi, &amp;pt, depth)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EPOLLIN | EPOLLRDNORM;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Item has been dropped into the ready list by the poll</span></span><br><span class="line"><span class="comment">			 * callback, but it&#x27;s not actually ready, as far as</span></span><br><span class="line"><span class="comment">			 * caller requested events goes. We can remove it here.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			__pm_relax(ep_wakeup_source(epi));</span><br><span class="line">			list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">__poll_t</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="params"><span class="function">					   struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">void</span> *priv, <span class="keyword">int</span> depth, <span class="keyword">bool</span> ep_locked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__poll_t</span> res;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">	LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">	 * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="comment">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="comment">	 * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="comment">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="comment">	 * because we want the &quot;sproc&quot; callback to be able to do it</span></span><br><span class="line"><span class="comment">	 * in a lockless way.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, <span class="literal">NULL</span>);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now call the callback function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * During the time we spent inside the &quot;sproc&quot; callback, some</span></span><br><span class="line"><span class="comment">	 * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="comment">	 * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="comment">		 * During the &quot;sproc&quot; callback execution time, items are</span></span><br><span class="line"><span class="comment">		 * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span></span><br><span class="line"><span class="comment">		 * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * -&gt;ovflist is LIFO, so we have to reverse it in order</span></span><br><span class="line"><span class="comment">			 * to keep in FIFO.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="comment">	 * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="comment">	 * ep-&gt;rdllist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Quickly re-inject items left on &quot;txlist&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">	__pm_relax(ep-&gt;ws);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的epoll_ctl技术代码实现的细节中存在着两个逻辑,即socket描述符注册与唤醒逻辑,主要体现在两个核心方法上,即ep_ptable_queue_proc &amp; ep_item_poll对此分析如下：</p>
</li>
<li><p>注册逻辑：</p>
<ul>
<li>在epoll空间中创建一个epitem的中间层,初始化一系列epitem的属性，同时将新增加的socket描述符包装到epitem下的epoll_filefd中，同时添加唤醒任务wakeup，同时将epitem的内部ep容器指向epoll空间</li>
<li>其次在进行item事件的轮询中，通过队列回调的方式将epitem绑定到队列节点entry上,并在entry节点上绑定epoll的回调函数来唤醒业务处理</li>
<li>最后是将epitem插入以epoll空间为根节点的红黑数中，后续内核可以通过fd查找到对应的epitem，通过epitem也就可以找到epoll空间引用</li>
</ul>
</li>
<li><p>唤醒逻辑：</p>
<ul>
<li>在item事件轮询中，通过轮询检测epoll空间中的等待队列是否有对应的节点entry可读，如果有退出循环，并且从当前注册的epitem开始轮询遍历查询就绪的entry节点并将就绪entry节点的socket描述符添加到ready_list上</li>
<li>其次在上述注册的逻辑之后，会检查当前的epitem的ready list节点,如果存在ready_list,会将epoll空间的等待队列唤醒,让执行处理的read_process添加到就绪队列中，让cpu能够进行调度</li>
</ul>
</li>
<li><p>epoll_wait等待逻辑</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_wait -&gt; do_epoll_wait -&gt; ep_poll, 我们关注核心方法ep_poll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fetch_events: <span class="comment">// 检测epoll是否有事件就绪</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 检测当前ep空间是否有fd事件就绪</span></span><br><span class="line">		eavail = ep_events_available(ep);</span><br><span class="line">		<span class="keyword">if</span> (eavail)</span><br><span class="line">			<span class="comment">// 是的跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 执行休眠方法 schedule()</span></span><br><span class="line">		<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	send_events: <span class="comment">// ep有事件就绪,将event_poll转换到用户空间中</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		ep_send_events(ep, events, maxevents);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上述可以看出等待处理逻辑主要有fetch_event以及send_events,现分析如下：<ul>
<li>循环检查当前epoll空间是否有就绪事件，如果有将跳出循环，如果没有将执行schedule的方法进入休眠等待再次轮询，原理与select/poll一致</li>
<li>其次当有就绪事件的时候,循环遍历将监听变化的事件拷贝到用户空间中,并且会将就绪事件socket添加到epitem的就绪队列ready_list上</li>
</ul>
</li>
</ul>
<blockquote>
<p>最后基于上述的分析做一个分析小结</p>
</blockquote>
<ul>
<li><p>解决大内存且频繁copy问题</p>
<ul>
<li>首先,epoll通过epoll_create创建epoll空间,同时在创建空间的同时将epoll空间拷贝到内存中,此后epoll对socket描述的注册监听通过epoll空间来进行操作,仅一次拷贝</li>
<li>其次,epoll注册将拆分为ADD/MOD/DEL三个操作,分别只对相应的操作进行处理,大大降低频繁调用的次数,相比select/poll机制，由原先高频率的注册等待转换为高频等待，低频注册的处理逻辑</li>
<li>接着,还有一点就是每次注册都通过建立一个epitem结构体对socket相关的fd以及file进行封装，并且epitem的ep容器通过指针引用指向epoll空间,即每次新增加一个socket描述符的时候而是通过单个epitem进行操作，相比fdset较为轻量级</li>
<li>最后,epoll在内核中通过虚拟内存方式将内核空间与用户空间的一块地址同时映射到相同的物理内存地址中，这块内存对用户空间以及内核空间均为可见，因此可以减少用户空间与内核空间之间的数据交换</li>
</ul>
</li>
<li><p>解决只对就绪队列进行唤醒循环遍历</p>
<ul>
<li>首先，我们可以看到在注册的过程中，epoll通过epitem将socket描述符存储到epoll_file中，同时将唤醒逻辑read_process也绑定到epitem，这样当处于唤醒状态就会被触发执行，然后在以当前epitem存储到队列entry节点上，并entry节点绑定回调函数，最后将entry节点添加到ep的等待队列上</li>
<li>其次，在进行wiat等待过程中，内核在执行file.poll()后会将等待队列上的节点添加到轮询等待中poll wait，处于半唤醒状态，也就是当前是就绪状态但还没唤醒，同时会将唤醒的socket描述符添加到epoll空间的ready list中</li>
<li>接着，每当有一个item被唤醒的时候就会退出上述的轮询遍历并持续设置当前的item处于唤醒状态，然后epoll空间开始遍历item（单链表存储）并执行回调函数通知，如果item为就绪状态，就将epoll空间的readylist拷贝到当前唤醒节点的epitem的ready list中</li>
<li>最后，会更新监听变化的事件状态，返回到用户进程，用户进程这个时候获取到ready list中的描述符均为可就绪状态</li>
</ul>
</li>
<li><p>epoll其他技术</p>
<ul>
<li>epoll支持并发执行，上述的休眠与唤醒逻辑都有加锁操作</li>
<li>其次对于就绪状态的ready_list是属于无锁操作，因此为了保证执行并发的安全性在epoll使用的加锁方式全局锁</li>
</ul>
</li>
</ul>
<h6 id="边缘触发与水平触发"><a href="#边缘触发与水平触发" class="headerlink" title="边缘触发与水平触发"></a>边缘触发与水平触发</h6><blockquote>
<p>边缘触发与水平触发定义</p>
</blockquote>
<ul>
<li><p>水平触发</p>
<ul>
<li>socket接收数据的缓冲区不为空的时候，则一直触发读事件，相当于”不断地询问是否数据是否可读”</li>
<li>socket发送数据的缓冲区不全满的时候，则一直触发写事件，相当于”不断地询问是否有区域可以让数据写入”<br>本质上就是一个不断进行交流的过程，如下图所示：<br><img src="http://s1.wailian.download/2020/03/10/level_triggerf57e0e324222c243.jpg" alt="level_triggerf57e0e324222c243.jpg"></li>
</ul>
</li>
<li><p>边缘触发</p>
<ul>
<li>socket接收数据的缓冲区发生变化，则触发读取事件，也就是当空的接收数据的socket缓冲区这个时候有数据传送过来的时候触发</li>
<li>socket发送数据的缓冲区发生变化，则触发写入事件，也就是当满的发送数据的socket缓冲区这个时候刚刷新数据初期的时候触发<br>本质上就是socket缓冲区变化而触发，如下图所示：<br><img src="http://s1.wailian.download/2020/03/10/edage_triigger.jpg" alt="edage_triigger.jpg"></li>
</ul>
</li>
<li><p>上述的触发事件会调用epoll_wait方法，也就是</p>
<ul>
<li>水平触发会多次调用epoll_wait</li>
<li>边缘触发在socket缓冲区中不发生改变那么就不会调用epoll_wait的方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>水平触发与边缘触发代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为水平触发对应标志为EPOLLONESHOT, 边缘触发标志为EPOLLET</span></span><br><span class="line">list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行唤醒逻辑</span></span><br><span class="line">		ws = ep_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (ws) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">				__pm_stay_awake(ep-&gt;ws);</span><br><span class="line">			__pm_relax(ws);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除epitem下的ready_list</span></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新轮询事件收集就绪事件</span></span><br><span class="line">		revents = ep_item_poll(epi, &amp;pt, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!revents)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">		    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">			<span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">				esed-&gt;res = -EFAULT;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		esed-&gt;res++;</span><br><span class="line">		uevent++;</span><br><span class="line">	    </span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">			epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">			 <span class="comment">// 水平触发模式，需要重新添加到ready_list以便于调用epoll_wait的时候能够检查到事件可用</span></span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>水平触发：遍历epoll下的等待队列的每个entry，唤醒entry节点之后从ready_list移除当前socket事件，然后再轮询当前item收集可用的事件，最后添加到ready_list以便于调用epoll_wait的时候能够检查到socket事件可用</li>
<li>边缘触发：遍历epoll下的等待队列的每个entry，唤醒entry节点之后从ready_list移除当前socket事件，再轮询当前item收集可用的事件然后唤醒执行的业务处理read_process</li>
</ul>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix网络编程之5种IO模型</title>
    <url>/2020/04/02/unix_io/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="1-Unix-Linux操作系统简述"><a href="#1-Unix-Linux操作系统简述" class="headerlink" title="1. Unix/Linux操作系统简述"></a>1. Unix/Linux操作系统简述</h5><blockquote>
<p>Unix操作与Linux系统结构图解 (引用计算机操作系统书籍)</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022311314023.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200223113215694.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>概要说明</p>
</blockquote>
<ul>
<li>用户空间: 姑且将上述用户级别或者是unix编程的应用程序的部分称为用户空间,我们可以通过启动进程来调用内核来完成从硬件设备读取或写入等操作</li>
<li>系统内核: 是直接与计算机硬件打交道的应用程序级别,在计算机相关的书籍中也称为操作系统,可以通过操作系统级别提供的一些组件来帮助用户进程与计算机硬件完成通信交互的操作,可以称为一个中转站</li>
</ul>
<blockquote>
<p>文件描述符（File descriptor）</p>
</blockquote>
<p>在linux/unix系统中,文件进程存储着一份文件描述表(数组存储),数组存储file结构指针类型,文件进程通过数组索引来完成文件的操作,这里的数组索引也就是文件描述符,简称为fd</p>
<p>至此,有了上述的认知之后,我们再来看下Unix的IO模型是如何进行网络数据的传输</p>
<h5 id="2-Unix之IO模型"><a href="#2-Unix之IO模型" class="headerlink" title="2. Unix之IO模型"></a>2. Unix之IO模型</h5><p>首先,讲述IO模型之前,需要先明确一个概念,比如我们现在需要从网络读取数据,那么流程将是先从用户进程中向系统内核发起读取数据的操作,然后等待内核接收到网络传输过来的数据报,有了数据报之后,根据上述操作系统的结构可知,我们需要将数据报通过系统内核复制到用户空间上,这个时候用户进程才能够获取到数据进行数据报的读取,由此可知,一个输入操作需要两个阶段:</p>
<ul>
<li>等待数据报可达,也就是系统内核必须要有接收到数据报</li>
<li>有了数据报之后,需要将数据报从内核复制到用户空间</li>
</ul>
<p>另外</p>
<ul>
<li>unix用recvfrom函数表示应用进程向系统内核发起读取操作的系统调用</li>
</ul>
<p>至此,网络IO读取操作有了上述的认知,接下来再看IO模式,注意默认情况下所有的套接字,即socket都是阻塞式的,以网络读取数据为例展开,为了简化概念,将TCP的低套接字等信息隐藏不做说明,只说明IO模型,或者可以简单理解为UDP传输方式</p>
<blockquote>
<p>阻塞式IO模型</p>
</blockquote>
<ul>
<li>自应用进程发起recvfrom系统调用,在此期间一直处于被阻塞,因为这个时候需要等待内核获取数据报信息并将数据报复制到用户空间中,除非被中断异常返回,否则将一直处于阻塞状态</li>
<li>以下是时序图展示阻塞式IO<br><img src="https://img-blog.csdnimg.cn/20200223115104499.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>非阻塞式IO模型</p>
</blockquote>
</li>
<li>非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</li>
<li>用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</li>
<li>用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</li>
<li>以下时序图展示NIO的方式<br><img src="https://img-blog.csdnimg.cn/20200223115840214.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>IO复用模型</p>
</blockquote>
</li>
<li>IO复用模式是使用select或者poll函数向系统内核发起调用,阻塞在这两个系统函数调用,而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</li>
<li>阻塞于select函数的调用,等待数据报套接字变为可读状态</li>
<li>当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</li>
<li>IO复用模式时序图如下<br><img src="https://img-blog.csdnimg.cn/2020022312032477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>信号驱动式IO模型</p>
</blockquote>
</li>
<li>用户进程可以使用信号方式,当系统内核描述符就绪时将会发送SIGNO给到用户空间,这个时候再发起recvfrom的系统调用等待返回成功提示,流程如下</li>
<li>先开启套接字的信号IO驱动功能,并通过一个内置安装信号处理函数的signaction系统调用,当发起调用之后将会直接返回</li>
<li>其次,等待内核从网络中接收数据报之后,向用户空间发送当前数据可达的信号给到信号处理函数</li>
<li>信号处理函数接收到信息就发起recvfrom系统调用等待内核复制数据报到用户空间的缓冲区</li>
<li>接收到复制完成的返回成功提示之后,应用进程就可以开始从网络中读取数据</li>
<li>时序图如下<br><img src="https://img-blog.csdnimg.cn/2020022312355190.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>异步IO模型</p>
</blockquote>
</li>
<li>由POSIX规范定义,告知系统内核启动某个操作,并让内核在整个操作包括数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成,可以进行读取数据</li>
<li>与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</li>
<li>时序图如下<br><img src="https://img-blog.csdnimg.cn/20200223131143774.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>现代计算机服务器操作系统大部分都是基于linxu实现,为处理高并发而采取NIO的模型,对于支持异步IO模型的系统持有不确定因素</li>
</ul>
<h5 id="3-同步与异步和阻塞与非阻塞"><a href="#3-同步与异步和阻塞与非阻塞" class="headerlink" title="3. 同步与异步和阻塞与非阻塞"></a>3. 同步与异步和阻塞与非阻塞</h5><blockquote>
<p>同步与异步的定义</p>
</blockquote>
<ul>
<li>同步:发起一个fn的调用,需要等待调用结果返回,该调用结果要么是期望的结果要么是异常抛出的结果,可以说是原子性操作(要么成功要么失败返回)</li>
<li>异步: 发起一个fn调用,无需等待结果就直接返回,只有当被调用者执行处理程序之后通过“唤醒”手段通知调用方获取结果(唤醒的方式有回调,事件通知等)</li>
<li><strong>小结: 同步和异步关注的是程序之间的通信</strong></li>
</ul>
<blockquote>
<p>阻塞与非阻塞的定义</p>
</blockquote>
<ul>
<li>阻塞: 类比线程阻塞来说明,在并发多线程争抢资源的竞态条件下,如果有一个线程已持有锁,那么当前线程将无法获取锁而被挂起,处于等待状态</li>
<li>非阻塞: 一旦线程释放锁,其他线程将会进入就绪状态,具备争抢锁的资格</li>
<li><strong>小结: 阻塞与非阻塞更关注是程序等待结果的状态</strong></li>
<li>由此可知,同步异步与阻塞非阻塞之间不存在关联,关注的目标是不一样的</li>
</ul>
<blockquote>
<p>同步IO与异步IO(基于POSIX规范)</p>
</blockquote>
<ul>
<li>同步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程一直处于等待状态,这时候进程被阻塞,直到IO操作完成返回成功提示</li>
<li>异步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程将直接返回一个错误信息,<strong>“相当于告诉进程还没有处理好,好了会通知你”</strong></li>
<li>阻塞IO: 主要是体现发起IO操作请求通知内核并且内核接收到信号之后如果让进程等待,那么就是阻塞</li>
<li>非阻塞IO: 发起IO操作请求的时候不论结果直接告诉进程“<strong>不用等待,晚点再来</strong>”,那就是非阻塞</li>
</ul>
<blockquote>
<p>IO模型对比</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200223152931555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>根基上述的同步与异步IO定义并结合上述的模型可知,只有异步IO模型符合POSIX规范的异步IO,其他IO模型都存在recvfrom系统调用被内核阻塞,属于同步IO操作</p>
</li>
<li><p>由此可知,阻塞IO与非阻塞IO可总结如下:</p>
</li>
<li><p>也就是说,要么称为同步与异步IO,要么称为上述5种模型的IO说法,注意上述的同步与异步的概念</p>
</li>
<li><p>大部分操作系统都是基于同步IO的方式实现,对于支持异步IO模型的操作系统还不确定,在实际工作我们经常会说Blocking-IO(阻塞IO)和Non-Blocking-IO(非阻塞IO),极少称同步IO与异步IO</p>
</li>
<li><p><strong>小结: 同步与异步针对通信机制,阻塞与非阻塞针对程序调用等待结果的状态</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>io2net</category>
      </categories>
      <tags>
        <tag>网络IO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之.class文件与字节码文件</title>
    <url>/2020/02/02/class/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="JVM运行数据区概述"><a href="#JVM运行数据区概述" class="headerlink" title="JVM运行数据区概述"></a>JVM运行数据区概述</h4><blockquote>
<p>.class与字节码bytecode</p>
</blockquote>
<ul>
<li>.class: 是指文件扩展名称为.class的文件,表示由java源程序经过java编译器编译而成且由JVM执行的二进制文件,因此可以通过拥有一份.class文件在不同的操作系统平台上的JVM执行,实现跨平台运行的特性</li>
<li>字节码bytecode: 简单说不是文件,而是JVM操作的指令格式,通常我们通过<code>javap -c -v xx.class</code>生成的文件称为字节码文件,是属于可阅读的字节码指令文件,能够让我们清楚地知道java文件编译成.class文件之后显示的执行指令,便于程序员理解jvm的相关的知识</li>
</ul>
<blockquote>
<p>.class文件与字节码文件格式</p>
</blockquote>
<ul>
<li><p>.class文件(16进制文件)<br><img src="https://img-blog.csdnimg.cn/20200124155250693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>字节码文件(可阅读的指令文件)<br><img src="https://img-blog.csdnimg.cn/20200124155445198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="2-class文件结构与字节码"><a href="#2-class文件结构与字节码" class="headerlink" title="2. .class文件结构与字节码"></a>2. .class文件结构与字节码</h4><blockquote>
<p>.class文件结构</p>
</blockquote>
<ul>
<li><p>幻数</p>
<ul>
<li>类文件的四个字节表头0xCAFEBABE<br><img src="https://img-blog.csdnimg.cn/20200124160239164.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>类文件格式的版本</p>
<ul>
<li>类文件的次要和主要版本</li>
<li>jdk的主要版本如下  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java SE 14 = 58 (0x3A hex),</span><br><span class="line">Java SE 13 = 57 (0x39 hex),</span><br><span class="line">Java SE 12 = 56 (0x38 hex),</span><br><span class="line">Java SE 11 = 55 (0x37 hex),</span><br><span class="line">Java SE 10 = 54 (0x36 hex),[3]</span><br><span class="line">Java SE 9 = 53 (0x35 hex),[4]</span><br><span class="line">Java SE 8 = 52 (0x34 hex),</span><br><span class="line">Java SE 7 = 51 (0x33 hex),</span><br><span class="line">Java SE 6.0 = 50 (0x32 hex),</span><br><span class="line">Java SE 5.0 = 49 (0x31 hex),</span><br></pre></td></tr></table></figure>
  <img src="https://img-blog.csdnimg.cn/20200124161328936.png" alt="在这里插入图片描述"><br>表示0x0034当前使用jdk版本为jdk8</li>
</ul>
</li>
<li><p>常量池: 类文件的常量池</p>
</li>
<li><p>访问标识: 类文件的访问标识,  abstract, static,等等</p>
</li>
<li><p>当前的类名称,class name</p>
</li>
<li><p>当前父类的名称, super class name</p>
</li>
<li><p>当前类的任何接口</p>
</li>
<li><p>当前类的字段信息</p>
</li>
<li><p>当前类的方法信息</p>
</li>
<li><p>当前类的属性信息</p>
</li>
</ul>
<blockquote>
<p>字节码指令</p>
</blockquote>
<ul>
<li><p>指令类别</p>
<ul>
<li>存储指令 （例如：aload_0, istore）</li>
<li>算术与逻辑指令 （例如: ladd, fcmpl）</li>
<li>类型转换指令 （例如：i2b, d2i）</li>
<li>对象创建与操作指令 （例如：new, putfield）</li>
<li>堆栈操作指令 （例如：swap, dup2）</li>
<li>控制转移指令 （例如：ifeq, goto）</li>
<li>方法调用与返回指令 （例如：invokespecial, areturn)</li>
</ul>
</li>
<li><p>指令操作前后缀与数据类型</p>
<ul>
<li>i        整数</li>
<li>l         长整数</li>
<li>s     短整数</li>
<li>b    字节</li>
<li>c    字符</li>
<li>f        单精度浮点数</li>
<li>d    双精度浮点数</li>
<li>z    布尔值</li>
<li>a    引用</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## iadd  表示两个整数相加</span><br><span class="line">## dadd  表示两个double类型数据相加</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
<li><p>参见jvm的规范</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## jvm指令码表</span><br><span class="line">https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-6.html#jvms-6.5</span><br><span class="line"></span><br><span class="line">## jvm字节码文件格式</span><br><span class="line">https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-4.html#jvms-4.1</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行数据区说明</title>
    <url>/2020/02/03/jvm/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="JVM运行数据区概览"><a href="#JVM运行数据区概览" class="headerlink" title="JVM运行数据区概览"></a>JVM运行数据区概览</h4><blockquote>
<p>jvm运行数据区图例</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200124163048370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>图例说明</p>
</blockquote>
<ul>
<li>JVM运行数据区可以划分为线程独占和线程共享两部分</li>
<li>线程独占(封闭): 每个线程都拥有它的独立的内存空间,jvm在运行程序时就会为线程开辟一个内存空间来存储线程相关的信息,随着线程生命周期创建和销毁</li>
<li>线程共享: 所有线程都能够访问当前的数据区域,随着GC的生命周期的创建和销毁</li>
</ul>
<h4 id="JVM运行数据区分解说明"><a href="#JVM运行数据区分解说明" class="headerlink" title="JVM运行数据区分解说明"></a>JVM运行数据区分解说明</h4><blockquote>
<p>线程共享</p>
</blockquote>
<ul>
<li><p>方法区</p>
<ul>
<li>用于存储被JVM加载的类信息、常量、静 态变量、即时编译器编译(JIT编译)后的代码等数据</li>
<li>属于一个逻辑区域,根据不同的hotspot VM来实现,如jdk7方法区存放在永久代,而jdk8存放在元数据空间,通过GC机制来对当前区域进行管理</li>
</ul>
</li>
<li><p>堆内存(也称为“主内存”/“共享内存”区域)</p>
<ul>
<li>划分为老年代, 新生代(Eden/From Survivor/To Survivor)</li>
<li>JVM启动的时候会根据系统分配的堆内存策略从计算机申请内存空间,主要用于存储类实例信息</li>
<li>GC回收器本质上是对堆内存的管理</li>
<li>此区域会抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程独占</p>
</blockquote>
<ul>
<li>虚拟机栈<ul>
<li>描述虚拟机VM在java在线程中执行方法的内存模型,是属于线程私有的一块独立空间线程栈</li>
<li>线程栈包含多个栈帧</li>
<li>一个线程会执行一个或者多个方法,一个方法对应一个栈帧</li>
<li>栈帧内容包含: 局部变量表,操作数栈,动态链接,方法回收地址,附加信息等,用来存储数据和部分结果过程的数据结构,同时也被用来处理动态链接,方法返回值和异常分派</li>
<li>栈帧随着方法的生命周期创建和销毁(不论是方法正常退出还是异常退出)</li>
<li>会抛出StackOverflowError</li>
</ul>
</li>
<li>本地方法栈<ul>
<li>描述虚拟机VM执行用native修饰的方法</li>
<li>虚拟机VM没有详细描述其规范,不同的VM将由对应不同的厂商实现</li>
<li>会抛出StaclOverflowError</li>
</ul>
</li>
<li>程序计数器<ul>
<li>对于执行native方法,程序计数器存储为空</li>
<li>对于执行java方法,程序计数器主要是记录当前线程执行的字节码位置,存储字节码执行指令的地址</li>
<li>每个线程都会在对应的线程栈创建存储计数器的空间,目的是记录执行字节码指令,因此占用空间比较少</li>
<li>作用: 就是在同一时刻,同一个CPU执行只能执行一个线程方法,在并发多线程情况下,为了能够记住当前线程执行的字节码指令位置,需要借助程序计数器来记录对应的地址,当线程被唤醒的时候,将会根据程序计数器的位置继续往下执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考jvm规范</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-2.html#jvms-2.5</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java程序运行堆栈分析</title>
    <url>/2020/02/05/stack_anlysis/</url>
    <content><![CDATA[<span id="more"></span>


<h4 id="java程序源代码与字节码"><a href="#java程序源代码与字节码" class="headerlink" title="java程序源代码与字节码"></a>java程序源代码与字节码</h4><blockquote>
<p>源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackHeapAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java 运行堆栈分析</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//define my wallet totel balance</span></span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// birthday cake</span></span><br><span class="line">        <span class="keyword">int</span> cakeVal = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">int</span> cakeNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// birthday flower</span></span><br><span class="line">        <span class="keyword">int</span> flower = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> flowerNum = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cakeSpent = cakeNum * cakeVal;</span><br><span class="line">        <span class="keyword">int</span> flowerSpent = flower * flowerNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalSpent = flowerSpent + cakeSpent;</span><br><span class="line">        <span class="keyword">int</span> currentBalance = balance - totalSpent;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;in order to celebrate birthday for my gift friends, i have spent %d\n&quot;</span>, totalSpent);</span><br><span class="line">        System.out.printf(<span class="string">&quot;now my wallet balance is %d \n&quot;</span>, currentBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节码文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class com.xiaokunliu.homework.thread.base.StackHeapAnalysis</span><br><span class="line">  minor version: 0                          // 最低版本号</span><br><span class="line">  major version: 52                         // 主版本号 52 = 0x34   意味着是jdk8版本</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER              // 访问标识符</span><br><span class="line">Constant pool:                              // 常量池</span><br><span class="line">   #1 = Methodref          #4.#32         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #33.#34        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #35            // in order to celebrate birthday for my gift friends, i have spent %d\n</span><br><span class="line">   #4 = Class              #36            // java/lang/Object</span><br><span class="line">   #5 = Methodref          #37.#38        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">   #6 = Methodref          #39.#40        // java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;</span><br><span class="line">   #7 = String             #41            // now my wallet balance is %d \n</span><br><span class="line">   #8 = Class              #42            // com/xiaokunliu/homework/thread/base/StackHeapAnalysis</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcom/xiaokunliu/homework/thread/base/StackHeapAnalysis;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  // 常量池省略....</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  public com.xiaokunliu.homework.thread.base.StackHeapAnalysis();		// 类的构造器</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/xiaokunliu/homework/thread/base/StackHeapAnalysis;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=6, locals=10, args_size=1							// 以下是main线程的字节码操作指令</span><br><span class="line">         0: sipush        500</span><br><span class="line">         3: istore_1</span><br><span class="line">         4: bipush        99</span><br><span class="line">         6: istore_2</span><br><span class="line">         7: iconst_1</span><br><span class="line">         8: istore_3</span><br><span class="line">         9: iconst_2</span><br><span class="line">        10: istore        4</span><br><span class="line">        12: bipush        99</span><br><span class="line">        14: istore        5</span><br><span class="line">        16: iload_3</span><br><span class="line">        17: iload_2</span><br><span class="line">        18: imul</span><br><span class="line">        19: istore        6</span><br><span class="line">        21: iload         4</span><br><span class="line">        23: iload         5</span><br><span class="line">        25: imul</span><br><span class="line">        26: istore        7</span><br><span class="line">        28: iload         7</span><br><span class="line">        30: iload         6</span><br><span class="line">        32: iadd</span><br><span class="line">        33: istore        8</span><br><span class="line">        35: iload_1</span><br><span class="line">        36: iload         8</span><br><span class="line">        38: isub</span><br><span class="line">        39: istore        9</span><br><span class="line">        41: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        44: ldc           #3                  // String in order to celebrate birthday for my gift friends, i have spent %d\n</span><br><span class="line">        46: iconst_1</span><br><span class="line">        47: anewarray     #4                  // class java/lang/Object</span><br><span class="line">        50: dup</span><br><span class="line">        51: iconst_0</span><br><span class="line">        52: iload         8</span><br><span class="line">        54: invokestatic  #5                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">        57: aastore</span><br><span class="line">        58: invokevirtual #6                  // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;</span><br><span class="line">        61: pop</span><br><span class="line">        62: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        65: ldc           #7                  // String now my wallet balance is %d \n</span><br><span class="line">        67: iconst_1</span><br><span class="line">        68: anewarray     #4                  // class java/lang/Object</span><br><span class="line">        71: dup</span><br><span class="line">        72: iconst_0</span><br><span class="line">        73: iload         9</span><br><span class="line">        75: invokestatic  #5                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">        78: aastore</span><br><span class="line">        79: invokevirtual #6                  // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;</span><br><span class="line">        82: pop</span><br><span class="line">        83: return</span><br><span class="line">      LineNumberTable:						// 字节码存储代码在代码表的数组中,LineNumberTable通过定位源文件的代码行数与代码表数据长度对应起来</span><br><span class="line">        line 15: 0</span><br><span class="line">          // ......</span><br><span class="line">      LocalVariableTable:				// 线程本地局部变量表,存储main线程中的局部变量信息</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      84     0  args   [Ljava/lang/String;</span><br><span class="line">        // ....</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="java运行堆栈分析"><a href="#java运行堆栈分析" class="headerlink" title="java运行堆栈分析"></a>java运行堆栈分析</h4><blockquote>
<p>类执行分析准备</p>
</blockquote>
<ul>
<li>定义的class文件编译为二进制.class的时候,产生幻数标识,访问标识</li>
<li>执行main的时候先执行当前类的init构造器完成初始化</li>
<li>线程执行包含程序计数器以及虚拟机栈(多个栈帧[操作数栈 + 局部变量表 + 动态链接 + 方法返回])</li>
</ul>
<blockquote>
<p>JVM的int入栈操作指令参考</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 参考链接</span><br><span class="line">https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</span><br><span class="line">## int入栈指令</span><br><span class="line">iconst_&lt;i&gt; 	操作常量 -1 - 5</span><br><span class="line">ipush 			操作一个字节的int数据</span><br><span class="line">sipush			操作两个字节的int数据</span><br><span class="line">ldc				超过两个字节的int数据</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main方法执行分析</p>
</blockquote>
<ul>
<li><code>int balance = 500</code> 分析<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// source.java</span></span><br><span class="line"> <span class="keyword">int</span> balance = <span class="number">500</span>;</span><br><span class="line"> <span class="comment">// 字节码文件</span></span><br><span class="line"> <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line"> <span class="number">3</span>: istore_1</span><br><span class="line"><span class="comment">// 其他定义变量的操作与上述一致</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p> <strong>将500压入操作数栈中并存储在本地变量表,然后弹出操作数栈,同时程序计数器记录当前代码执行的位置</strong></p>
<ul>
<li><code>int cakeNum = 1;</code>与<code>int flower = 2;</code>分析<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source.java</span></span><br><span class="line"> <span class="keyword">int</span> cakeNum = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> flower = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码文件</span></span><br><span class="line"><span class="number">7</span>: iconst_1		</span><br><span class="line"><span class="number">8</span>: istore_3</span><br><span class="line"><span class="number">9</span>: iconst_2</span><br><span class="line"><span class="number">10</span>: istore        <span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>JVM将常量1和2压入操作数栈并存储在本地变量表中,然后弹出操作数栈,更新程序计数器当前执行的代码的位置</strong></p>
<ul>
<li>进行乘法运算<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source.java</span></span><br><span class="line"><span class="keyword">int</span> cakeSpent = cakeNum * cakeVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码</span></span><br><span class="line"> <span class="number">16</span>: iload_3		<span class="comment">// 1</span></span><br><span class="line"> <span class="number">17</span>: iload_2		<span class="comment">// 99</span></span><br><span class="line"> <span class="number">18</span>: imul</span><br><span class="line"> <span class="number">19</span>: istore        <span class="number">6</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>将本地变量表中的数据1 和 数据99分别压入操作数栈中然后进行乘法运算最后将运算结果存储在本地变量表中</strong><br>其他的数学基本运算也是依次类推</p>
<ul>
<li>打印输出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//source.java</span></span><br><span class="line">System.out.printf(<span class="string">&quot;in order to celebrate birthday for my gift friends, i have spent %d\n&quot;</span>, totalSpent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码文件</span></span><br><span class="line"> <span class="number">41</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"> <span class="number">44</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String in order to celebrate birthday for my gift friends, i have spent %d\n</span></span><br><span class="line"> <span class="number">46</span>: iconst_1</span><br><span class="line"> <span class="number">47</span>: anewarray     #<span class="number">4</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line"> <span class="number">50</span>: dup</span><br><span class="line"> <span class="number">51</span>: iconst_0</span><br><span class="line"> <span class="number">52</span>: iload         <span class="number">8</span></span><br><span class="line"> <span class="number">54</span>: invokestatic  #<span class="number">5</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line"> <span class="number">57</span>: aastore</span><br><span class="line"> <span class="number">58</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;</span></span><br><span class="line"> <span class="number">61</span>: pop</span><br></pre></td></tr></table></figure></li>
<li>分析:<ul>
<li>getstatic     #2 表示从常量池获取静态资源#2并将其加载到操作数栈中,同时创建新的栈帧,因为属于一个新的方法调用</li>
<li>ldc    将常量池中将字符串数据压入操作数栈中</li>
<li>anewarray     #4  从常量池中获取静态资源#4并将其创建一个新的对象数组引用</li>
<li>dup 上述的对象引用复制到操作数栈的顶部</li>
<li>iload         8 从本地变量表中加载totalSpent的数据</li>
<li>invokestatic  执行整数转换为字符串的方法,将totalSpent转换为字符串</li>
<li>aastore    将上述计算得到的结果存储到本地变量表中</li>
<li>invokevirtual 调用方法输出字符串到控制台中</li>
<li>main的线程中弹出getstatic的栈帧</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>java程序代码转换为.class字节码的时候是按照指定的字节码指令进行操作</li>
<li>线程栈中定义的局部变量数据将会压入操作栈中进行计算然后存储到本地变量表中,并且会将执行代码的行数记录到程序计数器中</li>
<li>线程调用方法的时候会新创建一个新的栈帧执行对应的方法中的代码,当方法执行完成之后栈帧将会从当前的线程中弹出</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S容器化技术</title>
    <url>/2021/04/18/k8s01/</url>
    <content><![CDATA[<span id="more"></span>


]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>linux工作常用命令小结1</title>
    <url>/2019/06/02/linux01/</url>
    <content><![CDATA[<span id="more"></span>


<h4 id="linux之用户管理命令小结"><a href="#linux之用户管理命令小结" class="headerlink" title="linux之用户管理命令小结"></a>linux之用户管理命令小结</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><blockquote>
<p>为用户创建相应的帐号和用户目录/home/username</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加用户操作也会相应的增加一个同名的组，用户属于同名组</span></span><br><span class="line">useradd -m username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置密码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完全的删除用户信息，使用-r选项</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel -r username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>帐号切换为userB</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su userB</span><br></pre></td></tr></table></figure>

<h5 id="2-添加用户组"><a href="#2-添加用户组" class="headerlink" title="2. 添加用户组"></a>2. 添加用户组</h5><blockquote>
<p>查看当前用户所属的组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groups</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将用户加入到组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -G groupNmame username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变更用户所属的根组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将用户加入到新的组，并从原有的组中除去</span></span><br><span class="line">usermod -g groupName username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看系统的所有组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more /etc/passwd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有的用户组及权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more /etc/group</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看文件所属用户、用户所在组以及其他用户的读写权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件属性字段总共有10个字母组成</span></span><br><span class="line"><span class="comment"># 第一个字母表示文件类型，如果这个字母是一个减号”-”,则说明该文件是一个普通文件。字母”d”表示该文件是一个目录，字母”d”,是dirtectory(目录)的缩写</span></span><br><span class="line"><span class="comment"># 后面的9个字母为该文件的权限标识，3个为一组，分别表示文件所属用户、用户所在组、其它用户的读写和执行权限</span></span><br><span class="line">ls -l /etc/group</span><br><span class="line">-rw-r--r-- 1 root root 3042 Apr 10 10:51 /etc/group</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更改读写权限(字母方式)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：chmod userMark(+|-)PermissionsMark file_name</span></span><br><span class="line"><span class="comment"># userMark：u：用户 | g：组 | o：其它用户 | a：所有用户</span></span><br><span class="line"><span class="comment"># PermissionsMark: r:读 | w：写 | x：执行</span></span><br><span class="line"></span><br><span class="line">chmod a+x file_name     <span class="comment"># 所有用户可执行</span></span><br><span class="line">chmod g+x file_name2    <span class="comment"># 用户所在组可执行</span></span><br><span class="line">chmod o-x file_name3    <span class="comment"># 其他用户不可执行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>更改读写权限(数字方式)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4(读)、2(写)、1(执行)三种数值的和来确定权限</span></span><br><span class="line"><span class="comment"># 第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限</span></span><br><span class="line">chmod 640 file_name    <span class="comment"># 设置用户为读写，组为可读不可写，其他的用户不可读写权限</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>更改文件或目录所属拥有者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown username dirOrfile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用-R选项递归更改该目下所有文件的拥有者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R username dir/</span><br></pre></td></tr></table></figure>

<h5 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h5><ul>
<li>bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/profile，/etc/bashrc 是系统全局环境变量设定</span><br><span class="line">~/.profile，~/.bashrc用户目录下的私有环境变量设定</span><br></pre></td></tr></table></figure>

<blockquote>
<p>登入系统获得一个shell进程时，其读取环境设置脚本分为三步</p>
</blockquote>
<ul>
<li>首先读入的是全局环境变量设置文件/etc/profile，然后根据其内容读取额外的文档，如/etc/profile.d和/etc/inputrc</li>
<li>读取当前登录用户Home目录下的文件<del>/.bash_profile，其次读取</del>/.bash_login，最后读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系</li>
<li>读取~/.bashrc</li>
</ul>
<blockquote>
<p>~/.profile 与 ~/.bashrc的区别</p>
</blockquote>
<ul>
<li>都具有个性化定制功能</li>
<li>~/.profile可以设定本用户专有的路径，环境变量等，它只能登入的时候执行一次</li>
<li>~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次</li>
</ul>
<blockquote>
<p>上述的应用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"><span class="built_in">alias</span> m=<span class="string">&#x27;more&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> lsl=<span class="string">&#x27;ls -lrt&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> lm=<span class="string">&#x27;ls -al|more&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>=/opt/applog/common_dir</span><br><span class="line">unit=/opt/app/unittest/common</span><br><span class="line"></span><br><span class="line">.bash_profile</span><br><span class="line">. /opt/app/tuxapp/openav/config/setenv.prod.sh.linux</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;$PWD#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过上述设置，我们进入log目录就只需要输入cd $log即可</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>linux工作常用命令小结2</title>
    <url>/2019/06/08/linux02/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="linux-监控命令小结"><a href="#linux-监控命令小结" class="headerlink" title="linux 监控命令小结"></a>linux 监控命令小结</h4><blockquote>
<p>IO监控</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iostat 仅对系统整体情况进行分析</span></span><br><span class="line"><span class="comment"># 系统级别的IO监控</span></span><br><span class="line">iostat -xdm 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># %util:代表磁盘繁忙程度。100% 表示磁盘繁忙, 0%表示磁盘空闲。但是注意,磁盘繁忙不代表磁盘(带宽)利用率高  </span></span><br><span class="line"><span class="comment"># argrq-sz:提交给驱动层的IO请求大小,一般不小于4K,不大于max(readahead_kb, max_sectors_kb),可用于判断当前的IO模式,一般情况下,尤其是磁盘繁忙时, 越大代表顺序,越小代表随机</span></span><br><span class="line"><span class="comment"># svctm:一次IO请求的服务时间,对于单块盘,完全随机读时,基本在7ms左右,既寻道+旋转延迟时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程级IO监控</span></span><br><span class="line"><span class="comment"># iotop:顾名思义, io版的top</span></span><br><span class="line"><span class="comment"># pidstat:顾名思义, 统计进程(pid)的stat,进程的stat自然包括进程的IO状况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 业务级IO监控</span></span><br><span class="line"><span class="comment"># ioprofile 命令本质上是 lsof + strace, 具体下载可见 http://code.google.com/p/maatkit/</span></span><br><span class="line">ioprofile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件级IO监控</span></span><br><span class="line"><span class="comment"># 文件级IO监控可以配合/补充&quot;业务级和进程级&quot;IO分析</span></span><br><span class="line"><span class="comment"># 文件级IO分析,主要针对单个文件, 回答当前哪些进程正在对某个文件进行读写操作.</span></span><br><span class="line"><span class="comment"># 1 lsof   或者  ls /proc/pid/fd</span></span><br><span class="line"><span class="comment"># 2 inodewatch.stp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inodewatch.stp</span></span><br><span class="line"><span class="comment">#! /usr/bin/env stap</span></span><br><span class="line"></span><br><span class="line">probe vfs.write, vfs.read</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># dev and ino are defined by vfs.write and vfs.read</span></span><br><span class="line">  <span class="keyword">if</span> (dev == MKDEV(<span class="variable">$1</span>,<span class="variable">$2</span>) <span class="comment"># major/minor device</span></span><br><span class="line">      &amp;&amp; ino == <span class="variable">$3</span>)</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%s(%d) %s 0x%x/%u\n&quot;</span>,</span><br><span class="line">      execname(), pid(), probefunc(), dev, ino)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看磁盘IO</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左右箭头：改变排序方式，默认是按IO排序。</span></span><br><span class="line"><span class="comment"># r：改变排序顺序。</span></span><br><span class="line"><span class="comment"># o：只显示有IO输出的进程。</span></span><br><span class="line"><span class="comment"># p：进程/线程的显示方式的切换。</span></span><br><span class="line"><span class="comment"># a：显示累积使用量。</span></span><br><span class="line"><span class="comment"># q：退出。</span></span><br><span class="line">iotop -oP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看进程cpu，内存负载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -c</span><br><span class="line"><span class="comment"># 按键F，进入选择模式，根据linux上面的提示，如果选择排序则按键S，再退出即会显示按照指定的指标排序显示</span></span><br><span class="line"><span class="comment"># 显示内存状态 free,具体包括物理内存,虚拟内存,共享内存和系统缓存</span></span><br><span class="line"><span class="comment"># 显示系统进程在瞬间的运行动态,ps</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚拟内存状态</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以报告关于进程、内存、I/O等系统整体运行状态</span></span><br><span class="line"><span class="comment"># 事件间隔：状态信息刷新的时间间隔；</span></span><br><span class="line"><span class="comment"># 次数：显示报告的次数。</span></span><br><span class="line">vmstat 3   <span class="comment"># 每隔3s打印一次</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>磁盘分区监控</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分区使用率大于85%:&#123;/home:[90.7568]&#125;,搜索磁盘占用空间最大的目录并通知清理</span></span><br><span class="line"><span class="comment"># du命令是对文件和目录磁盘使用的空间的查看</span></span><br><span class="line">du --max-depth=1 -BM ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内存监控</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 机器内存free（含buf/cache）小于10%（7.1800）</span></span><br><span class="line"><span class="comment"># 查看内存占用情况</span></span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程占用的内存,从高到低占用排序</span></span><br><span class="line">top -c -o -%MEM</span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计网络接口活动</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ifstat命令就像iostat/vmstat描述其它的系统状况一样，是一个统计网络接口活动状态的工具</span></span><br><span class="line">apt-get install -y ifstat</span><br><span class="line">ifstat -tT</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看网络状态</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况</span></span><br><span class="line"><span class="comment"># 并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息</span></span><br><span class="line">netstat -ap | grep uwsgi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示网络接口列表</span></span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看phpcgi进程数，如果接近预设值，说明不够用，需要增加</span></span><br><span class="line">netstat -anpo | grep <span class="string">&quot;php-cgi&quot;</span> | wc -l</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全能系统信息统计工具</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具</span></span><br><span class="line"><span class="comment"># 监控swap，process，sockets，filesystem并显示监控的时间</span></span><br><span class="line">dstat -tsp --socket --fs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示系统的平均负载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uptime命令能够打印系统总共运行了多长时间和系统的平均负载。</span></span><br><span class="line"><span class="comment"># uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载</span></span><br><span class="line">uptime</span><br></pre></td></tr></table></figure>

<blockquote>
<p>系统运行状态统计工具</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备</span></span><br><span class="line"><span class="comment"># 察看内存和交换空间的使用率</span></span><br><span class="line"><span class="comment"># kbmemfree与kbmemused字段分别显示内存的未使用与已使用空间，后面跟着的是已使用空间的百分比（%memused字段）。</span></span><br><span class="line"><span class="comment"># kbbuffers与kbcached字段分别显示缓冲区与系统全域的数据存取量，单位为KB。</span></span><br><span class="line">sar -r</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>linux工作常用命令小结3</title>
    <url>/2019/06/12/linux03/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="linux-工作常用命令小结-1"><a href="#linux-工作常用命令小结-1" class="headerlink" title="linux 工作常用命令小结(1)"></a>linux 工作常用命令小结(1)</h4><blockquote>
<p>参考链接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 参考链接：</span><br><span class="line">http://man.linuxde.net/</span><br><span class="line">http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查机器配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux CPU大小,对于双核的cpu，在cpuinfo中会看到两个cpu,通过Physical Processor ID来区分单核和双核</span></span><br><span class="line">cat /proc/cpuinfo |grep <span class="string">&quot;model name&quot;</span> &amp;&amp; cat /proc/cpuinfo |grep <span class="string">&quot;physical id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存大小</span></span><br><span class="line">cat /proc/meminfo |grep MemTotal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬盘大小</span></span><br><span class="line">fdisk -l | grep Disk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核/操作系统/CPU信息的linux系统信息命令</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看操作系统版本,是数字1不是字母L</span></span><br><span class="line">head -n 1 /etc/issue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU信息的linux系统信息命令</span></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出加载的内核模块</span></span><br><span class="line">lsmod </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看环境变量资源</span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用量和交换区使用量</span></span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各分区使用情况</span></span><br><span class="line">df -h </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定目录的大小</span></span><br><span class="line">du -sh *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统运行时间、用户数、负载</span></span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统负载磁盘和分区</span></span><br><span class="line">cat /proc/loadavg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载的分区状态</span></span><br><span class="line">mount | column -t </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有分区</span></span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有网络接口的属性</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙设置</span></span><br><span class="line">iptables -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看路由表</span></span><br><span class="line">route -n </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有监听端口</span></span><br><span class="line">netstat -lntp </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已经建立的连接</span></span><br><span class="line">netstat -antp </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络统计信息进程</span></span><br><span class="line">netstat -s </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有进程</span></span><br><span class="line">ps -ef </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有用户</span></span><br><span class="line">cut -d: -f1 /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有组</span></span><br><span class="line">cut -d: -f1 /etc/group</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前用户的计划任务服务</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志查看</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more /path/logfiles</span><br><span class="line">less /path/logfiles</span><br><span class="line">tail -f /path/logfiles</span><br></pre></td></tr></table></figure>

<blockquote>
<p>机器监控命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看系统进程/cpu/内存/线程等信息</span></span><br><span class="line">top</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 文本处理操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量的文件转换为linux的换行符号</span></span><br><span class="line">find dir/ -name <span class="string">&quot;*.py&quot;</span> |xargs sed -i <span class="string">&#x27;s/\r//&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单个文件</span></span><br><span class="line">sed -i <span class="string">&#x27;s/\r//&#x27;</span>  filename</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看当前服务IP</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 出口IP</span></span><br><span class="line">curl http://members.3322.org/dyndns/getip</span><br><span class="line"><span class="comment"># 内网IP 以及 服务的网卡信息</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看端口占用的进程</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof –i:port</span><br></pre></td></tr></table></figure>

<blockquote>
<p>域名操作工具</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常</span></span><br><span class="line">dig www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># nslookup，是常用域名查询工具，就是查DNS信息用的命令</span></span><br><span class="line">nslookup www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># host命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常</span></span><br><span class="line">host www.baidu.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>追踪网络数据包信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># traceroute命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节</span></span><br><span class="line">traceroute www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcpdump，可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析</span></span><br><span class="line">tcpdump tcp port 80     <span class="comment"># 监控本机器的80端口数据包流量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓包命令</span></span><br><span class="line">ngrep -d any -W byline port port_num | head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心技术分析</title>
    <url>/2020/05/21/redis01/</url>
    <content><![CDATA[<span id="more"></span>


]]></content>
      <categories>
        <category>middleware</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型设计</title>
    <url>/2018/04/02/data_design/</url>
    <content><![CDATA[<span id="more"></span>

<blockquote>
<p>整数类型</p>
</blockquote>
<ul>
<li>整数:tinyint(8bit存储空间)、smallint(16bit存储空间)、mediumint(24bit存储空间)、int(32bit存储空间)、bigint(64bit存储空间)</li>
<li>整数有可选的unsigned属性,表示不允许为负值,无符号和有符号类型使用相同的存储空间,并具有相同的性能</li>
<li>整数计算一般使用64bit的bigint整数,即使在32bit的环境也是如此</li>
</ul>
<blockquote>
<p>实数</p>
</blockquote>
<ul>
<li>float和double支持使用标准的浮点运算进行近似计算</li>
<li>decimal类型用于存储精确的小数,在数据量比较大的时候,可以考虑bigint代替decimal,即将需要存储的货币单位根据小数位数乘以相应的倍数</li>
</ul>
<blockquote>
<p>字符串类型</p>
</blockquote>
<ul>
<li><p>varchar</p>
<ul>
<li>存储可变长的字符串,比定长类型的字符串更加节省空间,仅仅使用必要的空间,但是如果mysql使用row_format=fixed创建表的时候将使用定长存储</li>
<li>varchar需要使用额外的1-2bit记录字符串的长度,若列的最大长度&lt;=255bit,则只使用1个字节表示,否则使用2个字节表示</li>
<li>由于行是可变长的,导致在做update的时候会变得比原来更长</li>
<li>如果一个行占用的空间增长,并且在页内没有更多的空间可以存储<ul>
<li>对于MyISAM的执行引擎:会将行拆分成不通的片段进行压缩</li>
<li>InnoDB:需要分裂页来使行可以放进页内</li>
</ul>
</li>
<li>MySQL5.0以上的在存储和检索的时候会保留末尾的空格,但是在4.1的时候或更老的版本中会剔除空格</li>
<li>使用场景:<ul>
<li>1)字符串列的最大长度比平均长度大很多;</li>
<li>2)列的更新很少,所以碎片不是问题;</li>
<li>3)使用像UTF-8这样复杂的字符集,每个字符都使用不同的字节数来进行存储</li>
</ul>
</li>
</ul>
</li>
<li><p>char</p>
<ul>
<li>MySQL总是根据定义的字符串长度分配足够的空间,使用char类型进行存储的时候,mysql会删除所有的末尾空格</li>
<li>使用场景:<ul>
<li>1)对于经常变更的数据,char定长存储不容易产生碎片,因而会有更好的性能</li>
<li>2)char可以用来存储密码的md5值</li>
</ul>
</li>
</ul>
</li>
<li><p>Blob与Text类型</p>
<ul>
<li>字符类型:tinytext、smalltext、text、mediumtext、longtext</li>
<li>二进制类型:tinyblob、smallblob、blob、mediumblob、longblob</li>
<li>Innodb在blob和text存储过大的时候,会使用外部存储区域来进行存储,此时需要每个值在行内需要1-4个字节存储一个指针,然后在外部存储区域存储实际的值</li>
</ul>
</li>
<li><p>日期和时间类型</p>
<ul>
<li>DateTime:能保存大范围的值,精度是秒,它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中,与时区无关,使用8个字节的存储空间</li>
<li>TimeStamp:只使用4个字节的存储空间,因此它的范围比DateTime小得多,一般情况下尽量使用TimeStamp,因为它的空间效率更高</li>
<li>如果需要存储更小的细粒度时间,可以使用bigint或者是double存储秒之后的小数部分或者使用MariaDB</li>
</ul>
</li>
<li><p>位数据类型（从技术上角度都是字符串类型,但都尽量避免使用）    </p>
<ul>
<li>bit（尽量避免使用）<ul>
<li>mysql把bit当做字符串类型,而不是数字类型,检索的时候是一个包含二进制0或1值的字符串</li>
<li>在数字的上下文中,是将位字符串转换层数字</li>
<li>若在一个bit的存储空间上存储一个true/false的值,可以考虑使用一个为空的CHAR(0)列,该列可以保存空值NULL或者长度为0的字符串</li>
</ul>
</li>
<li>set（修改字段是整表修改的,并且也无法在SET列上通过索引查找）– 应用场景不强,不深入</li>
</ul>
</li>
<li><p>Id的标识符选择</p>
<ul>
<li>选择的思考:一个是考虑存储类型,一个是MySQL对这种存储类型的执行计算和比较如何</li>
<li>落地的原则:一旦选择相应的存储类型,要保证关联的表中也尽量靠近或者是选择相同的存储类型</li>
<li>最小原则:选择的标识符既要考虑当前的业务情况还要考虑未来可能增长的情况,比如建立一个列Id来存储省份的名称标识,这时候是不需要几千或者几万的值,可以考虑tinyint</li>
<li>选择的类型比较:<ul>
<li>整数:可以使用AUTO_INCREMENT并且在建立索引抑或是查询的时候具有良好的性能（存储在磁盘中占用的空间按照指定的整数类型存储,不像字符串那样分散）</li>
<li>字符串:比较消耗空间,并且如果使用MyISAM的执行引擎时会对字符串进行压缩,这样会导致磁盘查询比较慢<ul>
<li>存储UUID,应当移除’-‘符号,并用unhex()函数转换为16字节的数字并存储在一个binary(16)列中,检索时通过hex()函数格式化为16进制格式</li>
<li>UUID、散列函数（md5/sha1）等生成的数据会任意分布在很大的空间内,会导致insert以及一些select语句变得很慢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊类型</p>
<ul>
<li>存储地址IP,可以使用无符号的32位整数进行存储,IP实际上就是32位无符号整数类型,不是字符串,可以使用MySQL的函数</li>
<li>IMET_ATON():将IP地址转换为32位无符号整数</li>
<li>INET_NTOA():将32位无符号整数转换为IP地址</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL技术</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/06/03/mysql01/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>mysql存储过程案例</title>
    <url>/2018/04/06/produce/</url>
    <content><![CDATA[<span id="more"></span>

<p>本文介绍关于在MySQL存储过程游标使用实例，包括简单游标使用与游标循环跳出等方法</p>
<blockquote>
<p>例1、一个简单存储过程游标实例</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> getUserInfo $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> getUserInfo(<span class="keyword">in</span> date_day datetime)</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- 实例</span></span><br><span class="line"><span class="comment">-- 存储过程名为：getUserInfo</span></span><br><span class="line"><span class="comment">-- 参数为：date_day日期格式:2008-03-08</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">declare</span> _userName <span class="type">varchar</span>(<span class="number">12</span>); <span class="comment">-- 用户名</span></span><br><span class="line"><span class="keyword">declare</span> _chinese <span class="type">int</span> ; <span class="comment">-- 语文</span></span><br><span class="line"><span class="keyword">declare</span> _math <span class="type">int</span> ;    <span class="comment">-- 数学</span></span><br><span class="line"><span class="keyword">declare</span> done <span class="type">int</span>;</span><br><span class="line"><span class="comment">-- 定义游标 www.jbxue.com</span></span><br><span class="line"><span class="keyword">DECLARE</span> rs_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> username,chinese,math <span class="keyword">from</span> userInfo <span class="keyword">where</span> datediff(createDate, date_day)<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 获取昨天的日期</span></span><br><span class="line">if date_day <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">set</span> date_day <span class="operator">=</span> date_add(now(),<span class="type">interval</span> <span class="number">-1</span> <span class="keyword">day</span>);</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">open</span> rs_cursor;</span><br><span class="line">cursor_loop:loop</span><br><span class="line">   <span class="keyword">FETCH</span> rs_cursor <span class="keyword">into</span> _userName, _chinese, _math; <span class="comment">-- 取数据</span></span><br><span class="line"></span><br><span class="line">   if done<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    leave cursor_loop;</span><br><span class="line">   <span class="keyword">end</span> if;</span><br><span class="line">   <span class="comment">-- 更新表</span></span><br><span class="line">   update infoSum <span class="keyword">set</span> total<span class="operator">=</span>_chinese<span class="operator">+</span>_math <span class="keyword">where</span> UserName<span class="operator">=</span>_userName;</span><br><span class="line"><span class="keyword">end</span> loop cursor_loop;</span><br><span class="line"><span class="keyword">close</span> rs_cursor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例2、存储过程游标循环跳出现<br>在MySQL的存储过程中,游标操作时,需要执行一个conitnue的操作.众所周知,MySQL中的游标循环操作常用的有三种,LOOP,REPEAT,WHILE.三种循环,方式大同小异.以前从没用过,所以记下来,方便以后查阅.</p>
</blockquote>
<ol>
<li>REPEAT</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    Statements;</span><br><span class="line">  UNTIL expression</span><br><span class="line"><span class="keyword">END</span> REPEAT</span><br><span class="line">demo</span><br><span class="line"><span class="keyword">DECLARE</span> num <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> my_string  <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span>  my_string <span class="operator">=</span>CONCAT(my_string,num,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">SET</span>  num <span class="operator">=</span> num <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  UNTIL num <span class="operator">&lt;</span><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>WHILE</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE expression DO</span><br><span class="line">    Statements;</span><br><span class="line"><span class="keyword">END</span> WHILE</span><br><span class="line">demo</span><br><span class="line"><span class="keyword">DECLARE</span> num <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> my_string  <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">SET</span> num <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> str <span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  WHILE num  <span class="operator">&lt;</span> span<span class="operator">&gt;</span><span class="number">10</span>DO</span><br><span class="line"><span class="keyword">SET</span>  my_string <span class="operator">=</span>CONCAT(my_string,num,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">SET</span>  num <span class="operator">=</span> num <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>LOOP(这里面有非常重要的ITERATE,LEAVE)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> num  <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> str  <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line"><span class="keyword">SET</span> num <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> my_string <span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  loop_label:  LOOP</span><br><span class="line">IF  num <span class="operator">&lt;</span><span class="number">10</span><span class="keyword">THEN</span></span><br><span class="line">      LEAVE  loop_label;</span><br><span class="line">ENDIF;</span><br><span class="line"><span class="keyword">SET</span>  num <span class="operator">=</span> num <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">IF(num mod3)<span class="keyword">THEN</span></span><br><span class="line">      ITERATE  loop_label;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">SET</span>  my_string <span class="operator">=</span>CONCAT(my_string,num,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">ENDIF;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"># PS:可以这样理解ITERATE就是我们程序中常用的contiune,而ITERATE就是break.当然在MySQL存储过程,需要循环结构有个名称,其他都是一样的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例3,mysql 存储过程中使用多游标</p>
</blockquote>
<ul>
<li>先创建一张表，插入一些测试数据：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> netingcn_proc_test;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `netingcn_proc_test` (</span><br><span class="line">  `id` <span class="type">INTEGER</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  `password` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> netingcn_proc_test(name, password) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;procedure1&#x27;</span>, <span class="string">&#x27;pass1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;procedure2&#x27;</span>, <span class="string">&#x27;pass2&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;procedure3&#x27;</span>, <span class="string">&#x27;pass3&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;procedure4&#x27;</span>, <span class="string">&#x27;pass4&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 下面就是一个简单存储过程的例子：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> IF <span class="keyword">EXISTS</span> test_proc;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_proc()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="comment">-- 声明一个标志done， 用来判断游标是否遍历完成</span></span><br><span class="line"> <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> <span class="comment">-- 声明一个变量，用来存放从游标中提取的数据</span></span><br><span class="line"> <span class="comment">-- 特别注意这里的名字不能与由游标中使用的列明相同，否则得到的数据都是NULL</span></span><br><span class="line"> <span class="keyword">DECLARE</span> tname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tpass <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="comment">-- 声明游标对应的 SQL 语句</span></span><br><span class="line"> <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">select</span> name, password <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line"> <span class="comment">-- 在游标循环到最后会将 done 设置为 1</span></span><br><span class="line"> <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> <span class="comment">-- 执行查询</span></span><br><span class="line"> <span class="keyword">open</span> cur;</span><br><span class="line"> <span class="comment">-- 遍历游标每一行</span></span><br><span class="line"> REPEAT</span><br><span class="line">  <span class="comment">-- 把一行的信息存放在对应的变量中</span></span><br><span class="line">  <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> tname, tpass;</span><br><span class="line">  if <span class="keyword">not</span> done <span class="keyword">then</span></span><br><span class="line">   <span class="comment">-- 这里就可以使用 tname， tpass 对应的信息了</span></span><br><span class="line">   <span class="keyword">select</span> tname, tpass;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line">  UNTIL done <span class="keyword">END</span> REPEAT;</span><br><span class="line"> <span class="keyword">CLOSE</span> cur;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行存储过程(第一种情况)  </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> test_proc();</span><br><span class="line"></span><br><span class="line">#  需要注意的是变量的声明、游标的声明和HANDLER声明的顺序不能搞错，必须是先声明变量，再申明游标，最后声明HANDLER。上述存储过程的例子中只使用了一个游标，那么如果要使用两个或者更多游标怎么办，其实很简单，可以这么说，一个怎么用两个就是怎么用的。例子如下：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> IF <span class="keyword">EXISTS</span> test_proc_1;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_proc_1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tid <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tpass <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> cur_1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">select</span> name, password <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line"> <span class="keyword">DECLARE</span> cur_2 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">select</span> id, name <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line"> <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">open</span> cur_1;</span><br><span class="line"> REPEAT</span><br><span class="line">  <span class="keyword">FETCH</span> cur_1 <span class="keyword">INTO</span> tname, tpass;</span><br><span class="line">  if <span class="keyword">not</span> done <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">select</span> tname, tpass;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line">  UNTIL done <span class="keyword">END</span> REPEAT;</span><br><span class="line"> <span class="keyword">CLOSE</span> cur_1;</span><br><span class="line"> <span class="comment">-- 注意这里，一定要重置done的值为 0</span></span><br><span class="line"> <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">open</span> cur_2;</span><br><span class="line"> REPEAT</span><br><span class="line">  <span class="keyword">FETCH</span> cur_2 <span class="keyword">INTO</span> tid, tname;</span><br><span class="line">  if <span class="keyword">not</span> done <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">select</span> tid, tname;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line">  UNTIL done <span class="keyword">END</span> REPEAT;</span><br><span class="line"> <span class="keyword">CLOSE</span> cur_2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> test_proc_1();</span><br></pre></td></tr></table></figure>

<ul>
<li>执行存储过程(第二种情况)  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 上述代码和第一个例子中基本一样，就是多了一个游标声明和遍历游标。这里需要注意的是，在遍历第二个游标前使用了<span class="keyword">set</span> done <span class="operator">=</span> <span class="number">0</span>，因为当第一个游标遍历玩后其值被handler设置为<span class="number">1</span>了，如果不用<span class="keyword">set</span>把它设置为 <span class="number">0</span> ，那么第二个游标就不会遍历了。当然好习惯是在每个打开游标的操作前都用该语句，确保游标能真正遍历。当然还可以使用<span class="keyword">begin</span>语句块嵌套的方式来处理多个游标,例如：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> IF <span class="keyword">EXISTS</span> test_proc_2;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_proc_2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> tpass <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span> cur_1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">select</span> name, password <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line"> <span class="keyword">DECLARE</span> cur_2 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">select</span> id, name <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line"> <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">open</span> cur_1;</span><br><span class="line"> REPEAT</span><br><span class="line">  <span class="keyword">FETCH</span> cur_1 <span class="keyword">INTO</span> tname, tpass;</span><br><span class="line">  if <span class="keyword">not</span> done <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">select</span> tname, tpass;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line">  UNTIL done <span class="keyword">END</span> REPEAT;</span><br><span class="line"> <span class="keyword">CLOSE</span> cur_1;</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> tid <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> tname <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> cur_2 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">   <span class="keyword">select</span> id, name <span class="keyword">from</span> netingcn_proc_test;</span><br><span class="line">  <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">open</span> cur_2;</span><br><span class="line">  REPEAT</span><br><span class="line">   <span class="keyword">FETCH</span> cur_2 <span class="keyword">INTO</span> tid, tname;</span><br><span class="line">   if <span class="keyword">not</span> done <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">select</span> tid, tname;</span><br><span class="line">   <span class="keyword">end</span> if;</span><br><span class="line">   UNTIL done <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">CLOSE</span> cur_2;</span><br><span class="line"> <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> test_proc_2();</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL技术</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql工作笔记</title>
    <url>/2018/04/23/work_notes/</url>
    <content><![CDATA[<span id="more"></span>


<blockquote>
<p>mysql分配用户以及相应的权限,设置远程访问</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>新建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> username IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span>分配用户权限</span><br><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> userName (<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION);</span><br><span class="line">如果添加<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION代表该用户还可以为其他用户授权，否则没有为其他用户授权的权限</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span>允许远程访问</span><br><span class="line">## <span class="number">1</span>）更改表</span><br><span class="line">update mysql.user <span class="keyword">set</span> `Host` <span class="operator">=</span> &quot;%&quot; <span class="keyword">where</span> `<span class="keyword">User</span>`<span class="operator">=</span>&quot;userName&quot; <span class="keyword">and</span> `Host`<span class="operator">=</span>&quot;localhost&quot;</span><br><span class="line">## <span class="number">2</span>)直接授权</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;%|ipaddress&#x27;</span> IDENTIFY <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION</span><br><span class="line">## [<span class="operator">%</span>表示任意主机，ipaddress表示指定的ip可以访问]</span><br><span class="line"></span><br><span class="line">## 最后要更改mysql的配置</span><br><span class="line">sudo vim <span class="operator">/</span>etc<span class="operator">/</span>mysql<span class="operator">/</span>my.cnf</span><br><span class="line">bind<span class="operator">-</span>address:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 注释掉</span><br><span class="line"></span><br><span class="line">## 然后重启mysql</span><br><span class="line">sudo service mysql restart</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span>最后如果有修改权限，要刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改密码</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># mysql<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;newpass&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># mysqladmin</span><br><span class="line">mysqladmin <span class="operator">-</span>u root password &quot;newpass&quot;</span><br><span class="line">mysqladmin <span class="operator">-</span>u root password oldpass &quot;newpass&quot;  # root已经设置过密码</span><br><span class="line"></span><br><span class="line"># 用UPDATE直接编辑<span class="keyword">user</span>表</span><br><span class="line">　mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">　mysql<span class="operator">&gt;</span> UPDATE <span class="keyword">user</span> <span class="keyword">SET</span> Password <span class="operator">=</span> PASSWORD(<span class="string">&#x27;newpass&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">　mysql<span class="operator">&gt;</span> FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>导入导出数据库</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 导入<span class="keyword">sql</span>文件</span><br><span class="line"><span class="number">1.</span> 连接进入mysql数据库</span><br><span class="line">mysql <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 cctestaudit</span><br><span class="line">source path<span class="operator">/</span>sql.sql</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 直接命令导入</span><br><span class="line">mysql <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 cctestaudit <span class="operator">&lt;</span> path<span class="operator">/</span>sql.sql</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 导出整个数据库中的所有数据</span><br><span class="line">mysqldump <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 cctestaudit <span class="operator">&gt;</span> fileName.sql</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 导出数据库中某张表</span><br><span class="line">mysqldump <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 cctestaudit tableName <span class="operator">&gt;</span> fileName.sql</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 导出数据库中所有表结构</span><br><span class="line">mysqldump <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 <span class="operator">-</span>d cctestaudit <span class="operator">&gt;</span> fileName.sql</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 导出某张表的结构</span><br><span class="line">mysqldump <span class="operator">-</span>h192<span class="number">.168</span><span class="number">.229</span><span class="number">.172</span> <span class="operator">-</span>ucc_test <span class="operator">-</span>pcc_test <span class="operator">-</span>P3306 <span class="operator">-</span>d cctestaudit tableName <span class="operator">&gt;</span> fileName.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建数据库指定编码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `mydb` CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL技术</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用bump管理版本号和打包</title>
    <url>/2017/12/31/bump/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="使用bump管理版本号和打包"><a href="#使用bump管理版本号和打包" class="headerlink" title="使用bump管理版本号和打包"></a>使用bump管理版本号和打包</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bump依赖于bumversion工具[https://github.com/peritus/bumpversion]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>项目添加bumpversion配置文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前项目根目录添加.bumpversion.cfg，内容如下（注意配置里面的缩进空白字符为Tab）：</span><br><span class="line">[bumpversion]</span><br><span class="line">commit = True</span><br><span class="line">tag = True</span><br><span class="line">current_version = 1.0.0</span><br><span class="line"></span><br><span class="line">[bumpversion:file:setup.py]</span><br><span class="line">search = version=&#x27;&#123;current_version&#125;&#x27;</span><br><span class="line">replace = version=&#x27;&#123;new_version&#125;&#x27;</span><br><span class="line"></span><br><span class="line">[bumpversion:file:CHANGELOG.md]</span><br><span class="line">search = Unreleased</span><br><span class="line">----------</span><br><span class="line">replace = Unreleased</span><br><span class="line">----------</span><br><span class="line">v&#123;new_version&#125; (&#123;now:%Y-%m-%d&#125;)</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line"># 说明</span><br><span class="line">上面的配置意思是使用bump打包时，会执行以下操作：</span><br><span class="line">1.根据传入的参数（majar|minor|patch）计算新版本号&#123;new_version&#125;</span><br><span class="line">2.替换./setup.py中的version=&#x27;&#123;current_version&#125;&#x27; 为 version=&#x27;&#123;new_version&#125;&#x27;</span><br><span class="line">3. 替换./CHANGELOG.md中的Unreleased\n---------- 为 Unreleased\n----------\nv&#123;new_version&#125;(YYYY-mm-dd)\n-------------------</span><br><span class="line">4. 将以上修改进行本地提交：git commit</span><br><span class="line">5. 使用新版本打一个tag：git tag v&#123;new_version&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加CHANGELOG文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前项目根目录添加CHANGELOG.md，用于记录发版历史，初始内容如下（注意格式必须匹配）：</span><br><span class="line"># pyzipkin的CHANGELOG，其中Unreleased块表示还没有发布的新功能（下次发版发布），v1.1.17块为上一次发版的内容</span><br><span class="line">Unreleased</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">- #146732 修复Redis Sentinel Server Address错误问题</span><br><span class="line">- imapp支持patch TaskBase.done</span><br><span class="line"></span><br><span class="line">v1.1.17 (2017-08-24)</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">- 区分http.uri和http.qs</span><br><span class="line">- 记录nameko HTTP接口uri和host</span><br><span class="line">- 改用util.get\_ipv4</span><br><span class="line">- 当HTTP服务的不支持zipkin时记录http.host</span><br><span class="line">- 将get\_ipv4移到util</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">注意可以手动编写该文件，但是要注意格式：</span><br><span class="line">1.每条CHANGELOG占一行，以横杠加空格开头</span><br><span class="line">2.如果CHANGELOG有Markdown格式字符，需要进行转义（如下划线前要用反斜杠转义）</span><br><span class="line">3.版本号格式为vX.X.X (YYY-mm-dd)，前面不要有空白</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装bump打包工具</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 内部开发的bump工具（注意不是pypi官网的bump），支持以下功能</span><br><span class="line">1.自动从Git提交历史抽取日志到CHANGELOG</span><br><span class="line">2. 使用bumpversion进行版本管理和打包 </span><br><span class="line">3. 使用rsysnc将pip包上传到xxx.com</span><br><span class="line"></span><br><span class="line">$ pip install -U bump -i https://xxx.com</span><br><span class="line"></span><br><span class="line">查看帮助：</span><br><span class="line"></span><br><span class="line">$ bump -h</span><br><span class="line">Usage: bump [-a|--use-all-logs] [-u|--upload] [-T|--no-tag] [-y|--auto-yes]</span><br><span class="line">[-v] [-h|--help] [majar|minor|patch|vX.X.X]</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">bump -a patch # use all logs as CHANGELOG, and release patch version</span><br><span class="line">bump -uy # upload latest version to pypi without yes/no confirm</span><br><span class="line">bump -u v1.0.0 # upload given version to pypi</span><br><span class="line"></span><br><span class="line">Environment variables:</span><br><span class="line">PYPI_SECRET Encryped secret for uploading to xxx.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打包代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用上传发版以来的所有提交日志更新到CHANGELOG，并提升patch位的版本号</span><br><span class="line">$ bump -a patch # -a 表示使用上次发版以来的所有（all）提交日志更新CHANGELOG，patch可以不填</span><br><span class="line"></span><br><span class="line"># 使用特殊的提交日志更新到CHANGELOG，并提升patch位的版本号</span><br><span class="line">特殊的提交日志包括：以`close #xxx`, `finish #xxx`, `ref #xxx`, `fix #xxx`, 或`_VER_`开头的日志。</span><br><span class="line">$ bump</span><br><span class="line"></span><br><span class="line"># 手工编辑CHANGELOG，并提升patch版本号，并将新的pip包上传到xxx.com</span><br><span class="line">$ vi CHANGELOG.md &amp;&amp; git commit # 按上面的规则编辑CHANGELOG，并提交</span><br><span class="line">$ bump -u</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推送更新到git服务器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本地打包完成后，所有修改都还在本地，可以使用git log -p查看打包进行了哪些修改，使用git tag -l查看tag。</span><br><span class="line"># 所以需要手工执行以下命令推送代码和tag到gitlab服务器：</span><br><span class="line">$ git push &amp;&amp; git push --tags</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传pip包（可选操作）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果当前项目不包含setup.py文件，则不用执行这个步骤；</span><br><span class="line">否则，打包操作时会执行python setup.py sdist，在当前目录的./dist下创建新版本的pip包。</span><br><span class="line">可以使用pip install dist/xxx.tar.gz来安装新包进行测试，测试OK后使用bump -u将最新创建的pip包上传到pypi.cc.163.com：</span><br><span class="line"></span><br><span class="line">$ bump -uy # -u 表示打包成功后，将pip包上传（upload），-y 表示提示确认时自动输入yes</span><br><span class="line"># 可以浏览https://xxx.com页面查看新上传的包，</span><br><span class="line"># 然后可以使用 pip install xxx -i https://xxx.com来安装</span><br></pre></td></tr></table></figure>

<h4 id="本文转载于公司内部文章-若有转载请标明当前博客地址-谢谢"><a href="#本文转载于公司内部文章-若有转载请标明当前博客地址-谢谢" class="headerlink" title="本文转载于公司内部文章,若有转载请标明当前博客地址,谢谢!"></a>本文转载于公司内部文章,若有转载请标明当前博客地址,谢谢!</h4>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类设计浅谈</title>
    <url>/2018/04/01/class_design/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="类设计浅谈"><a href="#类设计浅谈" class="headerlink" title="类设计浅谈"></a>类设计浅谈</h5><p>1.抽象类设计</p>
<ul>
<li>抽象方法：在编写class语句中，若有存在未定义或是未实现的或是@abstractmethod装饰器修饰的</li>
<li>抽象类：class中定义有抽象方法的类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## abs.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 第一种形式,伪抽象类,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()               <span class="comment">## action具体实现方法由子类定义z</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;action must be defined!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>(<span class="params">Super</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call sub action ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 第二种形式</span></span><br><span class="line"><span class="comment">## py3.x</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>(<span class="params">metaclass=ABCMeta</span>):</span>     <span class="comment">## 定义为抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>(<span class="params">Super</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call sub action ...&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">## py2.x</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span>                </span><br><span class="line">    __metaclass__ = ABCMeta   <span class="comment">## 通过类属性声明</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>(<span class="params">Super</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call sub action ...&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">## 第二种形式的Super不能够进行实例化,第一种形式可以进行实例化</span></span><br></pre></td></tr></table></figure>

<p>2.类的继承与组合设计</p>
<ul>
<li>继承是属于”is a”的强依赖关系,拥有父类的一系列属性和方法</li>
<li>组合是属于”has a”的弱依赖关系,也称为聚合,由各个组件组合而成共同完成一项任务目标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## task.py </span></span><br><span class="line"><span class="comment">## 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">		self.__name = name  <span class="comment">## 定义私有属性,严格意义上是属于伪属性</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;employ work ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span>(<span class="params">Employee</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;engineer coding ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span>(<span class="params">Employee</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;product manager desgin ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		self.__name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">post_requirement</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;the %s post requirement ...&quot;</span> % self.__name)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectGroup</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, engineer, manager</span>):</span></span><br><span class="line">		self.__engineer = engineer</span><br><span class="line">		self.__manager = manager</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">build_dtrees</span>(<span class="params">self, customer_name</span>):</span></span><br><span class="line">		customer = Customer(customer_name)</span><br><span class="line">		customer.post_requirement()</span><br><span class="line">		self.__manager.work()</span><br><span class="line">		self.__engineer.work()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>engineer = Engineer(<span class="string">&quot;keithl&quot;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager = ProductManager(<span class="string">&quot;keithl&quot;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pg = ProjectGroup(engineer,manager)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pg.build_dtrees(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"></span><br><span class="line">the xiaoming post requirement ...</span><br><span class="line">product manager desgin ...</span><br><span class="line">engineer coding ...</span><br></pre></td></tr></table></figure>


<p>3.类的委托(代理)</p>
<ul>
<li>对原有对象的方法进行增强，即在原有的方法基础上，丰富方法的行为</li>
<li>重载<code>__getattr__</code>内置方法并使用<code>getattr</code>方法来回调被包装类对象的属性方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## wrapper.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span></span><br><span class="line">        self.__wrapper = <span class="built_in">object</span>     <span class="comment">## 传递被包装的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,attrname</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call wrapper for attr[%s] ....&quot;</span> % attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.__wrapper,attrname)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">str</span>(self.__wrapper)</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>engineer = Engineer(<span class="string">&quot;keithl&quot;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>we = Wrapper(engineer)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>we.work(<span class="string">&quot;dtrees&quot;</span>)</span><br><span class="line">call wrapper <span class="keyword">for</span> attr[work] ....</span><br><span class="line">engineer review <span class="keyword">and</span> coding ...</span><br></pre></td></tr></table></figure>

<p>4.伪属性</p>
<ul>
<li>保证定义的类中的属性(类属性和实例属性)名称唯一,即使在同名属性的情况下也能够区分是属于哪一个类中定义的属性</li>
<li>在属性的名称前面添加<code>__</code>双下划线,后面不添加下划线,py会将这类属性转换为<code>_className__attrName</code></li>
<li>可以看成是私有属性,即对外暴露的属性名称不再是定义的属性名,而是<code>_className__attrName</code></li>
<li>使用伪属性是保证唯一性,防止在多继承过程中不同的子类命名相同而冲突</li>
</ul>
<blockquote>
<p>定义Person类私有的name属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## private.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	__template_name = <span class="string">&quot;person instance template name&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span>    </span><br><span class="line">		self.__name = name      <span class="comment">## __name 属于Person类,</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_template_name</span>():</span></span><br><span class="line">		<span class="keyword">return</span> Person.__template_name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">&quot;keithl&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p.get_name())</span><br><span class="line">keithl</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p._Person__name)</span><br><span class="line">keithl</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p.__name)</span><br><span class="line">AttributeError: <span class="string">&#x27;Person&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">dir</span>(p))</span><br></pre></td></tr></table></figure>
<p>截图</p>
<blockquote>
<p>定义Person的子类各自的私有属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## sub.py</span><br><span class="line">class Manager(Person):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">		self.__name = name      ## __name 属于Manager类</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">class Engineer(Person):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">		self.__name = name      ## __name 属于Engineer类</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; m = Manager(&quot;manager&quot;)</span><br><span class="line">&gt;&gt;&gt; e = Engineer(&quot;engineer&quot;)</span><br><span class="line"></span><br><span class="line">## 打印的结果如下图所示</span><br><span class="line">&gt;&gt;&gt; print(dir(m)) </span><br><span class="line">&gt;&gt;&gt; print(dir(e))</span><br></pre></td></tr></table></figure>
<p>截图</p>
<p>5.方法的绑定与未绑定</p>
<ul>
<li>未绑定对象的方法：不带有self参数的方法,通过定义的类来调用函数并返回一个没有绑定self的方法</li>
<li>绑定对象的方法：带有self参数的方法,即实例方法，通过实例对象调用函数并返回一个绑定self参数的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## fn.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bound class action ....&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        python3.x未绑定self对象的方法均是类定义的函数,注意这个还不是属于静态方法和类方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unbound</span>(<span class="params">num</span>):</span>               <span class="comment">## work in py3.x,fail in py2.x</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;the number is %d&quot;</span> % num)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = BoundClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.action()              <span class="comment">## action方法绑定实例对象self,可以直接通过点号运算调用  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = BoundClass.action   <span class="comment">## m是没有绑定实例对象self的方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m(t)                    <span class="comment">## 调用需要传递实例对象t</span></span><br></pre></td></tr></table></figure>

<p>6.对象工厂方法</p>
<ul>
<li>使用场景<ul>
<li>将代码与动态配置对象构造器的实现细节分离 </li>
<li>可以通过配置文件的内容在运行时动态创建实例对象</li>
<li>工厂方法允许我们使用未定义的类来避免硬编码的方式进行类的导入和传递</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## fa.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factory</span>(<span class="params">aClass,*pargs,**kwargs</span>):</span>    <span class="comment">## aClass 具体是什么类不清楚，只有在运行的时候才知道</span></span><br><span class="line">    <span class="keyword">return</span> aClass(pargs,kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## run-fa.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">现在有一个配置文件setting.py,主要是用作配置数据库的一系列参数,其中需要指定一个类是表明使用哪种数据库,如MySQL、Oracle...</span></span><br><span class="line"><span class="string">假设在一个db.py定义了实现不同的数据库对应的类模板</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> setting.py                  <span class="comment">## 读取配置文件</span></span><br><span class="line"></span><br><span class="line">classargs = setting_db_config      <span class="comment">## 获取实例化连接对象的数据库配置参数,uri,port,username,password</span></span><br><span class="line"></span><br><span class="line">classname = setting_db_class       <span class="comment">## 获取类名称的字符串</span></span><br><span class="line"></span><br><span class="line">aClass = <span class="built_in">getattr</span>(db,classname)     <span class="comment">## 从模块中获取类对象</span></span><br><span class="line"></span><br><span class="line">connection = factory(aClass,classargs)  <span class="comment">## 传递参数创建类实例对象</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类编写细节</title>
    <url>/2018/04/11/class_detail/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="类编写细节"><a href="#类编写细节" class="headerlink" title="类编写细节"></a>类编写细节</h5><p>1.class 语句</p>
<blockquote>
<p>class语句细节</p>
</blockquote>
<ul>
<li>python的class语句是属于OOP的一种工具(即定义变量名的工具，将数据和逻辑暴露给客户端)，而不是声明式的</li>
<li>class语句是对象的创建者，类似于对象工厂</li>
<li>class语句是一种隐含的赋值运算，即执行class语句时，会产生类对象并且将其引用存储到定义的类名称上</li>
<li>class语句与def一样，都是可执行语句，即python还没有执行到class语句时，类是不存在的</li>
<li>class是复合语句，所有种类语句都可以位于其主体内,如print, 赋值语句, if, def…</li>
</ul>
<blockquote>
<p>class语句如何得到命名空间</p>
</blockquote>
<ul>
<li>首先，执行类语句的时候，会从头至尾执行其主体内的所有语句</li>
<li>其次，是在执行过程中的赋值运算会在这个类作用域中创建变量名，从而成为对应的类对象属性</li>
<li>与函数相比,可以把class语句看成一个本地作用域,在class语句下定义的变量就属于这个本地作用域</li>
</ul>
<ul>
<li>与模块相比,定义的变量名是可以共享的并且成为当前类的对象属性</li>
</ul>
<blockquote>
<p>class语句一般形式 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 根据上述所言，className是类对象的一个引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span>(<span class="params">superclass1,superclass2,...</span>):</span>          </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        定义类属性,属于所有实例的共享数据,通过类语句下进行定义和创建</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    class_attr = value </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        定义实例方法以及实例属性</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self,data</span>):</span>      <span class="comment">## 定义实例方法</span></span><br><span class="line">        self.attr = data        <span class="comment">## 设置实例属性,通过带有self的方法来分配属性信息</span></span><br></pre></td></tr></table></figure>

<p>2.方法</p>
<blockquote>
<p>实例方法对象调用等价于类方法函数调用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## python自动将实例方法的调用自动转成类方法函数,并传递实例对象作为第一个参数传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s study method in for %s&quot;</span> % (name,self.__class__.__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.study(<span class="string">&quot;keithl&quot;</span>)</span><br><span class="line">keithl study method <span class="keyword">in</span> <span class="keyword">for</span> Person</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.study(p,<span class="string">&quot;keithl&quot;</span>)</span><br><span class="line">keithl study method <span class="keyword">in</span> <span class="keyword">for</span> Person</span><br><span class="line"></span><br><span class="line"><span class="comment">## instance.method(arg1,arg2,...) == class.method(instance,arg1,arg2,...)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用超类的构造函数<code>__init__</code>方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call person init ....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()               <span class="comment">## 创建子类时会调用父类构造函数,原因是子类没有定义自己的构造函数</span></span><br><span class="line">call person init ....</span><br><span class="line"></span><br><span class="line"><span class="comment">## 为子类增加构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call student init ....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()               <span class="comment">## 只输出子类的__init__方法,并没有调用父类方法,原因在于python是根据命名空间来执行调用方法</span></span><br><span class="line">call student init ....</span><br><span class="line"></span><br><span class="line"><span class="comment">## 若要调用父类构造方法则必须显示进行调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        必须在子类构造函数中显式调用父类的构造函数,并传递子类的self引用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call student init start....&quot;</span>)</span><br><span class="line">		Person.__init__(self)              </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call student init end....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()               </span><br><span class="line">call student init start....</span><br><span class="line">call person init ....</span><br><span class="line">call student init end....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态方法</p>
</blockquote>
<ul>
<li>使用场景：<ul>
<li>目标：为所有类实例提供数据共享的类属性</li>
<li>执行：通过类名称访问类属性</li>
<li>优化：其一是使用OOP思想封装类属性而对外提供方法,其二是考虑扩展性,通过继承来定制</li>
<li>落地：使用静态方法或者类方法,即不需要传递类对象self实例参数的方法</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## person.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	num = <span class="number">1</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义一个没有带参数的普通方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">printNum</span>():</span></span><br><span class="line">		Person.num += <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;the number is %s&quot;</span> % Person.num)</span><br><span class="line">	</span><br><span class="line">	printNum = <span class="built_in">staticmethod</span>(printNum)                   <span class="comment">## 声明为静态方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义一个带参数的普通方法,此参数为类对象参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">clsPrintNum</span>(<span class="params">cls</span>):</span></span><br><span class="line">		Person.num += <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;the number is %s&quot;</span> % Person.num)         </span><br><span class="line"></span><br><span class="line">	clsPrintNum = <span class="built_in">classmethod</span>(clsPrintNum)              <span class="comment">## 声明为类方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.printNum()</span><br><span class="line">the number <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.clsPrintNum()</span><br><span class="line">the number <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## person.py 使用装饰器来声明静态或类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	num = <span class="number">1</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">printNum</span>():</span></span><br><span class="line">		Person.num += <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;the number is %s&quot;</span> % Person.num)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">clsPrintNum</span>(<span class="params">cls</span>):</span></span><br><span class="line">		Person.num += <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;the number is %s&quot;</span> % Person.num)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态方法、类方法与实例方法</p>
</blockquote>
<ul>
<li>类中带有实例对象self的参数传递的方法称为实例方法</li>
<li>类中带有类对象cls的参数传递的方法并通过函数classmethod或者装饰器@classmethod声明的方法称为类方法</li>
<li>类中没有实例对象self和类对象cls参数传递的方法，且通过staticmethod或装饰器@staticmethod什么的方法称为静态方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">static_method</span>():</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;static method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;class method ....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">instance_method</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;instance method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		python3.x可以调用下面的函数，可以说是静态方法,但严格意义上是属于类的一个行为方法，但是python2.x无法该方法</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;just a fn,if py3.x,it is static method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 总结:</span></span><br><span class="line"><span class="number">1</span>)在类中定义方法一定要规范化,明确是静态方法还是类方法抑或是实例方法</span><br><span class="line"><span class="number">2</span>)避免使用最后一种方式在类中定义方法</span><br></pre></td></tr></table></figure>

<p>3.命名空间与作用域</p>
<ul>
<li>命名空间：用于记录变量的轨迹,key是变量名称,value是变量值,作用就是根据变量名称搜索变量<ul>
<li>使用无点号运算的变量名称(X),将根据LEGB(local/enclosing/global/builtin)作用域查找法则来搜索变量</li>
<li>使用点号的属性名称(object.x)使用的是对象命名空间来搜索变量（对象：类的实例对象和类对象）</li>
<li>有些作用域会对对象的命名空间进行初始化(模块和类)</li>
</ul>
</li>
</ul>
<blockquote>
<p>无点号运算的变量名称</p>
</blockquote>
<ul>
<li>赋值语句:在当前作用域创建或更改变量X,除非声明为全局变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="string">&quot;global X&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enclosing_fn</span>():</span></span><br><span class="line">    <span class="comment">## global X             </span></span><br><span class="line">    X = <span class="string">&quot;enclosing fn&quot;</span>      <span class="comment">## 创建当前enclosing_fn的本地变量X如果没有声明为全局变量的话</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用:根据LEGB作用域法则来搜索变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="string">&quot;global X&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enclosing_fn</span>():</span></span><br><span class="line">    X = <span class="string">&quot;enclosing fn&quot;</span>      <span class="comment">## 如果注释此行,将打印全局的变量X</span></span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">local_x</span>()</span></span><br><span class="line"><span class="function">        <span class="title">x</span> = &quot;<span class="title">local</span> <span class="title">x</span>&quot;       ## 如果仅注释此行,将会打印嵌套的变量<span class="title">X</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    <span class="title">local_x</span>()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>点号的属性变量名称</p>
</blockquote>
<ul>
<li>赋值语句:在对应的对象命名空间中创建或修改属性名称X,即object.X = value</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在对象实例的命名空间创建或更改属性名称name</span></span><br><span class="line">p.name = <span class="string">&quot;keithl&quot;</span>       <span class="comment">## 并无进行变量名称的搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在类的命名空间中创建或更改属性名称name</span></span><br><span class="line">Person.name = <span class="string">&quot;keithl&quot;</span>  <span class="comment">## 并无进行变量名称的搜索</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用<ul>
<li>基于类的对象引用：会在对象内搜索属性名称X,若没有找到则根据继承搜索来查找</li>
<li>基于模块对象的引用：先导入模块,再从模块中读取X</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.name          <span class="comment">## 从对象命名空间开始按照继承树来搜索</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.name     <span class="comment">## 从类的命名空间开始按照继承树来搜索</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命名空间字典</p>
</blockquote>
<ul>
<li>模块的命名空间是以字典的形式实现的，并且可以由属性<code>__dict__</code>来显示</li>
<li>类和对象可以看成一个带有链接的字典,属性点号就是字典索引运算,属性继承就是搜索链接的字典<ul>
<li>实例与类通过<code>__class__</code>属性链接</li>
<li>类与超类通过<code>__bases__</code>属性链接,可以通过递归往上遍历超类</li>
</ul>
</li>
<li>都可以通过<code>__dict__</code>查看模块、类或者对象的属性信息</li>
</ul>
<blockquote>
<p>类与模块的关系总结</p>
</blockquote>
<ul>
<li><p>类</p>
<ul>
<li>调用类会创建新的对象</li>
<li>由class来创建类对象</li>
<li>通过调用来使用</li>
<li>属于模块的一部分</li>
</ul>
</li>
<li><p>模块</p>
<ul>
<li>是数据和逻辑包</li>
<li>通过py抑或其他语言来扩展</li>
<li>必须导入才能使用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之OOP编程</title>
    <url>/2018/04/12/class_oop/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h5><blockquote>
<p>python类</p>
</blockquote>
<ul>
<li>继承：继承顶层类的通用属性，并且在通用情况下实现一次，目的是提高代码重用性</li>
<li>组合：由多个组件对象组合而成，通过多个对象来协作完成相应指令，每个组件都可以写成类来定义自己的属性和行为</li>
<li>与模块的区别：内存中模块只有一个实例，只能通过重载以获取其最新的代码，而类有多个实例</li>
</ul>
<blockquote>
<p>python类具体特征</p>
</blockquote>
<ul>
<li>多重实例<ul>
<li>类是产生对象实例的工厂</li>
<li>每调用一次类，便会产生独立命名空间的新对象</li>
<li>每个对象存储的数据是不一样</li>
</ul>
</li>
<li>通过继承进行定制<ul>
<li>在类的外部重新定义其属性</li>
<li>建立命名空间的层次结构来定义类创建的对象所使用的变量名称</li>
</ul>
</li>
<li>运算符重载<ul>
<li>根据提供特定的协议方法，可以定义对象来响应在内置类型上的几种运算</li>
</ul>
</li>
</ul>
<blockquote>
<p>python多重实例</p>
</blockquote>
<ul>
<li>s1:定义类模板和创建实例对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## person.py</span></span><br><span class="line"><span class="comment">## 定义类模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="comment">## python函数中在默认第一个有参数之后的任何参数都必须拥有默认值</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="string">&quot;the name[%s] - the job[%s] - the pay[%d]&quot;</span> % (self.name,self.job,self.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建实例并测试</span></span><br><span class="line">tom = Person(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">jack = Person(<span class="string">&quot;jack&quot;</span>,job=<span class="string">&quot;market&quot;</span>,pay=<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(tom)</span><br><span class="line"><span class="built_in">print</span>(jack)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python person.py</span><br><span class="line">the name[tom] - the job[<span class="literal">None</span>] - the pay[<span class="number">0</span>]</span><br><span class="line">the name[jack] - the job[market] - the pay[<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结：</span></span><br><span class="line"><span class="number">1</span>）创建实例的时候使用了默认值参数以及关键字参数</span><br><span class="line"><span class="number">2</span>）tom和jack从技术的角度而言是属于不同的对象命名空间，都拥有类创建的独立副本</span><br><span class="line"><span class="number">3</span>）不足在要导入其他的python文件也会把<span class="built_in">print</span>的信息也输出</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更改存放测试代码的位置，在文件底部添加如下代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tom = Person(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    jack = Person(<span class="string">&quot;jack&quot;</span>,job=<span class="string">&quot;market&quot;</span>,pay=<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(toml)</span><br><span class="line">    <span class="built_in">print</span>(jackl)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python person.py</span><br><span class="line">the name[toml] - the job[<span class="literal">None</span>] - the pay[<span class="number">0</span>]</span><br><span class="line">the name[jackl] - the job[market] - the pay[<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> person</span><br><span class="line"><span class="comment">## 没有任何输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li>s2:添加行为方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## python OOP编程也应当遵循封装的特性，即细节隐藏，外部访问方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 非OOP的方式获取last name</span></span><br><span class="line"><span class="built_in">print</span>(jack.name.split()[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## OOP的准则为添加方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 外部调用</span></span><br><span class="line"><span class="built_in">print</span>(jack.getLastName()</span><br></pre></td></tr></table></figure>

<ul>
<li>s3:运算符重载</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 上述测试实例对象每次都需要去调用相应的属性名称打印显示出来，重写__str__方法来显示一个对象属性的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">list</span> = []</span><br><span class="line">		<span class="keyword">for</span> k,v <span class="keyword">in</span> self.__dict__.items():       <span class="comment">## 通过动态获取实例对象的属性信息,而不是直接将属性名以及值直接硬编码</span></span><br><span class="line">			<span class="built_in">list</span>.append(<span class="string">&quot;%s -- %s&quot;</span> % (k,v))</span><br><span class="line">		<span class="built_in">str</span> =  <span class="string">&quot;,&quot;</span>.join(<span class="built_in">list</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person[%s]&quot;</span> % <span class="built_in">str</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">## 上述打印出所有的对象属性信息出来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tom)</span><br><span class="line">Person[pay -- <span class="number">0</span>,name -- tom,job -- <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>s4:通过子类定制行为</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 扩展父类的方法，而不是去重写或者修改父类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span>(<span class="params">self,percent</span>):</span></span><br><span class="line">        self.pay = self.pay * (<span class="number">1</span> + percent)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>(<span class="params">Person</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span>(<span class="params">self,percent,bouns=<span class="number">.10</span></span>):</span></span><br><span class="line">        <span class="comment">## 调用类的方法并传递self参数,这里不能用self,self本身指当前类实例对象本身，会导致循环引用而内存耗尽</span></span><br><span class="line">        Person.giveRaise(self,percent + bouns)      </span><br><span class="line">    </span><br><span class="line"><span class="comment">## 对于python调用父类方法，一般是通过类.方法(self,parameters)来显示调用，像其他编程语言，如java调用父类是通过super.方法来显示调用，这是区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 多态</span></span><br><span class="line">p1 = Person(<span class="string">&quot;p1&quot;</span>,job=<span class="string">&quot;dev&quot;</span>,pay=<span class="number">11000</span>)</span><br><span class="line">p2 = Manager(<span class="string">&quot;p2&quot;</span>,job=<span class="string">&quot;dev&quot;</span>,pay=<span class="number">11000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p1.giveRaise(<span class="number">.10</span>))        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p2.giveRaise(<span class="number">.10</span>))</span><br><span class="line">Person[name -- p1,job -- dev,pay -- <span class="number">12100.000000000002</span>]</span><br><span class="line">Person[name -- p2,job -- dev,pay -- <span class="number">13200.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结：</span></span><br><span class="line"><span class="number">1</span>）python的多态和其他编程语言略有差异，只要方法名称一样便会覆盖顶层类相应的方法，不管参数个数还是参数类型</span><br><span class="line"><span class="number">2</span>）原因在于python的属性以及行为是根据搜索树来遍历获取最近的属性或者方法</span><br><span class="line"><span class="number">3</span>）python参数类型是在赋值的时候才知道的，没有预先定义的类型</span><br></pre></td></tr></table></figure>

<ul>
<li>s5:定制构造函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定制Manager类，使其特殊化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,pay = <span class="number">0</span></span>):</span></span><br><span class="line">	    Person.__init__(self,name,job = <span class="string">&quot;manager&quot;</span>,pay = pay)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tom = Manager(<span class="string">&quot;tomk&quot;</span>,pay=<span class="number">11000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tom)</span><br><span class="line">Person[pay -- <span class="number">13200.0</span>,name -- tomk,job -- manager]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>s6:使用内省工具(类似其他编程语言的”反射”)</p>
<ul>
<li>问题描述1：Manager打印显示的信息是Person，然后实际中应当是显示Manager的信息</li>
<li>问题描述2：Manager如果在__init__增加属性，如果是硬编码的话则通过打印出来的信息就无法显示新的属性信息</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 问题1的解决方案：</span></span><br><span class="line">实例对象到创建它的类的链接通过instance.__class__属性</span><br><span class="line">反过来,可以通过一个__name__或者是__bases__序列提供超类的访问    </span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;p1&quot;</span>,job=<span class="string">&quot;dev&quot;</span>,pay=<span class="number">11000</span>)</span><br><span class="line">p2 = Manager(<span class="string">&quot;p2&quot;</span>,pay=<span class="number">11000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p1.__class__.__name__)</span><br><span class="line">Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p1.__class__.__bases__)</span><br><span class="line">(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">object</span>&#x27;&gt;,)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">p2.__class__.__name__</span>)</span></span><br><span class="line"><span class="class"><span class="title">Manager</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">p2.__class__.__bases__</span>)</span></span><br><span class="line"><span class="class">(<span class="params">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person&#x27;</span>&gt;,</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## 问题2的解决方案：</span></span><br><span class="line"><span class="class">通过内置的<span class="title">object</span>.<span class="title">__dict__</span>字典来显示实例对象的所有属性信息</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## 在上述<span class="title">person</span>已经使用<span class="title">__dict__</span>属性来显示实例属性信息</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">p1</span>)</span></span><br><span class="line"><span class="class"><span class="title">Person</span>[<span class="title">job</span> -- <span class="title">dev</span>,<span class="title">name</span> -- <span class="title">p1</span>,<span class="title">pay</span> -- 11000]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## 新增加对象属性</span></span><br><span class="line"><span class="class"><span class="title">p1</span>.<span class="title">age</span> = 10            </span></span><br><span class="line"><span class="class"><span class="title">p1</span>.<span class="title">hobby</span> = &quot;<span class="title">maths</span>&quot;      </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">p1</span>)</span></span><br><span class="line"><span class="class"><span class="title">Person</span>[<span class="title">pay</span> -- 11000,<span class="title">hobby</span> -- <span class="title">maths</span>,<span class="title">age</span> -- 10,<span class="title">job</span> -- <span class="title">dev</span>,<span class="title">name</span> -- <span class="title">p1</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## 将上述<span class="title">Person</span>改造成通用的工具显示</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_all_attrs</span>(<span class="params">self</span>):</span></span><br><span class="line">		attrs = []</span><br><span class="line">		<span class="keyword">for</span> key,value <span class="keyword">in</span> self.__dict__.items():</span><br><span class="line">			attrs.append(<span class="string">&quot;%s==%s&quot;</span> % (key,value))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(attrs)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;%s[%s]&quot;</span> % (self.__class__.__name__,self.get_all_attrs())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p1)</span><br><span class="line">Person[hobby==maths,name==p1,job==dev,pay==<span class="number">11000</span>,age==<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p2)</span><br><span class="line">Manager[name==p2,pay==<span class="number">11000</span>,job==manager]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 显示类和实例对象的所有属性使用dir方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 一份完整的OOP</span></span><br><span class="line">https://github.com/xiaokunliu/python-code/tree/master/01base/OOP</span><br></pre></td></tr></table></figure>

<ul>
<li>s7:对象持久化<ul>
<li>pickle:任意python对象和字节串之间的序列化</li>
<li>dbm:实现一个可通过键访问的文件系统，以存储字符串</li>
<li>shelve:使用上述两个模块把python对象存储到一个文件中，即按键存储pickle处理后的对象并存储在dbm的文件中</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## pickle</span><br><span class="line">## 将对象序列化到文件</span><br><span class="line">f1 = open(&quot;pickle.db&quot;,&quot;wb+&quot;)</span><br><span class="line">pickle.dump(p1,f1)  ## 这里不能一步到位，即open(&quot;pickle.db&quot;,&quot;wb+&quot;)，会导致pickle在读取的时候抛出EOFError: Ran out of input </span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">## 将对象序列化为字符串</span><br><span class="line">string = pickle.dumps(p1)</span><br><span class="line"></span><br><span class="line">## 从文件读取</span><br><span class="line">f = open(&quot;pickle.db&quot;,&quot;rb&quot;)</span><br><span class="line">p = pickle.load(f)</span><br><span class="line"></span><br><span class="line">## 从字符串读取</span><br><span class="line">p_obj = pickle.loads(string)</span><br><span class="line"></span><br><span class="line">## dbm</span><br><span class="line">## 存储</span><br><span class="line">db = dbm.open(&quot;dbm&quot;,&quot;c&quot;)</span><br><span class="line">db[k1] = v1</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line">## 读取</span><br><span class="line">db = dbm.open(&quot;dbm&quot;,&quot;c&quot;)</span><br><span class="line">for key in db.keys():</span><br><span class="line">    print(&quot;key[%s] -- %s&quot; % (key,db[key]))</span><br><span class="line"></span><br><span class="line">## shelve</span><br><span class="line">import shelve</span><br><span class="line">db = shelve.open(&quot;persondb&quot;)    ## filename</span><br><span class="line">for object in [p1,p2]:</span><br><span class="line">	db[object.name] = object</span><br><span class="line">db.close()  ## 必须关闭</span><br><span class="line"></span><br><span class="line">## 从db文件中读取</span><br><span class="line">db = shelve.open(&quot;persondb&quot;)        ## db拥有和字典相同的方法，区别在于shelve需要打开和关闭操作</span><br><span class="line">for key in db.keys():</span><br><span class="line">	print(&quot;from db[%s]&quot; % db[key])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>python重载运算符</p>
</blockquote>
<ul>
<li>双下划线命名的方法(<code>__X__</code>)是特殊的钩子</li>
<li>当实例出现在内置运算时，这类方法会自动调用</li>
<li>类可覆盖多数内置类型的运算</li>
<li>运算符覆盖方法没有默认，而且也不需要</li>
<li>运算符可以让类与Python的对象模型项集成</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 重载类的内置方法，一般是应用于数学类对象的计算才需要重载运算符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverrideClass</span>(<span class="params">ClassObject</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">		self.data = data</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">return</span> OverrideClass(self.data + other)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;[OverrideClass.data[%s]]&quot;</span> % self.data</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">self,other</span>):</span></span><br><span class="line">		self.data *= other</span><br><span class="line">		</span><br><span class="line"><span class="comment">## 调用</span></span><br><span class="line">t = OverrideClass(<span class="string">&quot;9090&quot;</span>)     <span class="comment">## 调用__init__方法</span></span><br><span class="line">t2 = t+<span class="string">&quot;234&quot;</span>                  <span class="comment">## 调用__add__方法，这个产生了新的对象</span></span><br><span class="line"><span class="built_in">print</span> t2                      <span class="comment">## 调用__str__方法</span></span><br><span class="line"></span><br><span class="line">t2.mul(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t2.data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>python属性继承搜索,object.attribute</p>
</blockquote>
<ul>
<li>找出attribute首次出现的实例对象</li>
<li>然后是该对象之上的所有类带有<code>__init__</code>方法中定义的属性查找attribute，由下至上，由左至右，属于继承搜索树</li>
<li>最后是定义该对象的类属性,查找方式也是由下至上，由左至右的遍历搜索</li>
</ul>
<blockquote>
<p>编写类树</p>
</blockquote>
<ul>
<li>每个class语句生成一个新的类对象</li>
<li>每次类调用，就会生成一个新的实例对象</li>
<li>实例对象自动连接到创建该实例对象的类</li>
<li>类连接至超类的方式，将超类列在类的头部括号中，其从左至右的顺序会决定树中的次序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M1</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>     <span class="comment">## 相当于构造器</span></span><br><span class="line">		self.name = <span class="string">&quot;m1 name&quot;</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;M1 class&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M2</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.name = <span class="string">&quot;m2 name&quot;</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;M2 class&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M3</span>(<span class="params">M1,M2</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M4</span>(<span class="params">M2,M1</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索树：M3 M1 M2,在多重继承中，以括号从左到右的次序会决定超类搜索的顺序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = M3()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a.name) </span><br><span class="line">M1 <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">m1</span> <span class="title">name</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#搜索树：<span class="title">M4</span> <span class="title">M2</span> <span class="title">M1</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">b</span> = <span class="title">M4</span>()</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">b.name</span>)</span></span><br><span class="line"><span class="class"><span class="title">M2</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">m2</span> <span class="title">name</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## <span class="title">a</span>.<span class="title">name</span>属性的查找</span></span><br><span class="line"><span class="class">1.先查找当前实例对象的属性,定义对象属性是在一个特殊方法<span class="title">__init__</span>定义,</span></span><br><span class="line"><span class="class">1.1因此会从<span class="title">M3</span> -&gt; M1 -&gt; M2的搜索树中查找最近定义的__init__方法</span></span><br><span class="line"><span class="class">1.2 如果__init__方法中有定义属性name则返回,否则进行下一步查找</span></span><br><span class="line"><span class="class">2.如果在对象属性中没有找到,则会从类的搜索树中查找属性值，即M3 -&gt; M1 -&gt; M2中查找</span></span><br><span class="line"><span class="class">2.1若找不到则抛出异常</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>python OOP总结</p>
</blockquote>
<ul>
<li>实例创建 – 填充实例的属性</li>
<li>行为方法 – 在类方法中封装逻辑</li>
<li>运算符重载 – 为外部调用的程序提供自身内置方法的定制化行为</li>
<li>定制行为  – 重新定义子类方法以使其特殊化</li>
<li>定制构造函数 –  为子类添加构造逻辑特殊化</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python装饰器小结</title>
    <url>/2019/12/31/decorator/</url>
    <content><![CDATA[<span id="more"></span>

<p>主要有以下几点：</p>
<ul>
<li>装饰器定义与作用</li>
<li>函数装饰器</li>
<li>类装饰器</li>
<li>装饰器的嵌套</li>
<li>带参数的装饰器</li>
<li>装饰器是如何管理函数和类</li>
</ul>
<h5 id="装饰器定义与作用"><a href="#装饰器定义与作用" class="headerlink" title="装饰器定义与作用"></a>装饰器定义与作用</h5><blockquote>
<p>定义</p>
</blockquote>
<ul>
<li>在定义的函数或者类的方法或者类使用<code>@</code>的修饰符修饰,<code>@</code>后面可以是一个函数或者是一个类</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<ul>
<li>可以理解为对原函数对象或者类对象进行代理或者包装，增强原有的函数和类功能</li>
<li>能够管理函数对象和函数调用，也能够管理定义类对象的类本身和实例对象</li>
</ul>
<h5 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h5><p>函数装饰器：函数实际被调用的时候会直接返回一个由函数装饰器包装好的函数对象进行回调,可以修饰在函数或定义的类方法</p>
<blockquote>
<p>编写基本的函数装饰器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_fn</span>(<span class="params">call_fn</span>):</span></span><br><span class="line">    <span class="keyword">if</span> auth():</span><br><span class="line">        <span class="string">u&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果是授权成功则直接调用函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> call_fn</span><br><span class="line">    <span class="comment"># 没有权限，不执行函数，返回一个包装None的可调用对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callable</span>(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_fn</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_fn</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;call fn ...&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上述的call_fn对象等价于</span></span><br><span class="line"></span><br><span class="line">call_fn = decorator_fn(call_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后再根据参数进行调用</span></span><br><span class="line">call_fn()   <span class="comment"># 此时该函数已增加授权校验功能</span></span><br></pre></td></tr></table></figure>

<h5 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h5><p>类装饰器：类实际被调用的时候会直接返回一个由函数装饰器包装好的类进行回调,让该类具有某种属性或行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">aClass</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;intercept ....&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> aClass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意上述使用装饰器修饰的Person已经是调用装饰器函数并返回Person对象，</span></span><br><span class="line"><span class="comment"># 即定义类的时候已经拥有装饰器的功能，因此不论如何调用Person()创建实例，</span></span><br><span class="line"><span class="comment"># 上面仅会打印一次intercept</span></span><br><span class="line"></span><br><span class="line">Person()分两步：</span><br><span class="line">其一，Person = decorator(Person) ，<span class="comment"># 执行包装的intercept然后返回原Person类</span></span><br><span class="line">其二，利用装饰器返回的Person类再创建对象</span><br></pre></td></tr></table></figure>

<h5 id="嵌套的装饰器"><a href="#嵌套的装饰器" class="headerlink" title="嵌套的装饰器"></a>嵌套的装饰器</h5><blockquote>
<p>函数装饰器嵌套</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@fn1</span></span><br><span class="line"><span class="meta">@fn2</span></span><br><span class="line"><span class="meta">@fn3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># fn对象等价于</span></span><br><span class="line"></span><br><span class="line">fn = fn1(fn2(fn3(fn)))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类装饰器嵌套</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@fn1</span></span><br><span class="line"><span class="meta">@fn2</span></span><br><span class="line"><span class="meta">@fn3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上述定义的类Person已经是具有fn1,fn2,fn3的所有装饰器功能</span></span><br><span class="line">Person = fn1(fn2(fn3(Person)))</span><br></pre></td></tr></table></figure>

<h5 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a><code>带参数</code>的装饰器</h5><blockquote>
<p>修饰带有参数的函数的装饰器,这时候装饰器的作用就是返回一个函数的代理</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proxy</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">u&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        作为代理函数来调用原有的函数，并对原来的函数进行auth的校验</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;auth checking&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">a=<span class="number">9</span>, b=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上述的被装饰器修饰的fn等价于proxy，在函数proxy中已经保存了fn函数的对象</span></span><br><span class="line">因此调用fn()就等价于调用proxy(),而proxy()函数增加了auth认证校验，即</span><br><span class="line">fn(*args, **kwargs) =  decorator(fn)(*args, **kwargs),再进一步拆分，即</span><br><span class="line">fn = decorator(fn)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修饰带有参数初始化类的装饰器</p>
</blockquote>
<ul>
<li>定义一个装饰器函数并传递类对象</li>
<li>在定义的装饰器函数内部定义一个代理函数对象，此代理函数对象与原函数传递的参数一致，并负责处理日志，认证等工作，最后返回一个类对象</li>
<li>此时使用装饰器修饰类必须重载运算符<code>__call__</code>保证可被动态调用（类似与反射创建类对象）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">aClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proxy</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">u&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        作为代理函数来调用原有的函数，并对原来的函数进行auth的校验</span></span><br><span class="line"><span class="string">        :param args:</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;auth checking&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> aClass(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;person ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意体会与上述定义类装饰器的区别,这个时候定义的Person并非Person类，</span></span><br><span class="line">而是一个定义在decorator函数内部的一个代理函数，这个代理函数保存了aClass这个类对象</span><br><span class="line">Person(*args, **kwargs) = decorator(Person)(*args, **kwargs)，进一步拆分，即</span><br><span class="line">Person = decorator(Person)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义的装饰器函数传递参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">cache_time, strategy</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">actual_decorator</span>(<span class="params">fn</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;using cache_time[%s] and strategy[%s] do the first job&quot;</span> % (cache_time, strategy))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">proxy</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;before call must be do the second job..&quot;</span>)</span><br><span class="line">            fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> proxy</span><br><span class="line">    <span class="keyword">return</span> actual_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator(<span class="params">cache_time=<span class="number">10</span>, strategy=<span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_fn</span>(<span class="params">a, b=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; b:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a &lt; b&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> a &gt; b:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a &gt; b&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a = b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用上述的装饰器修饰的call_fn等价于</span></span><br><span class="line"><span class="comment"># call_fn = decorator(cache_time=10, strategy=&quot;&quot;)(call_fn) # 调用了两次函数,最终返回代理proxy</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @decorator(<span class="params">cache_time=<span class="number">10</span>, strategy=<span class="string">&quot;nio&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">self,a, b=<span class="number">10</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> a &lt; b:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;a &lt; b&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> a &gt; b:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;a &gt; b&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;a = b&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 同理，定义的cal函数等价于</span></span><br><span class="line">cal = decorator(cache_time=<span class="number">10</span>, strategy=<span class="string">&quot;nio&quot;</span>)(cal)   <span class="comment"># 调用了两次函数并返回代理函数</span></span><br></pre></td></tr></table></figure>

<h5 id="利用装饰器有效地管理函数和类"><a href="#利用装饰器有效地管理函数和类" class="headerlink" title="利用装饰器有效地管理函数和类"></a>利用装饰器有效地管理函数和类</h5><p>使用装饰器要分清楚以下几点：</p>
<ul>
<li>使用装饰器修饰的函数或者类主要应用场景是什么,是直接返回原函数(类)还是嵌套定义的代理函数对象</li>
<li>如果是直接返回园函数或者是类，那么可以保证修饰前后的数据属性是一致的，并且能够获取原数据的属性信息</li>
<li>如果返回的是一个包装原函数或者类的代理函数对象，那么此时数据属性便发生改变，这种情况下只适用于调用的方式而非使用元数据进行下一步业务操作</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python异常定义与原理</title>
    <url>/2018/12/31/exception/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="异常在程序中的作用"><a href="#异常在程序中的作用" class="headerlink" title="异常在程序中的作用"></a>异常在程序中的作用</h5><ul>
<li>Error Handling:能够在异常处理语句中捕获并响应错误信息</li>
<li>Event Notification:即当我们应用程序在传入数据并进行数据处理过程中，针对不合法的事件我们是采取抛出异常而不是返回一个表示不合法的数据结果</li>
<li>Special-case handling：在异常处理器处理程序个别极端情况，可以通过assert来检查条件是否如我们的预期值一样</li>
<li>Termination actions:即保证程序中的资源能够在异常发生之后正常关闭</li>
<li>Unusual control flows:不正常的控制流，使用raise抛出异常信息</li>
</ul>
<h5 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h5><blockquote>
<p>默认异常处理器,即由python自动搜索匹配对应的异常信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python命令行,默认是3.6,以下没有特殊说明全部是基于这个版本</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>=<span class="string">&quot;keithl&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">10</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>捕获异常信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_index</span>():</span></span><br><span class="line">	<span class="built_in">str</span>=<span class="string">&quot;keithl&quot;</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">10</span>])</span><br><span class="line">		<span class="comment"># print(str[2])</span></span><br><span class="line">	<span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">		<span class="built_in">print</span>(e)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;try正常执行，没有异常发生...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    catch_index()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMjEwNzU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMjIyNDM4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>抛出异常,使用raise</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raise_index</span>():</span></span><br><span class="line">	<span class="built_in">str</span> = <span class="string">&quot;keithl&quot;</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">10</span>])</span><br><span class="line">	<span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">		<span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    raise_index()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMjQ2NDU1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>自定义异常</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;my exception object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_exception</span>():</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">raise</span> MyException</span><br><span class="line">	<span class="keyword">except</span> MyException <span class="keyword">as</span> e:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;get my exception error[%s]&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    define_exception()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMjU5ODE4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>使用finally终止try语句</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raise_index_finally</span>():</span></span><br><span class="line">	<span class="built_in">str</span> = <span class="string">&quot;keithl&quot;</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">10</span>])</span><br><span class="line">	<span class="keyword">except</span> IndexError:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;except index error&quot;</span>)</span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;try statement to close resource ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	raise_index_finally()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMzEzMDEz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h5 id="异常语句"><a href="#异常语句" class="headerlink" title="异常语句"></a>异常语句</h5><blockquote>
<p>try/except/else语句</p>
</blockquote>
<ul>
<li>语句块的定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;程序业务逻辑.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> name1:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;捕获异常name1..&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (name2, name3):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;捕获异常name2 或 name3..&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> name4 <span class="keyword">as</span> var:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;捕获异常name4,并传递其引用变量到语句块中..&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:         <span class="comment"># 5      </span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;捕获所有异常(上述的name1,name2,name3,name4除外..)&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;没有异常,try语句正常执行..&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try/except/else工作原理</p>
<ul>
<li>当在try语句块中发生异常时,异常类型将会匹配except对应的name,然后根据对应的name分配对应的异常类对象,执行statement中的语句</li>
<li>当在try语句块中发生异常但没有在except中匹配到对应的name,python将会查询其他的异常直至进程最高级别的异常并退出程序,打印出默认的异常信息</li>
<li>如果try语句正常执行,那么最后也将会执行else语句</li>
</ul>
</li>
<li><p>捕获任意或所有异常</p>
<ul>
<li>使用<code>except:</code>,即后面没有携带任何异常类,将会捕获先前没有定义的异常类</li>
<li>使用<code>except (e1,e2,..)</code>,即只要业务代码中抛出的异常是在定义的一系列异常列表中(e1,e2,..),那么就会在except语句中被捕获处理</li>
</ul>
</li>
<li><p><code>except:</code>与<code>except Exception:</code></p>
<ul>
<li><code>except:</code>是捕获所有的异常,但存在不足,一是捕获和业务代码无关的系统错误,二是会拦截其他程序的异常处理</li>
<li><code>except Exception:</code>:py3.x建议使用这个Exception类,同时可以避免上述问题,Exception会忽略与系统操作相关的异常,如系统退出py时报出的异常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="comment"># `except:`执行遇到系统退出的时候会捕获异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_exception</span>():</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">			<span class="built_in">print</span>(i)</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">				sys.exit(-<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;直接使用空的异常来捕获&quot;</span>)</span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_exception()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python exception.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMzMyNjc1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `except Exception:`在系统退出的时候没有捕获异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_exception</span>():</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">			<span class="built_in">print</span>(i)</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">				sys.exit(-<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">except</span> Exception:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;直接使用空的异常来捕获&quot;</span>)</span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_exception()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python exception.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxMzQ0MjAy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>py2.x与py3.x的异常语句作用域<ul>
<li>py2.x可以支持<code>except Exception as e</code>以及<code>except Exception,e</code>,py3.x仅支持<code>except Exception as e</code></li>
<li>py2.x的异常语句Exception对应的实例变量e是全局变量，在try语句块外还可以直接访问</li>
<li>py3.x的异常语句Exception对应的实例变量e是局部变量，在try语句块外不能访问，但是可以保存在一个全局的变量中</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNDA2ODQw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNDE4NTMz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNDMwNTE2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNDQyNzky?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>try/finally语句</p>
</blockquote>
<ul>
<li>语句块定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行业务代码语句块...&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;关闭处理业务的资源...&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try/finally工作原理</p>
<ul>
<li>当try语句块中的业务逻辑是正常执行的时候，在程序退出返回的时候将会执行finally语句块</li>
<li>当try语句块中的业务逻辑出现异常的时候，仍然会执行finally语句块并将异常信息一并向顶层程序抛出</li>
</ul>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raise_exception</span>():</span></span><br><span class="line">	<span class="keyword">raise</span> MyException()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_try_finally</span>():</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		raise_exception()</span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;execute test_try_finally statement ...&quot;</span>)</span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_try_finally()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python exception.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNDU2MDc4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>try/except/finally语句</p>
</blockquote>
<ul>
<li>这个在上面的基础上添加一个异常处理块，其一般模板为</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;处理核心业务逻辑&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;捕获异常信息e1&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;捕获异常信息e2&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;try的业务语句没有异常，正常执行完毕后将执行else语句&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;关闭消耗CPU的资源&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>raise语句</p>
</blockquote>
<ul>
<li><p>raise instance:raise 语句抛出一个异常信息类型<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNTEwMzYw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p>raise class:raise 语句创建一个异常类class的实例并抛出异常信息<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNTIyNjU1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
</li>
<li><p>raise:将一个异常类class信息抛出并往顶层程序传播</p>
<ul>
<li><p>在一个try语句中发生的异常信息类会在except语句中按照顺序进行匹配</p>
</li>
<li><p>抛出的异常类是except定义的异常类的子类或本类，其他在except定义的异常类将不捕获异常</p>
</li>
<li><p>抛出的异常类如果是except定义的异常类的父类，也不会捕获到该父类的异常</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNTQ1ODcx?x-oss-process=image/format,png" alt="这里写图片描述">    </p>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNTU4MTE0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNjEwNTQy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>仅py3.x支持的from语句</li>
</ul>
<p><code>raise newException from otherException</code><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNjIyODM4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">raise</span> MyException <span class="keyword">from</span> e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>assert语句</p>
</blockquote>
<ul>
<li>语法：<code>assert test,data        # data是可选的</code></li>
<li>工作原理如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">__debug__</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> test:</span><br><span class="line">        <span class="keyword">raise</span> AssertionError(data)</span><br></pre></td></tr></table></figure>

<ul>
<li>示例：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNjM0ODc5?x-oss-process=image/format,png" alt="这里写图片描述"></li>
</ul>
<blockquote>
<p>with/as上下文管理器</p>
</blockquote>
<ul>
<li>基本语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> variable]</span><br><span class="line">    <span class="keyword">with</span>-block</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表达式expression返回的是一个实现上下文管理器协议的对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景一：IO操作自动打开和关闭资源</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件filepath并且自动读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;filepath&quot;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<ul>
<li>场景二：应用在线程锁中，自动获取和释放锁</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在一个线程中对语句块进行锁操作</span></span><br><span class="line">lock = threading.Lock()     <span class="comment"># 导入threading模块</span></span><br><span class="line"><span class="keyword">with</span> lock:                  <span class="comment"># 在业务代码执行之前自动获取锁，在执行完成之后自动释放锁,除非有异常抛出</span></span><br><span class="line">    <span class="comment"># 执行相关的业务代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景三：在decimal模块中使用上下文管理来设置decimal操作业务数据的格式，退出后格式自动清除失效</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">with</span> decimal.localcontext() <span class="keyword">as</span> ctx: </span><br><span class="line">    ctx.prec = <span class="number">2</span>        <span class="comment"># 保留小数点后两位</span></span><br><span class="line">    x = decimal.Decimal(<span class="string">&#x27;5.00&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3.00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>with表达式语句的工作原理<ul>
<li>上下文管理器对象必须有实现内置操作符<code>__enter__</code>和<code>__exit__</code>方法</li>
<li>在with语句中返回一个对象管理器并分配一个变量的时候将会回调<code>__enter__</code>方法</li>
<li>执行嵌套的语句块，也就是上面的相关业务代码</li>
<li>当有异常信息抛出的时候，就会回调<code>__exit__</code>的方法,同时携带type,value,traceback三个参数(通过sys.exc_info获取到)</li>
<li>正常执行完成之后，也会回调<code>__exit__</code>的方法</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exception.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithContextObject</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">self,args</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;execute enter method ..&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">		<span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;execute normally...&quot;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;raise exception ...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_with</span>():</span></span><br><span class="line">	<span class="keyword">with</span> WithContextObject() <span class="keyword">as</span> context:</span><br><span class="line">		context.message(<span class="string">&quot;take message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_with()</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python exception.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI3MDkxNjUyODUz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>使用多个with上下文管理器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path1) <span class="keyword">as</span> reader,<span class="keyword">with</span> <span class="built_in">open</span>(file_path2) <span class="keyword">as</span> writer:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        writer.write(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path1) <span class="keyword">as</span> reader:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path2) <span class="keyword">as</span> writer:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">            writer.write(line)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python微服务设计</title>
    <url>/2018/03/12/mirco/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="Nameko-API-Swagger"><a href="#Nameko-API-Swagger" class="headerlink" title="Nameko + API Swagger"></a>Nameko + API Swagger</h5><h6 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 安装微服务框架</span></span><br><span class="line">pip install nameko==2.5.4.4</span><br><span class="line"><span class="comment">## 安装api框架</span></span><br><span class="line">pip install nameko-swagger==1.2.7</span><br><span class="line"><span class="comment">## 创建项目</span></span><br><span class="line">nameko-admin createproject demo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>项目目录结构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo/</span><br><span class="line">    .tox/   </span><br><span class="line">    bin/</span><br><span class="line">        run.sh</span><br><span class="line">    conf/</span><br><span class="line">        config.yaml</span><br><span class="line">    logs/</span><br><span class="line">    service/</span><br><span class="line">        demo.py</span><br><span class="line">    spec/</span><br><span class="line">        v1/</span><br><span class="line">            api.yaml</span><br><span class="line">    test/</span><br><span class="line">    ... ##</span><br></pre></td></tr></table></figure>

<h6 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/demo/health:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">获取服务健康状态</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">get_health</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/v1/demo/health&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_get_health</span>(<span class="params">self, request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>, msg=<span class="string">&#x27;&#x27;</span>, data=&#123;&#125;, time=<span class="built_in">int</span>(time.time()))</span><br></pre></td></tr></table></figure>

<h6 id="配置在路径path的作用域中"><a href="#配置在路径path的作用域中" class="headerlink" title="配置在路径path的作用域中"></a>配置在路径path的作用域中</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml添加path的路径参数配置</span></span><br><span class="line"><span class="string">/demo/path/index/&#123;uid&#125;:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在path中进行查询</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">index</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">uid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">path</span>        <span class="comment"># Note the name is the same as in the path</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户uid</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/v1/demo/path/index/&lt;int:uid&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_index</span>(<span class="params">self, request, uid</span>):</span></span><br><span class="line">    logger.info(request)</span><br><span class="line">    logger.info(uid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>, msg=<span class="string">&#x27;&#x27;</span>, data=&#123;<span class="string">r&quot;msg&quot;</span>: <span class="string">&quot;path index success...&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h6 id="配置在路径query作用域中"><a href="#配置在路径query作用域中" class="headerlink" title="配置在路径query作用域中"></a>配置在路径query作用域中</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="string">/demo/query/index:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在query中查询</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">query_index</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户频道Id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/v1/demo/query/index&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_index</span>(<span class="params">self, request, cid</span>):</span></span><br><span class="line">    logger.info(request)</span><br><span class="line">    logger.info(cid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">                msg=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                data=&#123;<span class="string">&quot;cid&quot;</span>: cid&#125;,</span><br><span class="line">                time=<span class="built_in">int</span>(time.time()))</span><br></pre></td></tr></table></figure>

<h6 id="配置在query中查询多个"><a href="#配置在query中查询多个" class="headerlink" title="配置在query中查询多个"></a>配置在query中查询多个</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="string">/demo/query/many:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在query中查询</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">query_many</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户频道Id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">uid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">channelid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/v1/demo/query/many&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_many</span>(<span class="params">self, request,</span></span></span><br><span class="line"><span class="params"><span class="function">               cid,</span></span></span><br><span class="line"><span class="params"><span class="function">               uid=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">               channelid=<span class="number">0</span></span>):</span></span><br><span class="line">    logger.info(request)</span><br><span class="line">    logger.info(cid)</span><br><span class="line">    logger.info(uid)</span><br><span class="line">    logger.info(channelid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">                msg=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                data=&#123;<span class="string">&quot;cid&quot;</span>: cid,</span><br><span class="line">                      <span class="string">&quot;uid&quot;</span>: uid,</span><br><span class="line">                      <span class="string">&quot;channelid&quot;</span>: channelid&#125;,</span><br><span class="line">                time=<span class="built_in">int</span>(time.time()))</span><br></pre></td></tr></table></figure>

<h6 id="在post的表单中查询"><a href="#在post的表单中查询" class="headerlink" title="在post的表单中查询"></a>在post的表单中查询</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="string">/demo/post:</span></span><br><span class="line">    <span class="attr">post:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在post的表单中查询</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">do_post</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">formData</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户频道Id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">uid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">formData</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">channelid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">formData</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/v1/demo/post&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_post</span>(<span class="params">self, request,</span></span></span><br><span class="line"><span class="params"><span class="function">               cid,</span></span></span><br><span class="line"><span class="params"><span class="function">               uid=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">               channelid=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    logger.info(request)</span><br><span class="line">    logger.info(cid)</span><br><span class="line">    logger.info(uid)</span><br><span class="line">    logger.info(channelid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">                msg=<span class="string">&#x27;do post message&#x27;</span>,</span><br><span class="line">                data=&#123;<span class="string">&quot;cid&quot;</span>: cid,</span><br><span class="line">                      <span class="string">&quot;uid&quot;</span>: uid,</span><br><span class="line">                      <span class="string">&quot;channelid&quot;</span>: channelid&#125;,</span><br><span class="line">                time=<span class="built_in">int</span>(time.time()*<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h6 id="配置在post中查询多个"><a href="#配置在post中查询多个" class="headerlink" title="配置在post中查询多个"></a>配置在post中查询多个</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="string">/demo/post/query:</span></span><br><span class="line">    <span class="attr">post:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在post的表单以及query的路径中查询</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">query_post</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户频道Id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">uid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">用户id</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">channelid</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">formData</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/v1/demo/post/query&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_post</span>(<span class="params">self, request,</span></span></span><br><span class="line"><span class="params"><span class="function">               cid,</span></span></span><br><span class="line"><span class="params"><span class="function">               uid=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">               channelid=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    logger.info(request)</span><br><span class="line">    logger.info(cid)</span><br><span class="line">    logger.info(uid)</span><br><span class="line">    logger.info(channelid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">                msg=<span class="string">&#x27;query post message&#x27;</span>,</span><br><span class="line">                data=&#123;<span class="string">&quot;cid&quot;</span>: cid,</span><br><span class="line">                      <span class="string">&quot;uid&quot;</span>: uid,</span><br><span class="line">                      <span class="string">&quot;channelid&quot;</span>: channelid&#125;,</span><br><span class="line">                time=<span class="built_in">int</span>(time.time() * <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h6 id="配置在body中"><a href="#配置在body中" class="headerlink" title="配置在body中"></a>配置在body中</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## api.yaml</span></span><br><span class="line"><span class="string">/demo/post/body:</span></span><br><span class="line">    <span class="attr">post:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">根据请求参数在body中查询</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">query_body</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">in:</span> <span class="string">body</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">jsonParameters</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/RequestJson&#x27;</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           返回结果：&#123;&quot;code&quot;: &quot;xxx&quot;, &quot;msg&quot;: &quot;xxx&quot;, &quot;data&quot;: &#123;&#125;, &quot;time&quot;: xxx, &quot;why&quot;: &quot;xxx&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="string">其中`code`字段可能返回的错误码包括：</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;OK&quot;</span> <span class="string">操作成功，结果见`data`字段</span></span><br><span class="line">            <span class="string">*</span> <span class="string">&quot;INTERNAL_SERVER_ERROR&quot;</span> <span class="string">内部错误，具体原因见`why`字段</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/definitions/HealthResponse&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义的requestJson格式</span></span><br><span class="line"><span class="attr">definitions:</span></span><br><span class="line">  <span class="attr">RequestJson:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">请求参数在body中的json格式</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">cid:</span></span><br><span class="line">         <span class="attr">description:</span> <span class="string">用户的cid</span></span><br><span class="line">         <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">      <span class="attr">uid:</span></span><br><span class="line">         <span class="attr">description:</span> <span class="string">用户的uid</span></span><br><span class="line">         <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">      <span class="attr">channelid:</span></span><br><span class="line">         <span class="attr">description:</span> <span class="string">频道Id</span></span><br><span class="line">         <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cid</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"><span class="meta">@swagger.unmarshal_request</span></span><br><span class="line"><span class="meta">@http(<span class="params"><span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/v1/demo/post/body&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_body</span>(<span class="params">self, request, jsonParameters</span>):</span></span><br><span class="line">    <span class="string">u&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    jsonParameters名称要和api.yaml上声明的name一致,请求的body的json格式为</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        cid:&quot;&quot;,</span></span><br><span class="line"><span class="string">        uid:&quot;&quot;,</span></span><br><span class="line"><span class="string">        channelid:&quot;&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ## 使用这种可以传递一个对象的json数据而避免使用过长的参数列表来进行request请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(code=<span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">                msg=<span class="string">&#x27;query post message&#x27;</span>,</span><br><span class="line">                data=jsonParameters,</span><br><span class="line">                time=<span class="built_in">int</span>(time.time() * <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python新式类</title>
    <url>/2018/04/01/new_style_class/</url>
    <content><![CDATA[<span id="more"></span>


<h4 id="python新式类模型"><a href="#python新式类模型" class="headerlink" title="python新式类模型"></a>python新式类模型</h4><ul>
<li>python3.x的所有类都会自动转换为一个”新式类”，不论是否有继承object对象</li>
<li>python2.x必须显式地指定类继承object父类才表示”新式类”</li>
</ul>
<h5 id="新式类与经典类模板"><a href="#新式类与经典类模板" class="headerlink" title="新式类与经典类模板"></a>新式类与经典类模板</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py3.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dtrees</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Dtrees默认是新式类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># py2.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dtrees</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    py2.x必须显式地继承object作为父类，此时才表示是新式类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dtrees</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Dtrees默认是经典类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h5 id="新式类的特征"><a href="#新式类的特征" class="headerlink" title="新式类的特征"></a>新式类的特征</h5><blockquote>
<p>定义经典类与新式类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py,python环境为2.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classic</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	python2.x默认类为经典类</span></span><br><span class="line"><span class="string">	由于__getatt__ 与 __getattribute__功能效果一样，这里只用__getattr__演示</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, method_name</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call Classic __getattr__,it would call built-in[%s] method &quot;</span> % method_name)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getattr</span>(self.__name,method_name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewStyleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.__name = <span class="string">&quot;newstyle name&quot;</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	python2.x需要指明为新式类，python3.x默认为新式类</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call NewStyle __getattr__,it would call built-in[%s] method &quot;</span> %item)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getattr</span>(self.__name,item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_dir</span>():</span></span><br><span class="line">    C = Classic()</span><br><span class="line">    N = NewStyleClass()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">dir</span>(C)        <span class="comment"># 经典类内置有__getattr__方法</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">dir</span>(N)        <span class="comment"># 新式类的内置方法继承object对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyMzQxMDMw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>新式类中的内置属性方法的获取将以类作为搜索起点，直接跳过类的实例搜索</p>
</blockquote>
<ul>
<li>在新式类中，路由指向<code>__getattr__</code>以及<code>__getattribute__</code>的类内置函数(<code>__X__</code>)直接跳过不再被拦截</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_classis</span>():</span></span><br><span class="line">	C = Classic()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;python2.x classic instance built-in attributes:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">str</span>(C))       <span class="comment"># 调用str()会执行内置函数__str__,但是会先被__getattr__方法拦截，然后再调用__str__</span></span><br><span class="line">	<span class="built_in">print</span>(C.__str__())  <span class="comment"># 执行的输出与上述结果一样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_new</span>():</span></span><br><span class="line">	N = NewStyleClass()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;python3.x classic instance built-in attributes:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">str</span>(N))               <span class="comment"># 调用str()会执行内置函数__str__，但是没有被__getattr__方法拦截</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(N).__str__(N))   <span class="comment"># 必须通过类的方式调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyMzU0NzIz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>经典类实例添加内置操作能够正常访问使用，新式类实例则不行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_builtin</span>():</span></span><br><span class="line">    C = Classic()</span><br><span class="line">	C.__add__ = <span class="keyword">lambda</span> x:x+<span class="number">2</span>    <span class="comment"># 为类实例添加内置属性方法</span></span><br><span class="line">	<span class="built_in">print</span>(C+<span class="number">2</span>)</span><br><span class="line">	</span><br><span class="line">	N = NewStyleClass()     </span><br><span class="line">	N.__add__ = <span class="keyword">lambda</span> x: x + <span class="number">2</span> </span><br><span class="line">	<span class="built_in">print</span>(N + <span class="number">2</span>)                <span class="comment"># unsupported operand type(s) for +: &#x27;NewStyleClass&#x27; and &#x27;int&#x27;,类中没有定义__add__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyNDA3Mjkx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>类模型的变更</p>
</blockquote>
<ul>
<li>classes are types,类都是type的一个实例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model_change</span>():</span></span><br><span class="line">	C = Classic()</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(C))</span><br><span class="line">	<span class="built_in">print</span>(C.__class__)</span><br><span class="line"></span><br><span class="line">	N = NewStyleClass()</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(N))</span><br><span class="line">	<span class="built_in">print</span>(N.__class__)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyNDE5ODgx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>types are classes，type都是类的一个实例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py </span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NClass</span>(<span class="params"><span class="built_in">object</span></span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model_change2</span>():</span></span><br><span class="line">	C1 = Classic()</span><br><span class="line">	C2 = D()</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(C1) == <span class="built_in">type</span>(C2))     <span class="comment"># 经典类中的所有实例都拥有相同的type</span></span><br><span class="line">	<span class="built_in">print</span>(C1.__class__ == C2.__class__)</span><br><span class="line"></span><br><span class="line">	N1 = NewStyleClass()</span><br><span class="line">	N2 = NClass()</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(N1) == <span class="built_in">type</span>(N2))     <span class="comment"># 新式类:type is class,class is type</span></span><br><span class="line">	<span class="built_in">print</span>(N1.__class__ == N2.__class__)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMDI5MzAx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>所有的类都继承object，object是处于顶级的基类</p>
</blockquote>
<ul>
<li>类实例对象的type是class，class的type是type，type的type是type</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_class</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;str class&quot;</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py	</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyNjI1OTQ3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>所有的新式类拥有来自基类object的属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_inherit</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(Classic.__bases__)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">dir</span>(Classic))</span><br><span class="line">	<span class="built_in">print</span>(NewStyleClass.__bases__)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">dir</span>(NewStyleClass))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py	</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMDQzMzEz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>继承树搜索在以同一个基类的基础下将以广度优先的方式进行遍历</p>
</blockquote>
<ul>
<li>拥有一个相同的顶层类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>(<span class="params"><span class="built_in">object</span></span>):</span>attr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A1</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A1</span>):</span>attr = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B,C</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_search</span>():</span></span><br><span class="line">	d = D()</span><br><span class="line">	<span class="built_in">print</span>(d.attr)       <span class="comment"># 经典类搜索：深度优先，即 D -- B --- A1 --- C，新式类：即D --- B --- C  --- A1</span></span><br><span class="line">	<span class="built_in">print</span>(D.__mro__)    <span class="comment"># 列出D的遍历搜索方式,只有在新式类中生效并且只有属于同一个类下的才会走广度优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A1是上述子类的基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_search()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py      <span class="comment"># 经典类 &amp; 新式类输出结果</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMDU1NDU2?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMTA2Mjgy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>顶层基类不是相同一个</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>(<span class="params"><span class="built_in">object</span></span>):</span>attr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>(<span class="params"><span class="built_in">object</span></span>):</span>attr = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A1</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A2</span>):</span>attr = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>(<span class="params">C</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B,T</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_search</span>():</span></span><br><span class="line">	d = D()</span><br><span class="line">	<span class="built_in">print</span>(d.attr)       </span><br><span class="line">	<span class="built_in">print</span>(D.__mro__)    </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle.py   经典类 &amp; 新式类输出结果</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMTIxNjg4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h5 id="新式类的扩展"><a href="#新式类的扩展" class="headerlink" title="新式类的扩展"></a>新式类的扩展</h5><blockquote>
<p>使用<code>__slots__</code>槽来存储实例对象的属性名称</p>
</blockquote>
<ul>
<li><p>1.定义：assigning a sequence of string attribute names,用一个序列存储字符串属性名称</p>
</li>
<li><p>2.作用：</p>
<ul>
<li>1)避免随意添加类的实例属性，只能通过槽指定的属性来做设置和访问</li>
<li>2)可以优化内存的使用和加快程序执行的速度 </li>
</ul>
</li>
<li><p>3.声明：</p>
<ul>
<li>1)通过内置属性<code>__slots__</code>变量来定义</li>
<li>2)必须定义在类顶部的语句中</li>
</ul>
</li>
<li><p>4.注意点：</p>
<ul>
<li>必须为槽定义的属性名称进行分配值，如果没有分配而进行访问将会报错，即AttributeError</li>
</ul>
</li>
<li><p>5.代码测试</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle_extend.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	定义属性槽，类实例只能使用下面的属性来进设置和访问，试图设置或者访问不在槽定义的会报错</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	__slots__ = [<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_slots</span>():</span></span><br><span class="line">	obj = MyObject()</span><br><span class="line">	<span class="comment"># print(obj.age)      # 未分配但尝试访问报错</span></span><br><span class="line">	obj.age = <span class="number">10</span></span><br><span class="line">	<span class="built_in">print</span>(obj.age)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># obj.hobby = u&quot;不存在槽中的属性将报错&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle_extend.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMTM3ODg2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMTUwNzYy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMjA2ODU1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>6.槽与命名空间字典<ul>
<li><code>__slots__</code>会排除实例字典属性，除非字典属性会显式地定义在槽中</li>
<li>一旦我们需要定义槽以外的属性存储在命名空间字典的时候，需要在槽里面添加一个属性,即<code>__dict__</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle_extend.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	定义属性槽，类实例只能使用下面的属性来进设置和访问，试图设置或者访问不在槽定义的会报错</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	__slots__ = [<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_slots</span>():</span></span><br><span class="line">	obj = MyObject()</span><br><span class="line">	obj.hobby = <span class="string">u&quot;不存在槽中的hobby属性将存储在命名空间字典中&quot;</span></span><br><span class="line">	<span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle_extend.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMjIwOTEz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>7.在继承树中使用槽,子类将继承父类的槽属性取并集操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># newstyle_extend.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__slots__ = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__slots__ = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>(<span class="params">E</span>):</span></span><br><span class="line">	__slots__ = [<span class="string">&#x27;xx&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]      <span class="comment"># 子类使用槽的时候，只能继承一个父类，否则报multiple bases have instance lay-out conflict</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_inherhit_class</span>():</span></span><br><span class="line">	m = M()</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">dir</span>(m))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python newstyle_extend.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMjM0MTM5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzMjQ1Mzk3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>属性访问器</p>
</blockquote>
<ul>
<li>使用property函数来获取属性，其格式为：property(get,set,del,doc),即包含了获取、设置、删除以及文档属性的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyObject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call get_name method...&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;keithl&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call set_name method...&quot;</span>)</span><br><span class="line">		self.__name = value</span><br><span class="line"></span><br><span class="line">	name = <span class="built_in">property</span>(fget = get_name,fset = set_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_property</span>():</span></span><br><span class="line">	po = PropertyObject()</span><br><span class="line">	<span class="built_in">print</span>(po.name)</span><br><span class="line">	po.name = <span class="string">&quot;xiaokun&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_property()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">property</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAzOTM0NjA5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>使用装饰器代替上述的属性设置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyObject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call get_name method...&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;keithl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@name.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call set_name method...&quot;</span>)</span><br><span class="line">		self.__name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>测试代码省略</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">property</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0MDI3MTIx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>属性工具:<code>__getattribute__</code>和描述符</p>
</blockquote>
<p>在前面详细说明了属性获取与重载运算符的关系，不熟悉的同学可以参考下《python面向对象编程5》，</p>
<ul>
<li>新式类中的<code>__getattribute__</code>方法会拦截所有属性获取的操作，包括上述属性定义的操作</li>
<li>使用类的描述符<code>__get__</code>&amp;<code>__set__</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDescriptor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span><span class="keyword">return</span> <span class="string">&quot;get_keithl&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span>instance._name=<span class="string">&quot;set_&quot;</span>+value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">descriptors</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	name = NameDescriptor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_name_desc</span>():</span></span><br><span class="line">	nd = descriptors()</span><br><span class="line">	<span class="built_in">print</span>(nd.name)</span><br><span class="line">	nd.name = <span class="string">&quot;keithl&quot;</span></span><br><span class="line">	<span class="built_in">print</span>(nd.name)</span><br><span class="line">	<span class="built_in">print</span>(nd._name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">property</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0NjQxMTc3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python重载运算符详解</title>
    <url>/2018/04/19/opr_detail/</url>
    <content><![CDATA[<span id="more"></span>


<h5 id="python重载运算符详解"><a href="#python重载运算符详解" class="headerlink" title="python重载运算符详解"></a>python重载运算符详解</h5><ol>
<li><p>基础</p>
<ul>
<li>运算符重载能够让类拦截正常的python操作</li>
<li>类能够重载所有的python表达式操作</li>
<li>类也能够重载内置操作,如打印、函数调用抑或是属性访问</li>
<li>重载能够让类的实例看上去更像是内置类型</li>
<li>重载是实现类中提供的特殊方法名，如<code>__X__</code></li>
</ul>
</li>
<li><p>索引和切片操作，<code>__getitem__</code> &amp; <code>__setitem__</code></p>
</li>
</ol>
<ul>
<li><code>__getitem__</code>方法被调用的应用场景</li>
</ul>
<blockquote>
<p>对象实例根据索引值获取索引值对应的数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indexer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call init ...&quot;</span>)</span><br><span class="line">        self.__data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span>           <span class="comment"># index为索引值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call getitem index...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__data[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_index</span>():</span></span><br><span class="line">    <span class="comment"># 取值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(X[i])  <span class="comment"># 等价于Indexer.__getitem__(X,i)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_index()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python indexer.py   <span class="comment"># 注：python如果没有说明表示都是3.x版本</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTMyNDMxMzMx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>对象实例根据分片方式获取一组分片索引值对应的数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slice.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliceObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call slice object init ...&quot;</span>)</span><br><span class="line">        self.__data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>    ]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span>   <span class="comment"># index为索引值或者分片对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">int</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;indexing&#x27;</span>, index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 分片对象有start stop 以及step属性</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;slicing&#x27;</span>, index.start, index.stop, index.step)</span><br><span class="line">        <span class="keyword">return</span> self.__data[index]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_slice</span>():</span></span><br><span class="line">    X = SliceObject()</span><br><span class="line">    <span class="comment"># 分片取值</span></span><br><span class="line">    <span class="built_in">print</span>(X[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(X[:-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(X[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_slice()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">slice</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTM1OTA5NDE1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>迭代器调用并进行数据遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indexer.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_iterator</span>():</span></span><br><span class="line">    X = Indexer()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> X:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># test_index()</span></span><br><span class="line">    test_iterator()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python indexer.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQwNjA4NzMw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>py2.x分片操作的内置方法,py3.x已经删除</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slice.py </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slicer</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	py2.x 分片</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call __getitem__ for index:%s&quot;</span> % <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getslice__</span>(<span class="params">self, i, j</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call __getslice__ for start[%d] to end[%d]&quot;</span> % (i,j))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setslice__</span>(<span class="params">self, i, j, seq</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call __setslice__ for start[%d] to end[%d] with seq[%d]&quot;</span> % (i,j,seq))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_slicer</span>():</span></span><br><span class="line">    Slicer()[<span class="number">1</span>]</span><br><span class="line">    Slicer()[<span class="number">1</span>:<span class="number">9</span>]</span><br><span class="line">    Slicer()[<span class="number">1</span>:<span class="number">9</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_slicer()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">slice</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQwODA2MjQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ0MDQ1NzY4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>py3.x新增<code>__index__</code>内置方法,该方法表示返回一个实例对象的整数型，与索引切片没关系</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indexer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexing</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">py3.x 新增的内置方法，但是该操作不是表示索引操作，而是为一个对象实例返回一个整型数值,并且用于转换为数值字符串的内置操作</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__index__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_indexing</span>():</span></span><br><span class="line">    X = Indexing()</span><br><span class="line">    <span class="comment"># 将对象转换为数值字符串，这里执行两个内置方法,__index__ 和 __str__</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(X))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_indexing()</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python indexer.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ0MzI4OTM2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li><code>__setitem__</code>对索引属性进行赋值操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indexer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span>:</span></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, index, value</span>):</span>    <span class="comment"># index恒为索引下标,value为值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call setitem ...&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key[%s]--value[%s]&quot;</span> % (index,value))</span><br><span class="line">        self.__data.insert(index,value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_index</span>():</span></span><br><span class="line">	<span class="comment"># 设置值</span></span><br><span class="line">    X = Indexer()</span><br><span class="line">    X[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 等价于Indexer.__setitem__(X,0,1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_index()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python indexer.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ0NDQxODQ5?x-oss-process=image/format,png" alt="这里写图片描述"><br>3. 迭代器对象:<code>__iter__</code> &amp; <code>__next__</code></p>
<blockquote>
<p>自定义迭代器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squares</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, stop</span>):</span></span><br><span class="line">        self.value = start - <span class="number">1</span></span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 生成迭代器对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call iter ...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.value == self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call next for value:&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    X = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 迭代器不支持使用索引</span></span><br><span class="line">    X[<span class="number">1</span>]    <span class="comment"># TypeError: &#x27;Squares&#x27; object does not support indexing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ0NjQ3MDY2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>使用循环迭代器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_for</span>():</span></span><br><span class="line">	<span class="comment"># 循环使用迭代器</span></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> Squares(<span class="number">2</span>, <span class="number">9</span>):  <span class="comment"># 调用Squares.__iter__,生成迭代器对象</span></span><br><span class="line">		<span class="built_in">print</span>(item)             <span class="comment"># 调用Squares.__next__</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ1MzUzNjcy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>逐个进行迭代</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_single</span>():</span></span><br><span class="line">	<span class="comment"># 逐个调用迭代器</span></span><br><span class="line">	X = Squares(<span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">	<span class="comment"># 显示将X转换为迭代器对象，条件是该对象有实现__iter__，只需调用一次</span></span><br><span class="line">	I = <span class="built_in">iter</span>(X)             <span class="comment"># Squares.__iter__</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">next</span>(I))          <span class="comment"># 调用Squares.__next__</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">next</span>(I))          <span class="comment"># 调用Squares.__next__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_single()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTQ1NDU0MTk0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>迭代器单次扫描</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_scan</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start single scan ....&quot;</span>)</span><br><span class="line">    X = Squares(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 首次会执行__iter__对迭代器进行初始化，</span></span><br><span class="line">    <span class="comment"># 并且每次执行将调用__next__将数据返回并保存当前迭代器的状态，直至为不可迭代状态</span></span><br><span class="line">    list1 = [n <span class="keyword">for</span> n <span class="keyword">in</span> X]</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 迭代器当前是不可迭代的状态，即list2是空列表</span></span><br><span class="line">    list2 = [n <span class="keyword">for</span> n <span class="keyword">in</span> X]       <span class="comment"># now list2 is empty</span></span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end single scan ....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    single_scan()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU0NjQzNDk0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>迭代器多次扫描</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutil_scan</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start mutil scan ... &quot;</span>)</span><br><span class="line">    <span class="comment"># 方式一：每次都是重新创建新的迭代器来进行迭代</span></span><br><span class="line">    list1 = [n <span class="keyword">for</span> n <span class="keyword">in</span> Squares(<span class="number">1</span>,<span class="number">2</span>)]</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    list2 = [n <span class="keyword">for</span> n <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式二 转换为列表并用列表解析器来转换</span></span><br><span class="line">    list_iter = <span class="built_in">list</span>(Squares(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    list3 = [n <span class="keyword">for</span> n <span class="keyword">in</span> list_iter]</span><br><span class="line">    <span class="built_in">print</span>(list3)</span><br><span class="line">    list4 = [n <span class="keyword">for</span> n <span class="keyword">in</span> list_iter]</span><br><span class="line">    <span class="built_in">print</span>(list4)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end mutil scan ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mutil_scan()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU0NzMyMzk1?x-oss-process=image/format,png" alt="这里写图片描述"><br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N9x57QY5-1571413260940)(media/15078697725265/15081168372111.jpg)]</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU1MDEzMjY0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>设计可多次迭代的类对象</p>
</blockquote>
<ul>
<li>自定义类可多次迭代<ul>
<li>条件：在内置方法中<code>__iter__</code>中返回的迭代器应当新的迭代器对象，而不是self自身对象</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutilIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, wrapper</span>):</span></span><br><span class="line">        self.__wrapper = wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	     每次调用迭代器的时候就创建一个新的迭代器并返回</span></span><br><span class="line"><span class="string">	    &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> DefineIterator(self.__wrapper)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefineIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, wrapped</span>):</span></span><br><span class="line">        self.wrapped = wrapped</span><br><span class="line">        self.offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.offset &gt;= <span class="built_in">len</span>(self.wrapped):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item = self.wrapped[self.offset]</span><br><span class="line">        self.offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	py2.x 没有next方法,python2.x 和 python3.x 都可用</span></span><br><span class="line">	<span class="built_in">next</span> = __next__</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mutil_object_iter</span>():</span></span><br><span class="line">    S = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">    <span class="comment"># 索引遍历操作</span></span><br><span class="line">    M = MutilIterator(S)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> M:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> M:               <span class="comment"># 第二次调用迭代器获取新的迭代器对象 </span></span><br><span class="line">            <span class="built_in">print</span>(x+y,end = <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_mutil_object_iter()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python iterator.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU1MTAwNDU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>类的迭代器与生成器混搭</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,start,stop</span>):</span></span><br><span class="line">        self.__start = start</span><br><span class="line">        self.__stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(self.__start,self.__stop+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> index**<span class="number">2</span>      <span class="comment"># 返回一个生成器对象，通过调用next()来显示值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mix_iterator</span>():</span></span><br><span class="line">    iterator = MixIterator(<span class="number">1</span>,<span class="number">5</span>)            <span class="comment"># 同一个对象可以迭代多次</span></span><br><span class="line">    list1 = [index <span class="keyword">for</span> index <span class="keyword">in</span> iterator]  </span><br><span class="line">    list2 = [index <span class="keyword">for</span> index <span class="keyword">in</span> iterator]</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_mix_iterator()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU1MTMwMTQz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>重构上述设计类的迭代器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterator.py</span></span><br><span class="line"><span class="comment"># 使用yield生成器可以保</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutilIterator2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,wrapper</span>):</span></span><br><span class="line">        self.__wrapper = wrapper</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call iter ... &quot;</span>)</span><br><span class="line">        offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> offset &lt; <span class="built_in">len</span>(self.__wrapper):</span><br><span class="line">            item = self.__wrapper[offset]</span><br><span class="line">            offset+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mutil2_iterator</span>():</span></span><br><span class="line">    S = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">    M = MutilIterator2(S)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> M:       <span class="comment"># 执行__iter__方法</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> M:    <span class="comment"># 执行__iter__方法，进入方法的时候offset又变为初始化0</span></span><br><span class="line">            <span class="built_in">print</span>(x+y,end = <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_mutil2_iterator()</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTU1MjI5MzQ0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>迭代器小结</p>
</blockquote>
<ul>
<li>迭代器是一个很强大的工具,能够让我们创建自定义迭代器对象来完成自己的业务需求,比如支持大型数据库在多个游标中进行数据查询时获取迭代</li>
<li>对象单个迭代器对象,即不能作为类似于上述的操作,python有map、zip、函数生成器以及生成器表达式</li>
<li>对象多个迭代器对象,即可以来操作上述的动作，python有list、string、range</li>
<li>使用类的迭代器，我们可以自定义迭代器是单例还是多例</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类重载运算符</title>
    <url>/2019/04/01/override_opr/</url>
    <content><![CDATA[<span id="more"></span>


<h4 id="python类重载运算符"><a href="#python类重载运算符" class="headerlink" title="python类重载运算符"></a>python类重载运算符</h4><p>1.成员操作符:<code>__contains__</code></p>
<blockquote>
<p>判断member是否存在<strong>可迭代的对象</strong>中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># membership.py</span></span><br><span class="line"><span class="comment"># 定义的对象必须是可迭代的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iters</span>:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   将所有可迭代的方法列出来 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		self.data = value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, i</span>):</span>    <span class="comment"># 迭代、索引、分片操作的时候会被调用</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> self.data[i]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span>          <span class="comment"># 进行迭代的时候会被调用</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;iter=&gt; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">		self.ix = <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;next:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> self.ix == <span class="built_in">len</span>(self.data):<span class="keyword">raise</span> StopIteration</span><br><span class="line">		item = self.data[self.ix]</span><br><span class="line">		self.ix += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, x</span>):</span>      <span class="comment"># 成员变量的判断，使用in</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;contains: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">	<span class="built_in">next</span> = __next__</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_iter</span>():</span></span><br><span class="line">    X = Iters([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)   <span class="comment"># contains: True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> X:</span><br><span class="line">		<span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_iter()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python membership.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNjAyMDg4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>2.属性管理</p>
<blockquote>
<p>属性访问<code>__getattr__</code></p>
</blockquote>
<ul>
<li>obj.attr_name的形式访问对象属性</li>
<li>自定义类管理属性信息,对于访问不存在的属性可以返回错误信息提示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># attr.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrObject</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr_name</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Attr Object get attr method ....&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> attr_name == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError(<span class="string">&quot;could not access the attr[%s]&quot;</span> % attr_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_empty</span>():</span></span><br><span class="line">	e = AttrObject()</span><br><span class="line">	<span class="built_in">print</span>(e.age)        <span class="comment"># 调用__getattr__方法,访问age属性,匹配并返回40</span></span><br><span class="line">	<span class="built_in">print</span>(e.hobby)      <span class="comment"># AttributeError: could not access the attr[hobby]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_empty()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python attr.py      <span class="comment"># 2.x &amp; 3.x表示结果一样,以下都会以此标记</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNjE5NTM5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>属性设置<code>__setattr__</code></p>
</blockquote>
<ul>
<li>定义类对象管理属性并将属性名以及值存储在一个实例对象中</li>
<li>self.attrname 以及 instance.attrname 将会调用类的内置方法<code>__setattr__</code>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># attr.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcessControl</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.hobby = <span class="string">&quot;basketball&quot;</span>               <span class="comment"># 会调用下面的__setattr__方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		<span class="comment"># self.name = &quot;xxxx&quot;                    # 不能在__setattr__上使用self.attr,会导致递归应用循环</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;access control set attr ...&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> key == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[key] = value + <span class="number">10</span>     <span class="comment"># 通过内建字典来保存属性数据</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;del item[%s]&quot;</span> % item)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;get item[%s]&quot;</span> % item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_access_control</span>():</span></span><br><span class="line">	ac = AcessControl()</span><br><span class="line">	ac.age = <span class="number">10</span>         <span class="comment"># 调用__setattr__</span></span><br><span class="line">	<span class="built_in">print</span>(ac.age)       <span class="comment"># 直接输入值，没有调用__getattr__</span></span><br><span class="line">	<span class="built_in">print</span>(ac.hobby)     <span class="comment"># 当属性有值时，也就是非None是不会调用__getattr__方法的，如果没有值，即None就会调用__getattr__方法</span></span><br><span class="line">	<span class="keyword">del</span> ac.age          <span class="comment"># 调用__delattr__</span></span><br><span class="line">	<span class="built_in">print</span>(ac.name)      <span class="comment"># 调用__getattr__,调用未定义的属性时候就会回调这个函数并且返回None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_access_control()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python attr.py      <span class="comment"># 2.x &amp; 3.x</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNjM2Mzc0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>属性设置与访问<code>__getattribute__</code></p>
</blockquote>
<ul>
<li>这个方法将会拦截所有获取的属性的操作，包括未定义的属性</li>
<li>属性内置函数允许我们将方法与特定类属性的获取和集合操作相关联</li>
<li>属性描述符为特定的类的属性提供了一组<code>__get__</code>和<code>__set__</code>方法访问协议</li>
<li>实例属性在类中声明但是在每一个类的对象实例中隐式存储</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrManager</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:param item:</span></span><br><span class="line"><span class="string">		:return:</span></span><br><span class="line"><span class="string">		避免产生递归循环引用,不要使用self.attr_name对属性进行访问或者设置,属性访问会经过这个方法</span></span><br><span class="line"><span class="string">		这里没有保存数据，因此返回的时候是None</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call  __getattribute__ for item[%s] &quot;</span> % item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_attr_manager</span>():</span></span><br><span class="line">	manager = AttrManager()</span><br><span class="line">	manager.name = <span class="string">&quot;attr manager name&quot;</span></span><br><span class="line">	<span class="built_in">print</span>(manager.name)</span><br><span class="line">	<span class="built_in">print</span>(manager.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_attr_manager()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python attr.py  <span class="comment"># 2.x与3.x的不同输出</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNjU4MTg0?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNzE0NDY1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li><code>__setattr__</code>和<code>__getattr__</code>能够在python不同的版本下对未定义的属性进行访问和赋值</li>
<li><code>__getattribute__</code>只能在3.x下对未定义的属性名进行访问</li>
<li>为了更好的兼容2.x和3.x，应当重载两个方法,即<code>__getattr__</code>以及<code>__getattribute__</code></li>
<li>python3.x中的执行的优先级，<code>__getattribute__</code> &gt; <code>__getattr__</code></li>
<li>python2.x中的执行的优先级，<code>__getattr__</code> &gt; <code>__getattribute__</code></li>
<li>如果类中没有定义<code>__getattribute__</code>或者<code>__getattr__</code>,则在访问未定义的属性时候会报没有属性的错误</li>
</ul>
<p>3.字符串打印:<code>__str__</code>,<code>__repr__</code></p>
<ul>
<li><code>__str__</code>主要应用于print函数以及字符串函数str的转换操作,</li>
<li><code>__repr__</code>应用于所有输出操作,如果有print以及str操作并定义<code>__str__</code>,则会以<code>__str__</code>为准</li>
<li><code>__repr__</code>与<code>__str__</code>均未定义的时候，默认打印的是输出对象地址信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayClass</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	__repr__ is used everywhere, except by print and str when a __str__ is defined.</span></span><br><span class="line"><span class="string">	__str__ to support print and str exclusively</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;display __repr__ class&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;display __str__ class&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命令行的形式打印输出  2.x &amp; 3.x 输出效果一致,以2.x作为截图</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = DisplayClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d                   <span class="built_in">repr</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(d)            <span class="built_in">str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(d))      <span class="built_in">repr</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(d))       <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNzMxMjk1?x-oss-process=image/format,png" alt="这里写图片描述"><br>4.运算操作符:<code>__add__</code>,<code>__radd__</code>,<code>__iadd__</code></p>
<blockquote>
<p>变量+常量,如X + 1024,调用<code>__add__</code>方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># addition.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value = <span class="number">0</span></span>):</span></span><br><span class="line">		self.data = value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] add [%d]...&quot;</span> % (self.data,other))</span><br><span class="line">		<span class="keyword">return</span> self.data + other</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">	r = Counter()</span><br><span class="line">	q = r + <span class="number">1024</span>       <span class="comment"># call add, instance +</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;q is %d&quot;</span> % q)</span><br><span class="line"></span><br><span class="line">test_add()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python addition.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxNzQ2MDU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>常量+变量,如1024 + X,调用<code>__radd__</code>方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># addition.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    ...     <span class="comment"># 省略上述代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] radd [%d]...&quot;</span> % (self.data,other))</span><br><span class="line">		<span class="keyword">return</span> self.data + other</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_radd</span>():</span></span><br><span class="line"> 	p = <span class="number">7</span> + r       <span class="comment"># call radd, + instance</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;the p is %d&quot;</span> % p)</span><br><span class="line">	</span><br><span class="line">test_radd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python addition.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxODExNTYw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>变量+变量,如X + Y</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># addition.py</span></span><br><span class="line"><span class="comment"># 执行X+Y的时候,会先执行__add__方法,再执行__radd__方法,此时代码需要稍微调整下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">isinstance</span>(other,Counter):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] radd [%d]...&quot;</span> % (self.data,other.data))</span><br><span class="line">		<span class="keyword">elif</span> <span class="built_in">isinstance</span>(other,<span class="built_in">int</span>):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] radd [%d]...&quot;</span> % (self.data, other))</span><br><span class="line">		<span class="keyword">return</span> self.data + other</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">isinstance</span>(other,Counter):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] add [%d]...&quot;</span> % (self.data,other.data))</span><br><span class="line">		<span class="keyword">elif</span> <span class="built_in">isinstance</span>(other,<span class="built_in">int</span>):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;counter data[%s] add [%d]...&quot;</span> % (self.data, other))</span><br><span class="line">		<span class="keyword">return</span> self.data + other</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_addition</span>():</span></span><br><span class="line">    X = Counter(<span class="number">2</span>)</span><br><span class="line">	Y = Counter(<span class="number">4</span>)</span><br><span class="line">	<span class="built_in">sum</span> = X + Y     <span class="comment"># X + Y ==&gt; 2 + Y ==&gt; 4 + 2</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">test_addition()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python addition.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxODI1MzM3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>5.回调:<code>__call__</code></p>
<blockquote>
<p>函数回调设计</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="comment"># 使用函数进行回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_fn</span>(<span class="params">color</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">oncall</span>():</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;select the color[%s]&quot;</span> % color)</span><br><span class="line">	<span class="keyword">return</span> oncall</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_callback_fn</span>():</span></span><br><span class="line">	fn = callback_fn(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">	fn()</span><br><span class="line"></span><br><span class="line">test_callback_fn()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxODM4ODU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>匿名函数回调</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_lamaba_callback</span>():</span></span><br><span class="line">	cs4 = (<span class="keyword">lambda</span> color=<span class="string">&#x27;red&#x27;</span>: <span class="built_in">print</span>(<span class="string">&#x27;turn &#x27;</span> + color))</span><br><span class="line">	cs4()</span><br><span class="line"></span><br><span class="line">test_lamaba_callback()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxODUyNDE3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>类回调设计</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallBack</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,color</span>):</span></span><br><span class="line">		self.color = color</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call callback color[%s]&quot;</span> % self.color)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventCall</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,callback = <span class="literal">None</span></span>):</span></span><br><span class="line">		self.c = callback</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">press</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.c()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_call_back</span>():</span></span><br><span class="line">	c1 = CallBack(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">	c2 = CallBack(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">	e1 = EventCall(callback = c1)</span><br><span class="line">	e2 = EventCall(callback = c2)</span><br><span class="line"></span><br><span class="line">	e1.press()      <span class="comment"># when press then trigger callback</span></span><br><span class="line">	e2.press()</span><br><span class="line"></span><br><span class="line">test_call_back()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxOTA3MDUx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>6.比较运算符</p>
<ul>
<li>py3.x不存在<code>__cmp__</code>以及cmp方法,也就是py3.x不能再使用<code>__cmp__</code>以及cmp方法,py2.x仍然保留</li>
<li>为兼容性,统一在py2.x与py3.x使用<code>__lt__</code>和<code>__gt__</code>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	方式一</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__gt__</span>(<span class="params">self, other</span>):</span> <span class="keyword">return</span> self.data &gt; other</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span> <span class="keyword">return</span> self.data &lt; other</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_comp</span>():</span></span><br><span class="line">	c = C()</span><br><span class="line">	<span class="built_in">print</span>(c &gt; <span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(c &lt; <span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_comp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py </span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxOTIxNTI4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>py2.x可用而py3.x不可用情况</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>:</span></span><br><span class="line">	data = <span class="string">&quot;spam&quot;</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	python3.x将不可用</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">return</span> cmp(self.data,other)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	方式三,改变cmp的方法,3.x仍然报错</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	data = <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">return</span> (self.data &gt; other) - (self.data &lt; other)</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_S</span>():</span></span><br><span class="line">	s = S()</span><br><span class="line">	<span class="built_in">print</span>(s &gt; <span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_d</span>():</span></span><br><span class="line">	d = D()</span><br><span class="line">	<span class="built_in">print</span>(d &gt; <span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(d &lt; <span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_S()</span><br><span class="line">test_d()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxOTM1MDYw?x-oss-process=image/format,png" alt="这里写图片描述"><br>7.布尔测试:<code>__bool__</code>,<code>__len__</code>,<code>__nozero__</code></p>
<ul>
<li>py3.x:如果没有<code>__bool__</code>就会执行<code>__len__</code>,也就是两个都存在的时候，<code>__bool__</code>的优先级比<code>__len__</code>高</li>
<li>py2.x如果没有<code>__bool__</code>就会执行<code>__len__</code>,也就是两个都存在的时候，<code>__len__</code>的优先级比<code>__bool__</code>高</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truth</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call bool method ...&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call len method ....&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_truth</span>():</span></span><br><span class="line">	X = Truth()</span><br><span class="line">	<span class="keyword">if</span> X:   </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;i&#x27;m truth ....&quot;</span>)</span><br><span class="line"></span><br><span class="line">test_truth()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxOTUwMzcz?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyMDAyNjUx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p><code>__nonzero__</code>:仅在python2.x使用，用于返回一个布尔值,并且优先级大于上面的<code>__len__</code>方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truth</span>:</span></span><br><span class="line">    <span class="comment"># 定义了__bool__方法以及__len__方法</span></span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__nonzero__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;call zero for python2.x&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">... </span><span class="comment"># 同样的测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyMDE2MzIy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>8.析构函数:<code>__del__</code></p>
<blockquote>
<p>__del__使用笔记</p>
</blockquote>
<ul>
<li>Need:即是否必需,python会自动回收内存空间，析构器并非是空间管理的一项必需工具</li>
<li>Predictability:即是否可预测,python退出解释器的时候，并不能保证会调用仍然存在的对象的析构函数来进行回收操作</li>
<li>Exceptions:由于存在异常情况并且不知道异常发生的时刻，析构器很难确定什么时候调用来进行回收操作</li>
<li>Cycles:对象的循环引用可以防止垃圾回收器发生一些如我们所期望的错误</li>
</ul>
<blockquote>
<p>代码测试</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># others.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Life</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&#x27;unknown&#x27;</span></span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">live</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Goodbye &#x27;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_del</span>():</span></span><br><span class="line">	l = Life(<span class="string">&quot;keithl&quot;</span>)</span><br><span class="line">	l.live()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_del()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python others.py        <span class="comment"># 2.x &amp; 3.x</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAyMjEwMjM1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建python环境</title>
    <url>/2017/12/31/python01/</url>
    <content><![CDATA[<span id="more"></span>
<h5 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## win10 &amp;&amp; macOS直接下载安装</span><br><span class="line">win10平台 ：https://www.docker.com/docker-windows</span><br><span class="line">macOS平台：https://www.docker.com/docker-mac</span><br><span class="line">## 需要使用Toolbox工具箱来安装Docker machine，并在docker machine下启动docker虚拟机</span><br><span class="line">win7平台：https://www.docker.com/products/docker-toolbox</span><br><span class="line">参考链接：http://www.docker.org.cn/book/install/c24.html</span><br></pre></td></tr></table></figure>

<h5 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建Docker镜像</h5><blockquote>
<p>基于Dockerfile构建镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 参考链接：https://docs.docker.com/engine/examples/running_ssh_service/#build-an-eg_sshd-image</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y openssh-server</span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN echo &#x27;root:root123&#x27; | chpasswd   ## 自己修改账户名和密码</span><br><span class="line">RUN sed -i &#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config</span><br><span class="line"># SSH login fix. Otherwise user is kicked off after login</span><br><span class="line">RUN sed &#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27; -i /etc/pam.d/sshd</span><br><span class="line">ENV NOTVISIBLE &quot;in users profile&quot;</span><br><span class="line">RUN echo &quot;export VISIBLE=now&quot; &gt;&gt; /etc/profile</span><br><span class="line">EXPOSE 22 80 3306 ## 这里暴露80、22、3306</span><br><span class="line">CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构建镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 进入本地自己的dockerfile所在目录，当前目录是在 ~/mywork/docker/docker</span><br><span class="line">docker build -t 自定义镜像名称:tag标签名 .</span><br><span class="line">docker build -t docker-ssh:v1 .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看docker镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构建docker-ssh容器实例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name pydev -v $PWD/data:/opt/data docker-ssh:v1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入linux环境</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh root@127.0.0.1 -p 32770</span><br></pre></td></tr></table></figure>

<h5 id="安装ZSH"><a href="#安装ZSH" class="headerlink" title="安装ZSH"></a>安装ZSH</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install -y zsh &amp;&amp; apt-get install -y wget</span><br><span class="line">apt-get install -y git</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>

<h5 id="安装python必备的apt软件包"><a href="#安装python必备的apt软件包" class="headerlink" title="安装python必备的apt软件包"></a>安装python必备的apt软件包</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install -y build-essential</span><br><span class="line">sudo apt-get install -y libsqlite3-dev</span><br><span class="line">sudo apt-get install -y libreadline6-dev</span><br><span class="line">sudo apt-get install -y libgdbm-dev</span><br><span class="line">sudo apt-get install -y zliblg-dev</span><br><span class="line">sudo apt-get install -y libbz2-dev</span><br><span class="line">sudo apt-get install -y sqllite3</span><br><span class="line">sudo apt-get install -y tk-dev</span><br><span class="line">sudo apt-get install -y zip</span><br></pre></td></tr></table></figure>

<h5 id="安装python相关包"><a href="#安装python相关包" class="headerlink" title="安装python相关包"></a>安装python相关包</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 安装python-dev包</span><br><span class="line">sudo apt-get install -y python-dev</span><br><span class="line">### 安装distribute包</span><br><span class="line">sudo chmod -R 0755 /usr/local   ### 修改本地/usr/local权限</span><br><span class="line">sudo chgrp -R keithl /usr/lcoal  ### 更改文件所属用户组</span><br><span class="line">wget http://python-distribute.org/distribute_setup.py</span><br><span class="line">sudo python distribute_setup.py</span><br></pre></td></tr></table></figure>

<h5 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 参考url:https://pip.pypa.io/en/stable/installing/</span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure>

<h5 id="python虚拟环境搭建"><a href="#python虚拟环境搭建" class="headerlink" title="python虚拟环境搭建"></a>python虚拟环境搭建</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install virtualenvwrapper</span><br><span class="line">### 配置.bashrc or .bash_profile or .zshrc文件</span><br><span class="line">if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then</span><br><span class="line">   export WORKON_HOME=~/workdir/python/pyenv</span><br><span class="line">   export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python</span><br><span class="line">   export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv</span><br><span class="line">   export PROJECT_HOME=/Users/wind/projects/python/</span><br><span class="line">   source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line">fi</span><br><span class="line">### 配置生效</span><br><span class="line">source ~/.bash_profile(.bashrc/.zshrc)</span><br><span class="line"></span><br><span class="line">### help帮助命令</span><br><span class="line">mkvirtualenv --help</span><br><span class="line"></span><br><span class="line">### 创建python开发目录并指定python版本</span><br><span class="line">mkvirtualenv --python=/usr/bin/python2.7 pyen2.7 </span><br><span class="line">OR</span><br><span class="line">mkvirtualenv --python=/usr/bin/python3.5 pyen3.5</span><br><span class="line"></span><br><span class="line">### 官网参考</span><br><span class="line">https://virtualenvwrapper.readthedocs.io/en/latest/</span><br></pre></td></tr></table></figure>

<h5 id="python便捷工具"><a href="#python便捷工具" class="headerlink" title="python便捷工具"></a>python便捷工具</h5><blockquote>
<p>检查代码风格工具</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pep8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>语法检查工具</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyflakes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令自动补全</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 1 way</span><br><span class="line">pip completion --zsh &gt;&gt; .zprofile</span><br><span class="line">source ~/.zprofile</span><br><span class="line">### 2 way,在~/.zshrc里面一行</span><br><span class="line">eval &quot;pip completion --zsh&quot;</span><br><span class="line">### 3.使用bash</span><br><span class="line">pip completion --bash &gt;&gt; ~/.profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python3.x之super()用法小结</title>
    <url>/2019/12/31/super/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="传统调用父类的方式"><a href="#传统调用父类的方式" class="headerlink" title="传统调用父类的方式"></a>传统调用父类的方式</h5><blockquote>
<p>传统父类方法调用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Super Class act method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>(<span class="params">SuperClass</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		SuperClass.act(self)        <span class="comment"># 显式地调用父类方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;SubClass act method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sub = SubClass()</span><br><span class="line">    sub.act()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py  </span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0ODA2NTc2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h5 id="super基本使用"><a href="#super基本使用" class="headerlink" title="super基本使用"></a>super基本使用</h5><blockquote>
<p>super()方法只能在py3.x中使用，py2.x必须要指明类名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Super Class act method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>(<span class="params">SuperClass</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">super</span>().act()</span><br><span class="line">		<span class="comment"># super(SubClass,self).act()     # py2.x 调用父类，过于复杂，这个可以正常执行</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;SubClass act method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sub = SubClass()</span><br><span class="line">    sub.act()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py     </span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0ODE4OTg4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0ODMwNzgw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>super在多继承中的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call A act method ....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call B act method ....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">B,A</span>):</span>       <span class="comment"># 搜索的顺序会从B开始搜索，B存在act方法则调用并返回，不再继续搜索</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">act</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">super</span>().act()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = C()</span><br><span class="line">	c.act()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0ODQ5MjAw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>super不支持运算符操作，如super()[index]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call E __getitem__ method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">E</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;call F __getitem__ method ..&#x27;</span>)</span><br><span class="line">		E.__getitem__(self, item)</span><br><span class="line">		<span class="built_in">super</span>().__getitem__(item)</span><br><span class="line">		<span class="built_in">super</span>()[item]       <span class="comment"># 不支持运算符操作，&#x27;super&#x27; object is not subscriptable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_opr</span>():</span></span><br><span class="line">	f = F()</span><br><span class="line">	f[<span class="number">2</span>]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_opr()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0OTA1OTI5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h5 id="super的作用"><a href="#super的作用" class="headerlink" title="super的作用"></a>super的作用</h5><blockquote>
<p>在运行时可以改变类的继承树</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m1</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call X method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m1</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call Y method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>(<span class="params">X</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m1</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">super</span>().m1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_z</span>():</span></span><br><span class="line">	z = Z()</span><br><span class="line">	z.m1()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;change Z class base for Y ....&quot;</span>)</span><br><span class="line">	Z.__bases__=(Y,)</span><br><span class="line">	z.m1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	test_z()</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0OTE5Nzc1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>能够在多继承中按照广度优先的继承树搜索关系链来有序地调用与父类相同名称的方法，且在每个子类拥有super的都会执行父类方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IA</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call IA init ...&quot;</span>)   <span class="comment"># 基类IA没有super()，没有意义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IB</span>(<span class="params">IA</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call IB init ....&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IC</span>(<span class="params">IA</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call IC init ....&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ID</span>(<span class="params">IC,IB</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call ID init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ID</span>():</span></span><br><span class="line">	d = ID()</span><br><span class="line">	<span class="built_in">print</span>(ID.mro())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_ID()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0OTM4MDI0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><strong>纠正一下，上面不是深度优先而是广度优先</strong></p>
<h5 id="super-多继承方法协作的使用注意事项"><a href="#super-多继承方法协作的使用注意事项" class="headerlink" title="super()多继承方法协作的使用注意事项"></a>super()多继承方法协作的使用注意事项</h5><blockquote>
<p>在父类没有使用super()情况下，在子类中将使用类的继承树搜索方式来匹配父类方法，找到并返回调用，不再继续往下搜索</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P1</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call P1 init ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P2</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call P2 init ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种方式等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>(<span class="params">P2,P1</span>):</span></span><br><span class="line">	<span class="keyword">pass</span>    <span class="comment"># 默认调用父类的构造方法,如果有定义的话并且子类没有调用super()将不会调用父类方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>(<span class="params">P2,P1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA0OTUzNDkz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>子类的继承树最近的父类如果没有使用super(),则调用链停止,如果使用super()将以广度优先的方式进行遍历,通过mro()查看调用链</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py 用上述的IA,IB,IC,ID做示例</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IC</span>(<span class="params">IA</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call IC init ....&quot;</span>)</span><br><span class="line">		<span class="comment"># super().__init__()    # 调用链停止</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MDA3Mzgy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>子类多继承中,按上述所说的,如果父类存在super()调用，将以广度优先地处理方式进行搜索,比如</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P1</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call P1 init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P2</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call P2 init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>(<span class="params">P2,P1</span>):</span></span><br><span class="line">    <span class="comment"># 最先搜索到的父类是P2,如果P2有使用super()来调用,那么就会以MRO的方式来搜索并继续往下调用,否则将停止调用</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_s</span>():</span></span><br><span class="line">	s = S()</span><br><span class="line">	S.mro()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_s()</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MDIzMTk5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MDMzOTA0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>在多继承中,最后的一个父类的顶层基类对应的super()将断开关系链,因为MRO的继承树最右边是object对象,不会继续往下调用</p>
</blockquote>
<ul>
<li>如上述的P1,P2,P1是属于仅次于object的顶层基类,调用super()不会指向其他的基类</li>
<li>P2和P1是两个没有任何关系的基类,但是在S类的MRO中,P2的super()便是P1(),因此在P2中使用super()会调用到P1的方法</li>
<li>对于P1没有super(),在实际编码中应当删除调用super()的语句,避免混淆</li>
</ul>
<blockquote>
<p>super()在多继承多个方法中的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixSuperA</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m1</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call mix super class A m1 method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixSuperB</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m2</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call mix super class B m2 method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassA</span>(<span class="params">MixSuperA</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m2</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call sub class A m2 method ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassD</span>(<span class="params">MixSuperA,MixSuperB</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m1</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call sub class D m1 method ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().m2()    <span class="comment"># 以MRO的搜索方式遍历</span></span><br><span class="line">		<span class="built_in">super</span>().m1()    <span class="comment"># 以MRO的搜索方式遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    d = SubClassD()</span><br><span class="line">    d.m1()  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MDQ5Mjkw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<blockquote>
<p>super调用的参数约束</p>
</blockquote>
<ul>
<li>super调用的方法必须存在</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;call person init ...&quot;</span>)</span><br><span class="line">		self.__name = name</span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,age</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;call Student init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__(<span class="string">&quot;keithl&quot;</span>,age)      <span class="comment"># 这里的super()使用MRO方式进行搜索，对应是Son,而Son只提供一个参数age的传递</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,age</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call son init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__(<span class="string">&quot;keithl&quot;</span>,age)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>(<span class="params">Student,Son</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Me(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MTAzMzg1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>为避免复杂化,定义规范:在每一个被super调用的方法参数签名必须与基类的定义的方法一致</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># super.py</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&quot;call Student init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__(name,age)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call son init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MTE1Nzcw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>为避免复杂化以及多继承中的方法混淆,最好是在MRO中最后一个调用的方法链中使用super()去覆盖基类的方法,其他的不要使用super()覆盖</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># Student不做定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;call son init ...&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python <span class="built_in">super</span>.py</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjA1MTI5Njkw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h5 id="super-小结"><a href="#super-小结" class="headerlink" title="super()小结"></a>super()小结</h5><ul>
<li>super()方法在py3.x中可用,py2.x是使用super关键字并传入父类名称和子类self对象</li>
<li>super()调用方法将以MRO的搜索方式进行关系链的调用</li>
<li>在子类中如果没有使用super()将停止关系链的调用</li>
<li>在MRO最右边的顶层基类中不要声明super()语句调用</li>
<li>混合方法使用super()仍然以上述规则来查询</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之uwsgi配置</title>
    <url>/2019/12/10/uwsgi/</url>
    <content><![CDATA[<span id="more"></span>
<blockquote>
<p>uwsg基础配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># 当前文件所处的文件夹</span><br><span class="line">chdir=%d</span><br><span class="line">project_name=%c</span><br><span class="line">user=@(exec://whoami)</span><br><span class="line">virtualenv=/home/keithl/workdir/python/pyenv/%(project_name)</span><br><span class="line"># load a WSGI module</span><br><span class="line">wsgi-file=wsgi_admin_handler.py</span><br><span class="line">master=true</span><br><span class="line"></span><br><span class="line"># set the socket listen queue size</span><br><span class="line">listen=100</span><br><span class="line"># 本机内网ip</span><br><span class="line">lanip=@(exec://hostname -I|awk &#x27;&#123;print $NF&#125;&#x27;)</span><br><span class="line"># 本机外网ip</span><br><span class="line">comboip=@(exec://hostname -I|awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 设置端口</span><br><span class="line">http=%(lanip):9000</span><br><span class="line"></span><br><span class="line"># 设置进程数</span><br><span class="line">processes=4</span><br><span class="line"></span><br><span class="line">print=%(http)</span><br><span class="line">pidfile=%(chdir)logs/uwsgi.pid</span><br><span class="line"># supervisor transfrom process into daemon</span><br><span class="line">vacuum=true</span><br><span class="line">auto-procname=true</span><br><span class="line">procname-prefix-spaced=%(user)_%(project_name)</span><br><span class="line"># supervisorctl restart</span><br><span class="line">touch-reload=/home/keithl/workdir/python/pyenv/cgi_reload_file/%(project_name)</span><br><span class="line">#touch-reload=wsgi_handler.py</span><br><span class="line">enable-threads=true</span><br><span class="line">lazy-apps=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日志</span><br><span class="line">show-config=true</span><br><span class="line">log-maxsize=0</span><br><span class="line">logfile-chmod=644</span><br><span class="line">logfile-chown=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># daemonize=%(chdir)logs/uwsgi_default.log</span><br><span class="line">logto=%(chdir)logs/uwsgi_default.log</span><br><span class="line">req-logger=file:%(chdir)logs/uwsgi_req.log</span><br><span class="line"></span><br><span class="line">exec-asap=mkdir -p %(chdir)logs</span><br><span class="line">exec-asap=touch %(chdir)logs/uwsgi_default.log</span><br><span class="line">exec-asap=chmod 644 %(chdir)logs/uwsgi_default.log</span><br><span class="line">exec-asap=touch %(chdir)logs/uwsgi_req.log</span><br><span class="line">exec-asap=chmod 644 %(chdir)logs/uwsgi_req.log</span><br><span class="line"></span><br><span class="line"># 日志切割</span><br><span class="line">cron = -30 -1 -1 -1 -1 find %(chdir)logs \( -name &quot;uwsgi_req.log&quot; -o -name &quot;uwsgi_default.log&quot; -o -name &quot;default.log&quot; -o -name &quot;epay.log&quot; -o -name &quot;leazy-error-log&quot; -o -name &quot;leazy-info-log&quot; -o -name &quot;leazy-debug-log&quot; -o -name &quot;error.log&quot; \) -size +100M -exec cp &#123;&#125; &#123;&#125;.`date +&quot;%%Y-%%m-%%d_%%H:%%M:%%S&quot;`.rotate.log \; -exec truncate &#123;&#125; --size 0 \;</span><br><span class="line"></span><br><span class="line"># 压缩 每天凌晨2:56将logs目录下后缀是rotate.log的，且最后修改时间在1天以上的日志，用gzip压缩</span><br><span class="line">cron = 56 2 -1 -1 -1 find %(chdir)logs -mtime +1 -name &quot;*.rotate.log&quot; -exec gzip &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"># 删除旧的日志 每天凌晨 3:56将太旧的备份文件删除，保留一个月吧,后缀是rotate.log.gz</span><br><span class="line">cron = 56 3 -1 -1 -1 find %(chdir)logs -mtime +31 -name &quot;*.rotate.log.gz&quot; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用supervisord配置启动</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:cclive]</span><br><span class="line">directory=/home/cc/webcc/cclive</span><br><span class="line"><span class="built_in">command</span>=/home/cc/.virtualenvs/webdd/bin/uwsgi webdd_uwsgi.ini</span><br><span class="line">user=cc</span><br><span class="line">numprocs=1</span><br><span class="line">stdout_logfile=/home/cc/webcc/cclive/logs/uwsgi_console.log</span><br><span class="line">redirect_stderr=<span class="literal">true</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">startsecs=10</span><br><span class="line">stopwaitsecs=600</span><br><span class="line">killasgroup=<span class="literal">true</span></span><br><span class="line">priority=998</span><br><span class="line">stopsignal=QUIT</span><br><span class="line"></span><br><span class="line">[program:cclive_celery]</span><br><span class="line">directory=/home/cc/webcc/cclive</span><br><span class="line"><span class="built_in">command</span>=/home/cc/.virtualenvs/webdd/bin/celery --app=webdd.celery:app worker --loglevel=INFO -Ofair --time-limit=120</span><br><span class="line">user=cc</span><br><span class="line">numprocs=1</span><br><span class="line">stdout_logfile=/home/cc/webcc/cclive/logs/celery_console.log</span><br><span class="line">redirect_stderr=<span class="literal">true</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">startsecs=10</span><br><span class="line">stopwaitsecs=600</span><br><span class="line">killasgroup=<span class="literal">true</span></span><br><span class="line">priority=998</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用celery配置django</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the default Django settings module for the &#x27;celery&#x27; program.</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;webdd.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;webdd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a string here means the worker will not have to</span></span><br><span class="line"><span class="comment"># pickle the object when using Windows.</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>)</span><br><span class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC(1)</title>
    <url>/2018/10/01/mvc/</url>
    <content><![CDATA[<span id="more"></span>


<blockquote>
<p>SpringMVC 原理</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTUyOTMwMTY5?x-oss-process=image/format,png" alt="springMVC 执行流程"></p>
<ul>
<li>s1:浏览器携带请求数据request发送到SpringMVC前端控制器DispacherServlet中</li>
<li>s2：DispacherServlet将请求转发给SpringMVC处理器映射器</li>
<li>s3：处理器映射器(handler mapping)根据request携带的url信息来进行决策要将request请求给哪个控制器处理并告知DispacherServlet</li>
<li>s4：DispacherServlet根据handler mapping决策将request发送到控制器，请求会卸下其负载的信息并等待控制器将业务委托给一个或者多个服务对象处理返回</li>
<li>s5：控制器将数据模型（委托的服务返回给用户显示的信息）打包并以特定的视图形式发送回DispatcherServlet</li>
<li>s6：DispatcherServlet将一个视图的逻辑名传递给视图解析器来确定返回给用户显示的指定视图实现</li>
<li>s7：视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端</li>
</ul>
<blockquote>
<p>AbstractAnnotationConfigDispatcherServletInitializer解析</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI5MTM0NTAzOTM0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ul>
<li>在servlet3.0的环境中，容器会在类路径中查找实现接口类的javax.servlet.ServletContainerInitializer，如果找到就用它来配置servlet容器</li>
<li>Spring的SpringServletContainerInitializer实现这个接口并将由所有实现WebApplicationInitializer接口的类来做一系列的配置任务</li>
<li>Spring中的AbstractAnnotationConfigDispatcherServletInitializer实现了WebApplicationInitializer接口，因此我们也可以在Java Config中配置先前web.xml的配置</li>
</ul>
<blockquote>
<p>使用java的config来配置servlet容器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置web映射路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定Web的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SpringMVC 两个上下文对象</p>
</blockquote>
<ul>
<li>DispatcherServlet：加载包含Web组件的bean，如控制器、视图解析器以及处理器映射</li>
<li>ContextLoaderListener： 加载应用中的其他bean，这些bean通常是驱动应用后端的中间层和数据层组件</li>
</ul>
<blockquote>
<p>DispatcherServlet 使用Java Config来配置并启动容器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.dtrees.springmvc.web&quot;)</span>      <span class="comment">// 启动扫描器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置JSP视图解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/views/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">        resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置静态资源的处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configurer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>web以外的Java配置RootConfig.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.keithl.project.core&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册一系列初始化beans</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring小结(1)</title>
    <url>/2018/10/01/spring/</url>
    <content><![CDATA[<span id="more"></span>

<blockquote>
<p>Spring降低Java开发成本，采取以下4种关键策略</p>
</blockquote>
<ul>
<li>基于POJO的轻量级和最小侵入性编程</li>
<li>通过依赖注入和面向接口实现松耦合</li>
<li>基于切面和惯例进行声明式编程</li>
<li>通过切面和模板减少样板式代码</li>
</ul>
<h6 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h6><ul>
<li>作用：通过将对象的依赖关系交由系统中负责协调各对象的第三方组件（Spring容器）在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系</li>
<li>装配：创建应用组件之间协作的行为通常称为装配</li>
<li>工作原理：Spring通过应用上下文(Application Context)装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅 在于如何加载配置</li>
</ul>
<h6 id="应用切面-AOP"><a href="#应用切面-AOP" class="headerlink" title="应用切面(AOP)"></a>应用切面(AOP)</h6><ul>
<li>作用：允许你把遍布应用各处的功能分离出来形成可重用的组件</li>
<li>组成：横切关注点+切点+切面+通知</li>
<li>横切关注点：系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件</li>
<li>切面：定义横切关注点的JavaBean对象</li>
<li>切点：业务组件对象中需要引入切面定义的系统服务，增强原先业务组件对象的方法服务，即业务组件原先的服务方法称为切点</li>
<li>通知：即在切点前后以及抛出异常时捕获住的切面方法</li>
</ul>
<h6 id="使用模板消除样板式代码"><a href="#使用模板消除样板式代码" class="headerlink" title="使用模板消除样板式代码"></a>使用模板消除样板式代码</h6><ul>
<li><p>通常为了实现通用的和简单的任务，你不得不一遍遍地重 复编写这样的代码，如使用JDBC访问查询数据的操作（打开连接+拼接sql+发送sql+解析结果集+关闭连接），其中样板式代码就是打开连接+发送sql+关闭连接，这些都可以通过模板来消除进而实现只关注核心的业务代码的编写</p>
<h6 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h6></li>
<li><p>作用：Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡(在这里，可能 就是new到finalize()）</p>
</li>
<li><p>bean工厂：org.springframework.beans.factory.BeanFactory，最简单的容器，提供基本的DI支持</p>
</li>
<li><p>应用上下文：org.springframework.context.ApplicationContext，基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件 给感兴趣的事件监听者</p>
</li>
</ul>
<h6 id="Spring应用上下文"><a href="#Spring应用上下文" class="headerlink" title="Spring应用上下文"></a>Spring应用上下文</h6><ul>
<li>AnnotationConfigApplicationContext:从一个或多个基于Java的配置类中加载 Spring应用上下文</li>
<li>AnnotationConfigWebApplicationContext:从一个或多个基于Java的配置类中加 载Spring Web应用上下文</li>
<li>ClassPathXmlApplicationContext:从类路径下的一个或多个XML配置文件中加载 上下文定义，把应用上下文的定义文件作为类资源</li>
<li>FileSystemXmlapplicationcontext:从文件系统下的一个或多个XML配置文件中加载上下文定义</li>
<li>XmlWebApplicationContext:从Web应用下的一个或多个XML配置文件中加载上下文定义</li>
<li>*FileSystemXmlApplicationContext在指定的文件系统 路径下查找knight.xml文件;ClassPathXmlApplicationContext是在所有的类路径(包含 JAR文件)下查找 knight.xml文件**</li>
</ul>
<h6 id="Spring-管理bean的生命周期"><a href="#Spring-管理bean的生命周期" class="headerlink" title="Spring 管理bean的生命周期"></a>Spring 管理bean的生命周期</h6><ol>
<li>Spring对bean进行实例化</li>
<li>Spring将值和bean的引用注入到bean对应的属性中</li>
<li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将 BeanFactory容器实例传入</li>
<li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来</li>
<li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法</li>
<li>如果bean实现了InitializingBean接口，Spring将调用它们的after- PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法</li>
<li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样， 如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>
</ol>
<h6 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h6><ul>
<li>核心容器：管理着Spring应用中bean的创建、配置和管理；在该模块中， 包括了Spring bean工厂，它为Spring提供了DI的功能，同时也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度</li>
<li>AOP模块：AOP可以帮助应用对象解耦，借助于AOP，可以将遍布系统的关注点(例如 事务和安全)从它们所应用的对象中解耦出来</li>
<li>数据访问与集成：<ul>
<li>本模块同样包含了在JMS(Java Message Service)之上构建的Spring抽象层，它会使用消息以异 步的方式与其他应用集成</li>
<li> 为多个ORM框架提供一种构建DAO的简便方式</li>
</ul>
</li>
<li>Web与远程调用：Spring的Web和远程调用自带了一个强大的MVC框架(MVC模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将 界面逻辑与应用逻辑分离)</li>
<li>Instrumentation：提供了为JVM添加代理(agent)的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样</li>
<li>测试：Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对 象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的 bean进行交互提供了支持</li>
</ul>
<h6 id="Spring-Portfolio"><a href="#Spring-Portfolio" class="headerlink" title="Spring Portfolio"></a>Spring Portfolio</h6><ul>
<li>Spring Web Flow：为基于流程的会话式Web应用(可以想一下购物 车或者向导功能)提供了支持，<a href="http://projects.spring.io/spring-webflow/">参考Spring WebFlow</a></li>
<li>Spring Web Service：提供了契约优先的Web Service模型，服务的实现都是为了满 足服务的契约而编写的，<a href="http://docs.spring.io/spring-%20ws/site/">参考Spring WebService</a></li>
<li>Spring Security：安全对于许多应用都是一个非常关键的切面。利用Spring AOP，Spring Security为Spring应用提供 了声明式的安全机制，<a href="http://projects.spring.io/spring-security/">参考Spring Security</a></li>
<li>Spring Integration：许多企业级应用都需要与其他应用进行交互。Spring Integration提供了多种通用应用集成模式的 Spring声明式风格实现，<a href="http://projects.spring.io/spring-integration/">参考Spring Integration</a></li>
<li>Spring Batch：当我们需要对数据进行大量操作时，没有任何技术可以比批处理更胜任这种场景。如果需要开发一个批处理应用，你可以通过Spring Batch，使用Spring强大的面向POJO的编程模型，<a href="https://spring.io/projects/spring-batch">参考Spring Batch</a></li>
<li>Spring Data：不管你使用文档数据库，如MongoDB，图数据库，如Neo4j，还是传统的关系型数据库，Spring Data都为持久化提供了一种简单的编程模型。这包括为多种数据库类型提供了一种自动化的 Repository机制，它负责为你创建Repository的实现</li>
<li>Spring Social：Spring的一个社交网络扩展模块，更多的是关注连 接(connect)，而不是社交(social)。它能够帮助你通过REST API连接Spring应用，其中有些 Spring应用可能原本并没有任何社交方面的功能目标，<a href="https://spring.io/guides/gs/accessing-facebook/">Spring facebook</a>，<a href="https://spring.io/guides/gs/accessing-twitter/">Spring twitter</a></li>
<li>Spring Mobile：Spring Mobile是Spring MVC新的扩展模块，用于支持移动Web应用开发</li>
<li>Spring for Android：旨在通过Spring框架为开发基于 Android设备的本地应用提供某些简单的支持，<a href="http://projects.spring.io/spring-android/">参考Spring Android</a></li>
<li>Spring Boot：Spring Boot大量依赖于自动配置技术，它能够消除大部分(在很多场景中，甚至是全部)Spring 配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小</li>
</ul>
<h6 id="耦合的两面性"><a href="#耦合的两面性" class="headerlink" title="耦合的两面性"></a>耦合的两面性</h6><ul>
<li>一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且典型地表现出“打地鼠”式的bug特性(修复一个bug，将会出现一个或者更多新的bug)。</li>
<li> 另一方面，一定程度的耦合又是必须的——完全没有耦合的代码什么也做不了。为了完成有实际意 义的功能，不同的类必须以适当的方式进行交互。总而言之，耦合是必须的，但应当被小心谨慎地管理</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring小结(2)</title>
    <url>/2019/07/24/spring2/</url>
    <content><![CDATA[<span id="more"></span>

<p>创建应用对象之间协作关系的行为通常称为装配(wiring)，这也是依赖注入(DI)的本质</p>
<h5 id="三种装配机制"><a href="#三种装配机制" class="headerlink" title="三种装配机制"></a>三种装配机制</h5><ul>
<li>在XML中进行显式配置</li>
<li>在Java中进行显式配置</li>
<li>隐式的bean发现机制和自动装配</li>
</ul>
<h5 id="自动化装配"><a href="#自动化装配" class="headerlink" title="自动化装配"></a>自动化装配</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE3MTE1MjU4ODIw" alt="这里写图片描述"></p>
<ul>
<li>组件扫描(component scanning):Spring会自动发现应用上下文中所创建的bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动自动扫描</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>  <span class="comment">// 默认扫描当前的java配置类下的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义javabean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类并声明组件</span></span><br><span class="line"><span class="meta">@Component(&quot;peppersBean&quot;)</span>   <span class="comment">// peppersBean为当前bean指定id名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span></span>&#123;</span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Component</span>:该类会作为组件类，并告知Spring要为这个类创建bean,前提是要启动扫描器</span></span><br><span class="line"><span class="comment">     * Spring应用上下文中所有的bean都会给定一个ID:将类名的第一个字母变为小写,即sgtPeppers</span></span><br><span class="line"><span class="comment">     * 自定义指定bean的Id:<span class="doctag">@Component</span>(idName)</span></span><br><span class="line"><span class="comment">     * 也可以通过<span class="doctag">@Named</span>注解来为bean设置ID,但是命名不好,不推荐使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;playing %s by %s&quot;</span>,title,artist));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动装配(autowiring):Spring自动满足bean之间的依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动spring测试类测试</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CDPlayerConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringJUnit4ClassRunner:在测试开始的时候自动创建Spring的应用上下文</span></span><br><span class="line"><span class="comment">     * 注解<span class="doctag">@ContextConfiguration</span>:告诉它需要在CDPlayerConfig中加载配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Autowired</span>:自动装配依赖的bean,即Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在 Spring应用上下文中寻找匹配某个bean需求的其他bean</span></span><br><span class="line"><span class="comment">     * 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将<span class="doctag">@Autowired</span>的required属性设置为false</span></span><br><span class="line"><span class="comment">     * 如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪 个bean进行自动装配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc compactDisc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer cdPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompactDiscNotNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(compactDisc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基于Java显式的配置"><a href="#基于Java显式的配置" class="headerlink" title="基于Java显式的配置"></a>基于Java显式的配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CDPlayer.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;CompactDisc.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ComponentScan</span>:注解能够在Spring中启用组件扫描,默认会扫描与配置类相同的包,即会扫描这个包以及这个包下的所有子包,查找带有<span class="doctag">@Component</span>注解的类</span></span><br><span class="line"><span class="comment">     * 为何设置基础包:有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开</span></span><br><span class="line"><span class="comment">     * 使用String设置组件扫描的基础包:</span></span><br><span class="line"><span class="comment">     *      单个:basePackages = &quot;com.dtrees.spring.bean&quot;</span></span><br><span class="line"><span class="comment">     *      多个:basePackages = &#123;&quot;com.dtrees.spring.bean&quot;,&quot;com.dtrees.spring.bean2&quot;,...&#125;</span></span><br><span class="line"><span class="comment">     * 使用Class来设置组件扫描的基础包(推荐):</span></span><br><span class="line"><span class="comment">     *      basePackageClasses = &#123;&#125;,basePackageClasses属性所设置的数组中包含了类,这些类所在的包将会作为组件扫描的基础包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明简单的bean并指定bean的id名称</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sgtPeppers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">getCompactDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java配置和xml配置混合"><a href="#Java配置和xml配置混合" class="headerlink" title="Java配置和xml配置混合"></a>Java配置和xml配置混合</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;compactDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dtrees.spring.bean.SgtPeppers&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//beans.xml在maven项目的resources目录</span></span><br><span class="line"><span class="meta">@Import(CDConfig.class)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Import</span>(&#123;&#125;):将多个配置类进行组合一起</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ImportResource</span>(&quot;classpath:beans.xml&quot;):将spring配置的xml组合在一起</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;cdPlayer&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MediaPlayer <span class="title">getMediaPlayer</span><span class="params">(CompactDisc compactDisc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="spring装配的命名空间"><a href="#spring装配的命名空间" class="headerlink" title="spring装配的命名空间"></a>spring装配的命名空间</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">## 开头省略...</span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">c-命名空间来声明构造器参数</span></span><br><span class="line"><span class="comment">beans.xml中必须引入xmlns:c=&quot;http://www.springframework.org/schema/c&quot;的声明</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用命名</span></span><br><span class="line"><span class="comment">        c:compactDisc-ref=&quot;sgtPeppers1&quot;</span></span><br><span class="line"><span class="comment">        属性名称c:命名空间的前缀</span></span><br><span class="line"><span class="comment">        compactDisc:装配的构造器参数名</span></span><br><span class="line"><span class="comment">        -ref:这是一个命名的约定,它会告诉Spring,正在装配的是一个bean的引用,这个bean的名字是compactDisc,而不是字面量“compactDisc”</span></span><br><span class="line"><span class="comment">        sgtPeppers1:要注入的bean的ID名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayer2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dtrees.spring.bean.CDPlayer&quot;</span> <span class="attr">c:compactDisc-ref</span>=<span class="string">&quot;sgtPeppers1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用属性的命名空间"><a href="#使用属性的命名空间" class="headerlink" title="使用属性的命名空间"></a>使用属性的命名空间</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用属性命名空间（p-命名空间的属性）:</span></span><br><span class="line"><span class="comment">        p:title-ref=&quot;title-ref&quot;</span></span><br><span class="line"><span class="comment">        属性的名字使用了“p:”前缀，表明我们所设置的是一个属性</span></span><br><span class="line"><span class="comment">        &quot;title&quot;:接下来就是要注入的属性名。</span></span><br><span class="line"><span class="comment">        -ref:这会提示Spring要进行装配的是引用，而不是字面量</span></span><br><span class="line"><span class="comment">        title-ref:要注入的bean的ID名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">// 引入属性的命名空间xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">//设置字面值</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;compactDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dtrees.spring.bean.SgtPeppers&quot;</span> <span class="attr">p:title</span>=<span class="string">&quot;xxx value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 设置引用</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;compactDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dtrees.spring.bean.SgtPeppers&quot;</span> <span class="attr">p:title-ref</span>=<span class="string">&quot;title-ref&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>小结：c与p的命名空间，在装配bean引用与装配字面量的唯一区别在于是否带有“-ref”后缀，如果没 有“-ref”后缀的话，所装配的就是字面量</strong></p>
<h5 id="bean的注入方式-这里只用JavaConfig注入方式，不用xml配置"><a href="#bean的注入方式-这里只用JavaConfig注入方式，不用xml配置" class="headerlink" title="bean的注入方式(这里只用JavaConfig注入方式，不用xml配置)"></a>bean的注入方式(这里只用JavaConfig注入方式，不用xml配置)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CompactDisc compactDisc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造器自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc compactDisc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compactDisc = compactDisc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过设置器自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompactDisc</span><span class="params">(CompactDisc compactDisc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compactDisc = compactDisc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertCompactDisc</span><span class="params">(CompactDisc compactDisc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compactDisc = compactDisc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">getCompactDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.compactDisc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring小结(3)</title>
    <url>/2019/07/24/spring3/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="Spring面向切面AOP编程"><a href="#Spring面向切面AOP编程" class="headerlink" title="Spring面向切面AOP编程"></a>Spring面向切面AOP编程</h5><h6 id="1-AOP编程原理"><a href="#1-AOP编程原理" class="headerlink" title="1. AOP编程原理"></a>1. AOP编程原理</h6><blockquote>
<p>使用背景</p>
</blockquote>
<ul>
<li>需要在原有的应用功能模块增加额外的辅助功能,但并不是所有的应用功能模块所必需的</li>
<li>使用面向对象继承或者依赖技术增加辅助功能,会导致部分甚至所有的应用功能模块声明的类都会与辅助功能类在代码上存在耦合关系</li>
<li>使用代理委托方式,存在对委托对象进行复杂调用,容易导致原来的功能模块出现问题</li>
</ul>
<blockquote>
<p>AOP切面作用</p>
</blockquote>
<ul>
<li>可以将上述增加辅助功能的问题转换为一个特殊类,集中处理,无须分散到各处的应用模块中</li>
<li>当前的特殊类只关注该辅助功能的实现,更为集中也便于维护</li>
</ul>
<blockquote>
<p>AOP原理</p>
</blockquote>
<p><strong>AOP可以比喻为我们要完成的一项任务工作, 一般做任何一项任务都具备目标,任务分解以及利用现有的工具资源来帮助任务推进,简言之可以将AOP对应的概念理解如下</strong>:</p>
<ul>
<li>目标: 最终要完成任务的目标 – <strong>AOP的通知Advice,设定的程序目标</strong></li>
<li>工具: 完成一项任务的目标我们需要借助一项工具来帮助我们更有效地完成  –  <strong>AOP的连接点,提供信息/方法</strong></li>
<li>任务分解: 任务比较多的时候我们可以采用任务分解的方式来完成,将任务逐一划分为可执行的区域 – <strong>AOP的切点,类似任务分解的区域,也就是where</strong></li>
<li>最后,就是在做一项任务之前,我们都知道要完成这项任务的目标以及如何去划分任务,这个就是<strong>AOP的切面,包含了通知和切点,定义任务的全部内容(准确地说,还包含工具提供的信息在里面)</strong></li>
</ul>
<blockquote>
<p>AOP 术语</p>
</blockquote>
<ul>
<li>切面: 定义要完成一项任务的全部内容,即声明一个切面的类定义任务内容信息</li>
<li>通知: 定义要完成任务的目标,即在一个切面类下的目标方法<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
</li>
<li>切点: 定义要在什么地方执行,即在一个切面类下的目标方法中,告诉目标方法要在什么地方执行</li>
<li>连接点: 定义要完成任务的工具,即从程序角度而言,是利用应用程序中已有的功能为完成任务提供辅助,从我们定义的业务而言,是指我们原有的业务功能</li>
<li>引入: 在无须修改类的情况下, 向现有的业务功能的类添加方法或者属性, 让它们具有新的行为和状态</li>
<li>织入: 是把切面应用到目标对象并创建新的代理对象的过程.切面在指定的连接点被织入到目标对象中<ul>
<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的</li>
<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面</li>
</ul>
</li>
</ul>
<h6 id="2-AOP编程创建切面"><a href="#2-AOP编程创建切面" class="headerlink" title="2. AOP编程创建切面"></a>2. AOP编程创建切面</h6><blockquote>
<p>AOP 基于注解的方式  </p>
</blockquote>
<p> Spring AOP是基于方法去做增强,也就是在<strong>类或对象的方法上做增强,需要区分AOP引入</strong></p>
<ul>
<li>定义连接点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义连接点 -- 业务处理功能</span></span><br><span class="line"><span class="comment"> * 项目是基于SpringBoot</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// AnnPerformance.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnPerformance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类AnnPerformanceImpl.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnPerformanceImpl</span> <span class="keyword">implements</span> <span class="title">AnnPerformance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AnnPerformanceImpl performance ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义切面<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnAudience.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用注解定义一个切面类，包含定义通知以及切点，使用注解的切面声明必须能够为通知类添加注解，为此要做到这点，必须有源码</span></span><br><span class="line"><span class="comment"> * 使用原则，基于注解的配置优于Java的配置，基于Java的配置优于xml的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> 使用该注解，Spring会动态为该Bean以及对应的目标bean创建代理对象，通过代理对象来实现目标，也就是通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnAudience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AnnAudience.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xiaokunliu.study.springinaction.aop.annotation.AnnPerformance.perform(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法内容并不重要，只是作为注解的附体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义通知方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;perform()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;silencing cell phones ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;perform()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;taking seats ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;perform()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;applause ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;perform()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demand refund ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;perform()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;silencing cell phones ....&quot;</span>);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;taking seats ....&quot;</span>);</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">            LOGGER.info(<span class="string">&quot;demand refund ..... &quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;catching error from watchPerformance,messages=%s&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="comment">//demandRefund();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>定义配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnConcertConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>    <span class="comment">// 启动AspectJ自动代理</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.xiaokunliu.study.springinaction.aop.annotation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnConcertConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnAudience <span class="title">audience</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnAudience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写单元测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestAnnAop.java</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = AnnConcertConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnnPerformance annPerformance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(annPerformance.getClass());</span><br><span class="line">        <span class="comment">// 运行结果: class com.sun.proxy.$Proxy26</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>AOP 注解注入参数定义切面<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义另一个切面来处理方法调用的统计</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTrackCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理通知中的参数</span></span><br><span class="line"><span class="comment">     * 目标： 需要记录每个磁道被播放的次数，此时需要将记录被播放的次数与播放本身分离出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; trackedCounters = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xiaokunliu.study.springinaction.aop.annotation.AopCompactDisc.play(java.lang.String)) &amp;&amp; args(trackedNumber)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackedPlay</span><span class="params">(String trackedNumber)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;trackedPlay(trackedNumber)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countTracked</span><span class="params">(String trackerNumberKey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = getCountTrack(trackerNumberKey);</span><br><span class="line">        trackedCounters.put(trackerNumberKey, counter + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取根据trackerNumberKey统计数据</span></span><br><span class="line">	<span class="comment">// 每一个方法对应一个key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCountTrack</span><span class="params">(String trackerNumberKey)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.8 版本 Map.getOrDefault</span></span><br><span class="line">        <span class="keyword">return</span> trackedCounters.getOrDefault(trackerNumberKey, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>AOP注解注入参数定义连接点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AopCompactDisc.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopCompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(String trackedNumber)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AopBlankDisc.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopBlankDisc</span> <span class="keyword">implements</span> <span class="title">AopCompactDisc</span> </span>&#123;</span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String trackNumberKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(trackNumberKey + <span class="string">&quot; AOP AopBlankDisc play .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注入参数单元测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = AnnConcertConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspectAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopCompactDisc aopCompactDisc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopTrackCounter trackCounter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTrackCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(aopCompactDisc.getClass());</span><br><span class="line">        String trackNumber = <span class="string">&quot;com.xiaokunliu.study.springinaction.aop.TestAspectAop.testTrackCounter&quot;</span>;</span><br><span class="line">        aopCompactDisc.play(trackNumber);   <span class="comment">// 3</span></span><br><span class="line">        System.out.println(trackCounter.getCountTrack(trackNumber)); <span class="comment">//4</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 重复3,4代码</span></span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
<li>运行结果<br><img src="https://img-blog.csdnimg.cn/20190924131341971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>AOP 注解引入,即切面能够为<strong>现有的对象或者类</strong>增加新的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如现在需要为现有的类或者对象增加监控的方法</span></span><br><span class="line"><span class="comment">// 定义一个监控的接口以及对应的实现类处理监控 -- 注意只是处理监控相关的,和Performance没有关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这个接口的调用应用到Performance实现中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performMonitor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnDefaultMonitor</span> <span class="keyword">implements</span> <span class="title">AnnMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理监控的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AnnDefaultMonitor performMonitor ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义监控的切面<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnMonitorAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents(value = &quot;com.xiaokunliu.study.springinaction.aop.annotation.AnnPerformance+&quot;, defaultImpl = AnnDefaultMonitor.class)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AnnMonitor monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>单元测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = AnnConcertConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnnPerformance annPerformance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnnMonitor monitor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(annPerformance.getClass());</span><br><span class="line">        System.out.println(monitor.getClass());</span><br><span class="line">        System.out.println(monitor.getClass() == annPerformance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行结果<br><img src="https://img-blog.csdnimg.cn/2019092414043748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>AOP引入可以用下图表示(引入Spring实战的图片)<br><img src="https://img-blog.csdnimg.cn/20190924140543762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbmRfNjAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote>
<p>AOP 基于xml声明式</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// java 代码省略,基本与上述一致,这里仅做xml相关的配置</span><br><span class="line">// bean_aop.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--AOP 基于Xml配置, 自动扫描指定的包目录下的java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明面向切面，与注解@EnableAspectJAutoProxy对应,启动AspectJ自动代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明需要的bean</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aopPerformance&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopPerformanceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明切面为一个bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopAudience&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        定义spring配置的切面</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  切点 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;performance&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xiaokunliu.study.springinaction.aop.xml.AopPerformance.perform(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通知方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;silenceCellPhones&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;takeSeats&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;demandRefund&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 声明环绕通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;watchPerformance&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        AOP 传递通知参数</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义切面bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aopBlankDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopBlankDisc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tracker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopTrackCounter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           注意参数名称要方法名称对应上去</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;tracker&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;tracker_performance&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xiaokunliu.study.springinaction.aop.xml.AopCompactDisc.play(java.lang.String)) and args(trackedNumber)&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;trackedPlay&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;tracker_performance&quot;</span> <span class="attr">arg-names</span>=<span class="string">&quot;trackedNumber&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        AOP 引入新的功能</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopPerformance+&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">implement-interface</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopMonitor&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">default-impl</span>=<span class="string">&quot;com.xiaokunliu.study.springinaction.aop.xml.AopDefaultMonitor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>基于SpringBoot定义配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;classpath:spring/beans_aop.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>单元测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = AopConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspectXml</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopPerformance annPerformance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopMonitor monitor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopCompactDisc aopCompactDisc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopTrackCounter trackCounter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 运行结果如下:</span></span><br><span class="line">    	<span class="comment">//  class com.sun.proxy.$Proxy20</span></span><br><span class="line">		<span class="comment">//  class com.sun.proxy.$Proxy20</span></span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">      	System.out.println(annPerformance.getClass());</span><br><span class="line">        System.out.println(monitor.getClass());</span><br><span class="line">        System.out.println(monitor.getClass() == annPerformance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTrackCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 执行结果如下:</span></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	*	class com.sun.proxy.$Proxy21</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			1</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			2</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			3</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			4</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			5</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			6</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			7</span></span><br><span class="line"><span class="comment">			trackingNumber AOP AopBlankDisc play .... </span></span><br><span class="line"><span class="comment">			8</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        System.out.println(aopCompactDisc.getClass());</span><br><span class="line">        String trackNumber = <span class="string">&quot;trackingNumber&quot;</span>;</span><br><span class="line">        aopCompactDisc.play(trackNumber);		<span class="comment">// 2</span></span><br><span class="line">        System.out.println(trackCounter.getCountTrack(trackNumber)); <span class="comment">//3</span></span><br><span class="line">		<span class="comment">// 重复2,3代码 ... </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring技术小结</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试的编写与自动化</title>
    <url>/2020/05/27/junit/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="单元测试的编写与自动化"><a href="#单元测试的编写与自动化" class="headerlink" title="单元测试的编写与自动化"></a>单元测试的编写与自动化</h3><h4 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h4><blockquote>
<p>单元测试属性概念</p>
</blockquote>
<p>单元测试可以理解为当一个开发人员开发一个class类或者是新增加已有的class类下的功能方法时,那么这个开发人员就需要对新开发的class类或者是class类下的功能实现的方法负责,保证实现的功能可以满足需求且能够正常运行交付,因此为了达到上述的目标,我们需要对class类或class类下的方法进行单元测试,那么对于一个单元测试具备的属性主要包含如下:</p>
<ul>
<li><strong>单元</strong>是软件系统组成的一个最小单位.</li>
<li>满足输入,计算处理,输出三个核心步骤,即我们需要定义输入的信息,通过程序的加工计算处理(也就是我们实现的代码程序),输出就是返回处理结果,测试本身是对于返回的处理结果进行重复验证,保证其正确率不低于我们预设的一个阀值百分比.</li>
<li>由单一的开发人员负责完成交付,实现的功能规模小,逻辑简单且相互独立, 能够更容易实现程序完整功能的集成.</li>
</ul>
<blockquote>
<p>单元测试作用</p>
</blockquote>
<p>在极限编程的TDD流程中,驱动流程前进的开发周期称为“红灯-绿灯-重构”,其中红绿灯体现一个单元测试的失败与成功标识,红灯代表处于说明测试不通过需要被修复或者正处于编写测试状态,绿灯代表实现的功能全部测试通过.TDD流程可以根据红绿灯显示的状态结果来不断重复优化我们的程序代码,对此单元测试对于软件系统,开发人员具备有以下的意义:</p>
<ul>
<li>对于开发人员而言,由于测试规模小且功能独立,因而在不需要考虑外部因素引入的情况下,能够通过单元测试快速定位错误并实现程序代码不断迭代优化,促使测试状态变更为绿灯状态.</li>
<li>对于软件系统而言,由于功能独立且规模小,那么在系统功能集成之前(尤其是大型软件系统)进行单元测试有助于提升系统功能实现的正确率,缩小排查异常的范围以及消耗的时间,提升需求功能实现的交付速度.</li>
</ul>
<h4 id="单元测试的工具使用"><a href="#单元测试的工具使用" class="headerlink" title="单元测试的工具使用"></a>单元测试的工具使用</h4><p>通过上述我们已经了解到单元测试的重要意义,基于单元测试的属性特征,进行单元测试的成本并不高,为了响应快速交付的目标,接下来讲述如何实现利用好工具进行单元测试.</p>
<ul>
<li>git在开发中的使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 先在github上fork下</span></span><br><span class="line"><span class="comment">## 拉取项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yourGithubId/boat-house.git</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置同步远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote add upstream https://github.com/idcf-boat-house/boat-house.git</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更新到本地</span></span><br><span class="line">git fetch upstream &amp;&amp; git checkout master &amp;&amp; git pull &amp;&amp; git merge upstream/master</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开发需求</span></span><br><span class="line"><span class="comment">## 基于小组owner成员的master</span></span><br><span class="line">git checkout master &amp;&amp; git pull &amp;&amp; git checkout -b feature-xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 完成需求的开发</span></span><br><span class="line">git pull &amp;&amp; git add files &amp;&amp; git commit -m <span class="string">&quot;add feature xxx&quot;</span> &amp;&amp; git push origin feature-xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 完成功能验证通过之后在github提PR合并到boat-house的master分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 完成PR提交到小组owner的master</span></span><br><span class="line">git checkout master &amp;&amp; git pull &amp;&amp; git merge feature-xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 有冲突修复然后提交</span></span><br><span class="line">git pull &amp;&amp; git add confilctfiles &amp;&amp; git commit -m <span class="string">&quot;fixing conflict&quot;</span> &amp;&amp; git push origin master</span><br></pre></td></tr></table></figure>

<ul>
<li>git使用细节(结合idea)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-git-use1.jpg"></p>
<p>提交的时候上面有四个细节,一个是填写开发者名称以及邮件,一般就是name <email>, 第二个就是右边的勾选项,会对我们编写的代码做一些格式优化调整与检查,第三个就是填提交信息一般是简述自己做的事情,最后一个的话,很重要就是提交之前要review自己的代码,避免引入一些无关的代码,比如下面:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-git-use2.jpg"></p>
<p>很有可能自己提交之前将英文逗号给改成中文逗号,但是自己没有检查就会报错.review的好处就是避免多次提交同时减少自己在一些可避免的错误上浪费时间.</p>
<ul>
<li>maven在开发中使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## maven其他命令请参考相关资源</span></span><br><span class="line"><span class="comment">## 使用脚手架进行快速构建项目</span></span><br><span class="line"><span class="built_in">cd</span> /path/project</span><br><span class="line">mvn archetype:create-from-project</span><br><span class="line"><span class="built_in">cd</span> /target/generated-sources/archetype</span><br><span class="line">mvn install</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从构建的脚手架快速项目</span></span><br><span class="line">mvn archetype:generate -DarchetypeCatalog=<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## maven的打包测试</span></span><br><span class="line"><span class="comment">## -Dmaven.test.failure.ignore=true表示单元测试失败仍然不影响打包</span></span><br><span class="line"><span class="comment">## -Dmaven.test.skip=true表示跳过单元测试</span></span><br><span class="line"><span class="comment">## -Pdev dev表示maven传递激活的环境</span></span><br><span class="line">mvn clean package -Dmaven.test.failure.ignore=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>idea使用</li>
</ul>
<p>打开idea的Preferences,搜索templates,找到File And Code Templates栏目,点击该栏目找到右侧的Junit4Class的模板配置,可以根据个人情况进行配置.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-idea-config.png" alt="image-20200417142513605"></p>
<p>可以为本地的模板配置为一个基本SpringBoot的测试模板样例,如下模板代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置Junit4 Test Class模板</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * date:$&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"> * author: authorName   ## 开发者名称</span></span><br><span class="line"><span class="comment"> * desc: junit4 test case for $&#123;NAME&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#parse(<span class="string">&quot;File Header.java&quot;</span>)</span><br><span class="line"><span class="comment">//@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration()</span></span><br><span class="line"><span class="comment">//@ActiveProfiles(&quot;dev&quot;) </span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $</span>&#123;NAME&#125; &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 这个方法仅在初始化的时候执行一次</span></span><br><span class="line">        $&#123;BODY&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这个方法在所有测试完成之后会执行一次</span></span><br><span class="line">        $&#123;BODY&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    $&#123;BODY&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置Junit Test Method 模板</span></span><br><span class="line"><span class="comment">// 测试方法名称为testMethodName</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test$&#123;NAME&#125;() &#123;</span><br><span class="line">   $&#123;BODY&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用IDEA快速创建一个单元测试类</li>
</ul>
<p>选中被测试的类,右键Go To -&gt; Test (同时可以把快捷键记住)</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-idea-create1.png" alt="boathouse-structure-junit-idea-create1"></p>
<p>这个时候弹出框构建单元测试类,选择Junit4的测试类库,同时按照上述规范命名测试类名称,最后根据实际需求情况勾选要进行单元测试的方法以及对应的setUp和tearDown方法,同时注意生成的测试类存放的包目录,一般情况下只需要勾选要进行测试的方法即可.</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-idea-create2.png" alt="boathouse-structure-junit-idea-create2"></p>
<p>最后就生成一个基于模板配置好的单元测试类并编写一个单元测试用例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration()</span></span><br><span class="line"><span class="comment">//@ActiveProfiles(&quot;dev&quot;)   // 使用dev环境进行测试</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtilsTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindModeResult</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java Code Coverage测试覆盖率测量工具(可选)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- maven 配置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.jacoco.agent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- maven plugin插件配置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置jacoco插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rule</span> <span class="attr">implementation</span>=<span class="string">&quot;org.jacoco.maven.RuleConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">element</span>&gt;</span>BUNDLE<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">limits</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 指定方法覆盖50% --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">limit</span> <span class="attr">implementation</span>=<span class="string">&quot;org.jacoco.report.check.Limit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">counter</span>&gt;</span>METHOD<span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>COVEREDRATIO<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">minimum</span>&gt;</span>0.50<span class="tag">&lt;/<span class="name">minimum</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">limit</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 指定分支覆盖到50% --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">limit</span> <span class="attr">implementation</span>=<span class="string">&quot;org.jacoco.report.check.Limit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">counter</span>&gt;</span>BRANCH<span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>COVEREDRATIO<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">minimum</span>&gt;</span>0.50<span class="tag">&lt;/<span class="name">minimum</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">limit</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 指定CLASS覆盖100% --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">limit</span> <span class="attr">implementation</span>=<span class="string">&quot;org.jacoco.report.check.Limit&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">counter</span>&gt;</span>CLASS<span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>MISSEDCOUNT<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maximum</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maximum</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">limit</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">limits</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre-test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  生成数据报告文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destFile</span>&gt;</span>$&#123;project.build.directory&#125;/coverage-reports/jacoco-it.exec<span class="tag">&lt;/<span class="name">destFile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>check<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 测试阶段输出覆盖率报告 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>post-test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  读取数据报告文件,打印测试覆盖率报告文件并以html展示 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dataFile</span>&gt;</span>$&#123;project.build.directory&#125;/coverage-reports/jacoco-it.exec<span class="tag">&lt;/<span class="name">dataFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.reporting.outputDirectory&#125;/jacoco-it<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述配置之后,根据maven构建的生命周期,可以直接执行test之后(包含test)命令将输出测试覆盖率报告,即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 执行测试</span></span><br><span class="line">mvn clean <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试报告输出路径</span></span><br><span class="line">/path/project/target/site/jacoco-it</span><br><span class="line"></span><br><span class="line"><span class="comment">## 比如找到下面的路径的html(这个是我本地)</span></span><br><span class="line">/home/idcf-house/boat-house/product-service/api/target/site/jacoco-it</span><br></pre></td></tr></table></figure>

<p>打开输出目录的index.html查看执行覆盖率报告结果:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-javacoco-report.png" alt="boathouse-structure-junit-javacoco-report"></p>
<p>通过上述报告结果,说明当前进行单元测试的覆盖率只有2%,开发人员需要重新审核自身编写的测试代码情况,即是否测试全面.</p>
<ul>
<li>模拟框架(可选)</li>
</ul>
<p>当我们需要使用到第三方依赖接口或者是外部资源的时候,为了方便我们能够进行正常测试,在这里需要引入框架来解决依赖的外部资源,其中模拟框架有:</p>
<ol>
<li><p>Mockito: 官网地址, <a href="https://site.mockito.org/">https://site.mockito.org/</a></p>
</li>
<li><p>EasyMock: 官网地址, <a href="https://easymock.org/">https://easymock.org/</a></p>
</li>
<li><p>PowerMock: 这个主要是针对上述两者之一存在无法提供模拟部分特殊类或者方法或者字段支持,是一个功能更为全面且提供模拟测试对象的框架,同时使用到这个框架也意味着开发人员的代码很可能会存在一些不足,需要有其他开发人员协助审查代码质量,更多详细的信息可查阅github学习,<a href="https://github.com/powermock/powermock">https://github.com/powermock/powermock</a></p>
</li>
</ol>
<h4 id="Junit框架简介"><a href="#Junit框架简介" class="headerlink" title="Junit框架简介"></a>Junit框架简介</h4><ul>
<li>单元测试框架类图结构设计</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-Class.png" alt="boathouse-structure-junit-Class"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Assert: 负责对单元测试结果进行校验</span></span><br><span class="line"><span class="comment">// TestResult: 单元测试输出结果</span></span><br><span class="line"><span class="comment">// TestCase: 开发人员编写的单元测试用例</span></span><br><span class="line"><span class="comment">// TestSuite: 测试集,相对地,如果添加一个单元测试类,则存在在同一个包下的所有单元测试类组成一个单元测试集合,如果是添加一个测试方法,则将所有方法存放在同一个类下组成的一个单元测试类也可以称为一个测试集</span></span><br><span class="line"><span class="comment">// Test: Junit框架提供测试接口</span></span><br><span class="line"><span class="comment">// TestRunner: 如果一个单元测试集(类)添加TestRunner/RunWith,如RunWith(SpringJUnit4ClassRunner.class),说明当前测试集/类/方法引入Spring相关的功能进行单元测试.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Junit框架说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@BeforeClass</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 在执行测试类中进行初始化操作,整个过程仅执行一次且声明为static</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 在每次测试用例执行之前的操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Ignore</span>  <span class="comment">// 忽略当前的测试用例</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 执行测试用例</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@After</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 在每次测试用例执行完成之后的后续操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@AfterClass</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在所有测试用例执行完成之后的后续操作,整个过程只执行一次且声明为静态static</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>junit框架额外知识(可选)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @FixMethodOrder: 决定单元测试方法的执行顺序,顺序规则有以下三种:</span></span><br><span class="line"><span class="comment">// MethodSorters.DEFAULT: 使用方法名称的hashcode的顺序执行测试用例</span></span><br><span class="line"><span class="comment">// MethodSorters.NAME_ASCENDING: 使用方法名称顺序执行测试用例</span></span><br><span class="line"><span class="comment">// MethodSorters.JVM: 使用JVM返回的方法名称顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试之参数化</span></span><br><span class="line"><span class="comment">// 声明处于参数化环境</span></span><br><span class="line"><span class="meta">@RunWith(Parameterized.class)</span></span><br><span class="line"><span class="meta">@FixMethodOrder(MethodSorters.DEFAULT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterClassTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造参数化数据</span></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; data() &#123;</span><br><span class="line">      <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始测试用例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单元测试实践"><a href="#单元测试实践" class="headerlink" title="单元测试实践"></a>单元测试实践</h4><p>在进行单元测试实践之前,我们需要先了解下单元测试的准则与规范</p>
<ul>
<li>单元测试准则: <a href="https://petroware.no/unittesting.html">参考准则英文版</a>  、<a href="https://github.com/yangyubo/zh-unit-testing-guidelines/blob/master/readme.rst">参考准则中文版</a></li>
<li>单元测试规范</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命名规范: 可以通过上述定义模板来自动生成</span><br><span class="line">1. 测试类名称: ClassNameTest,即在原有的类中添加Test表示要进行单元测试的测试类</span><br><span class="line">2. 方法名称:  @BeforeClass对应的方法名称为init,表示初始化操作.</span><br><span class="line">             @AfterClass对应的方法名称为release,表示执行完所有测试用例之后要释放资源</span><br><span class="line">             @Before对应的方法名称为setUp,@After对应方法名称为tearDown</span><br><span class="line">             @Test对应的测试用例方法名称为testMethodName</span><br><span class="line">3. 单元测试集: 存放单元测试的测试类的包命名规范与被测试的类所处的包目录结构一致,如</span><br><span class="line">java/</span><br><span class="line">	com.idcf.boathouse.mapper.OrderMapper</span><br><span class="line">test/</span><br><span class="line">	com.idcf.boathouse.mapper.OrderMapperTest</span><br></pre></td></tr></table></figure>

<ul>
<li>基于需求的单元测试实践</li>
</ul>
<p>以订单需求为例,现在的需求是开发一个商家接单的功能,对于一个订单的基本流程有: 下单 - 支付  -  接单  -  确认订单  -  订单完成等流程,因此对商家接单功能进行单元测试实践如下:</p>
<ol>
<li>第一步是编写单元测试用例.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdersMapperTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//由于mapper还没有实现,对此使用Mock框架模拟实现</span></span><br><span class="line">   <span class="comment">// 1. 这个时候还没有定义OrdersMapper,显示红灯,未定义错误</span></span><br><span class="line">   <span class="comment">// 2. 编写测试用例完成之后再定义OrdersMapper,定义并修复红灯</span></span><br><span class="line">   <span class="meta">@Mock</span></span><br><span class="line">   <span class="keyword">private</span> OrdersMapper ordersMapper;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在每个测试方法之前都会执行</span></span><br><span class="line">        <span class="comment">//进行初始化操作</span></span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这个方法每个测试方法执行之后都会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfirmOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">     	<span class="comment">// 商家接单,首先我需要有查询一个已支付的订单信息,于是在接口还没有进行完成开发之前,使用Mock进行模拟</span></span><br><span class="line">      String orderId = <span class="string">&quot;20200429143906111&quot;</span>;</span><br><span class="line">      Mockito.when(ordersMapper.selectByOrderId(orderId)).then(<span class="keyword">new</span> Answer&lt;Orders&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Orders <span class="title">answer</span><span class="params">(InvocationOnMock invocationOnMock)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          Orders orders = <span class="keyword">new</span> Orders();</span><br><span class="line">          orders.setId(invocationOnMock.getArgument(<span class="number">0</span>, Integer.class));</span><br><span class="line">          orders.setOrderStatus(OrderStatusEnum.OrderWaitHandle.getValue());   <span class="comment">//已支付待受理状态</span></span><br><span class="line">          <span class="keyword">return</span> orders;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行查询并验证查询结果</span></span><br><span class="line">        Orders orders = ordersMapper.selectByOrderId(orderId);</span><br><span class="line">        Assert.assertEquals(orderId, orders.getOrderId());</span><br><span class="line">        Assert.assertEquals(OrderStatusEnum.OrderWaitHandle.getValue(), orders.getOrderStatus());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 满足上述的条件之后，接下来我们需要进行商家接单操作</span></span><br><span class="line">        orders.setOrderStatus(OrderStatusEnum.OrderHandling.getValue());</span><br><span class="line">        Mockito.when(ordersMapper.confirmOrder(orders)).thenReturn(<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 执行接单操作并验证</span></span><br><span class="line">        <span class="keyword">int</span> res = ordersMapper.confirmOrder(orders);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, res);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 根据orderId查询订单验证订单状态</span></span><br><span class="line">       Mockito.when(ordersMapper.selectByOrderId(orderId)).then(<span class="keyword">new</span> Answer&lt;Orders&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Orders <span class="title">answer</span><span class="params">(InvocationOnMock invocationOnMock)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          Orders orders = <span class="keyword">new</span> Orders();</span><br><span class="line">          orders.setId(invocationOnMock.getArgument(<span class="number">0</span>, Integer.class));</span><br><span class="line">          orders.setOrderStatus(OrderStatusEnum.OrderHandling.getValue());   <span class="comment">//已接单状态</span></span><br><span class="line">          <span class="keyword">return</span> orders;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 验证订单状态</span></span><br><span class="line">      Orders orders = ordersMapper.selectByOrderId(orderId);</span><br><span class="line">      Assert.assertEquals(OrderStatusEnum.OrderHandling.getValue(), orders.getOrderStatus());</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 再次执行接单操作,这个时候测试结果应该是失败,已经执行过一次,需要保证幂等</span></span><br><span class="line">         Mockito.when(ordersMapper.confirmOrder(orders)).thenReturn(<span class="number">0</span>);</span><br><span class="line">         res = ordersMapper.confirmOrder(orders);</span><br><span class="line">         Assert.assertEquals(<span class="number">0</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>优化代码并将红灯显示区域修复,运行单元测试用例并促使其出现绿灯,保证当前单元测试是成功的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如上述还没有定义接口OrdersMapper,那么这个时候就需要先定义出OrdersMapper的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrdersMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Orders</span>&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Orders <span class="title">selectByOrderId</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">confirmOrder</span><span class="params">(Orders orders)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>当接口开发完成之后,我们根据上述的单元测试用例注释掉Mock数据,基于Spring的配置进行加载并对接口功能进行单元测试.</p>
</li>
<li><p>最后通过单元测试报告来优化功能代码,驱使一个接单功能的实现能够符合预期的业务需求目标.</p>
</li>
</ol>
<p>更多关于单元测试实践参考如下:</p>
<ul>
<li><p><a href="https://phauer.com/2019/modern-best-practices-testing-java/">Modern Best Practices for Testing in Java</a></p>
</li>
<li><p><a href="https://dzone.com/articles/7-tips-for-writing-better-unit-tests-in-java">7-tips-for-writing-better-unit-tests-in-java</a></p>
</li>
<li><p><a href="https://dzone.com/articles/java-unit-testing-best-practices-how-to-get-the-mo">Java Unit Testing Best Practices</a></p>
</li>
<li><p><a href="https://dzone.com/articles/unit-level-performance-testing-in-java">Unit-Level Performance Testing in Java</a></p>
</li>
</ul>
<h4 id="Jenkins构建自动化单元测试"><a href="#Jenkins构建自动化单元测试" class="headerlink" title="Jenkins构建自动化单元测试"></a>Jenkins构建自动化单元测试</h4><ul>
<li>单元测试自动化</li>
</ul>
<ol>
<li>使用docker-compose的方式对项目进行构建,即docker-compse-build.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">product-service-api-ci:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">maven:3.5.2-jdk-8-alpine</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/build</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/build</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">&quot;mvn package &amp;&amp; mvn cobertura:cobertura&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据maven的构建的生命周期,在进行maven打包的时候会执行当前项目下的单元测试类,直接通过docker compose up启动构建服务,至此在流水线上就可以看到Jenkins构建单元测试输出结果:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-jenkins-test.jpg" alt="boathouse-structure-junit-jenkins-test"></p>
<ol start="3">
<li>Jenkins安装Html Publisher插件输出单元测试报告</li>
</ol>
<p>打开Jenkins界面,在基于流水线的构建基础下,点击进入左侧的Manage Jenkins(系统配置),找到插件管理并点击进入,点开可选插件面板,搜索html,如下界面:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-jenkins-search.jpg" alt="boathouse-structure-junit-jenkins-search"></p>
<p>这个时候点击直接安装即可(上述已经安装过插件).</p>
<ol start="3">
<li><p>需要在项目的pom文件进行配置,在上述单元测试的工具已经介绍并贴出相关的配置(Java Code Coverage)</p>
</li>
<li><p>根据上述的pom文件配置以及maven的插件,在执行构建打包的时候会输出Java Code Coverage的测试报告结果.只需要将报告结果export出来,即在JenkinsFile的构建步骤中增加输出报告的结果,即如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## product-service项目使用maven进行构建输出报告目录: ./product-service/api/target/site/jacoco-it</span></span><br><span class="line"><span class="comment">## 在JenkinsFile下的构建build-product-service的步骤最后增加以下命令即可</span></span><br><span class="line">publishHTML([allowMissing: <span class="literal">false</span>, alwaysLinkToLastBuild: <span class="literal">false</span>, keepAll: <span class="literal">true</span>, reportDir: <span class="string">&#x27;./product-service/api/target/site/jacoco-it&#x27;</span>, reportFiles: <span class="string">&#x27;index.html&#x27;</span>, reportName: <span class="string">&#x27;Junit Report&#x27;</span>, reportTitles: <span class="string">&#x27;&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>最后只需要在Jenkins上构建流水线,等待单元测试报告的结果输出即可,如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-jenkins-report1.jpg" alt="boathouse-structure-junit-jenkins-report1"></p>
<p>然后在当前界面的右上角点击“制品”Tab,显示如下:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-jenkins-report2.jpg" alt="boathouse-structure-junit-jenkins-report2"></p>
<p>点击上述的Junit Report即可显示单元测试输出报告,即:</p>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/junit/boathouse-structure-junit-jenkins-report3.jpg" alt="boathouse-structure-junit-jenkins-report3"></p>
]]></content>
      <categories>
        <category>tdd</category>
      </categories>
      <tags>
        <tag>TDD驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title>git发版使用</title>
    <url>/2019/04/02/git/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="使用git打包发布版本"><a href="#使用git打包发布版本" class="headerlink" title="使用git打包发布版本"></a>使用git打包发布版本</h5><blockquote>
<p>拉取git项目的代码(仅执行一次)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取项目</span></span><br><span class="line">git <span class="built_in">clone</span> projects.git  <span class="comment"># url</span></span><br><span class="line"><span class="built_in">cd</span> projects</span><br><span class="line">git checkout master &amp;&amp; git pull</span><br><span class="line"><span class="comment"># 创建基于master的git flow的实例化操作</span></span><br><span class="line">git flow init -d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于develop分支进行发版</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取开发分支</span></span><br><span class="line">git checkout develop &amp;&amp; git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前项目的版本号(自定义于所属项目中),如</span></span><br><span class="line">projects/</span><br><span class="line">    projects/</span><br><span class="line">        __init__.py</span><br><span class="line">            __version__ = <span class="string">&quot;1.2.0&quot;</span></span><br><span class="line">            __release_date__ = <span class="string">&quot;2018-02-02&quot;</span></span><br><span class="line"><span class="comment"># 版本号规定为三位数字x.y.z</span></span><br><span class="line">    <span class="comment"># x表示为项目大的改动,比如重构,换新的技术等,在原有的基础递增</span></span><br><span class="line">    <span class="comment"># y表示在一个周期时间段内的版本发布,如每隔2周发布新的功能,在原有的基础递增</span></span><br><span class="line">    <span class="comment"># z可以表示紧急修复抑或是bug修复抑或功能上的改进等等,在原有的基础递增</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 基于当前的一个版本号,根据项目实际情况进行发版,比如现在是新功能发布,则版本号为1.3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前的release版本进行打包</span></span><br><span class="line">git flow release start 1.3.0  <span class="comment"># 此版本仅用于bug或者是功能上的修复,不做新功能的发布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改版本号以及changelog</span></span><br><span class="line"><span class="comment"># 将上述修正为</span></span><br><span class="line">__version__ = <span class="string">&quot;1.3.0&quot;</span></span><br><span class="line">__release_date__ = <span class="string">&quot;2018-02-06&quot;</span>   <span class="comment"># 以当前时间为准</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加修改的日志记录在changelog,添加的内容视团队以及项目规范而定</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git log查看上次打包以来的修改日志，对比CHANGELOG.txt中的是否有遗漏</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;tag&gt;..HEAD                  <span class="comment"># 获取某Tag以来的日志，如：git log 1.0.8..HEAD</span></span><br><span class="line">git <span class="built_in">log</span> --since=&lt;last-release-date&gt;  <span class="comment"># 获取某个时间以来的日志，如：git log --since=2015-01-14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将新建的release分支publish到服务器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add files   <span class="comment"># 本次发版修改的文件内容</span></span><br><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br><span class="line">git flow release publish 1.3.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通知团队其他可以签出该分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git flow release track 1.3.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行bug修复和提交</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase              <span class="comment"># 定期拉取别人提交的代码</span></span><br><span class="line">                                       <span class="comment"># 如果pull出现冲突，则解决冲突后git add xxx</span></span><br><span class="line">                                       <span class="comment"># 然后git rebase --continue继续操作。</span></span><br><span class="line"></span><br><span class="line">git status                     <span class="comment"># 查看有哪些文件修改</span></span><br><span class="line">git diff                       <span class="comment"># 查看具体修改内容</span></span><br><span class="line">git add xxx                    <span class="comment"># 添加准备提交的文件或文件夹</span></span><br><span class="line">git commit -m<span class="string">&quot;fix #xxx xxx&quot;</span>    <span class="comment"># 提交代码</span></span><br><span class="line"></span><br><span class="line">git push                       <span class="comment"># 定期将自己的代码推到服务器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将release分支合并到本地master和develop</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master &amp;&amp; git pull</span><br><span class="line">git checkout develop &amp;&amp; git pull</span><br><span class="line">git checkout release/1.3.0</span><br><span class="line">git pull &amp;&amp; git flow release finish 1.3.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并分支的时候可能遇到冲突，注意解决冲突方法(无则跳过)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看冲突的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理二进制文件</span></span><br><span class="line">git checkout --thires -- a.swf a.jpg   <span class="comment"># 使用release的二进制文件</span></span><br><span class="line">git checkout --ours   -- b.swf b.jpg   <span class="comment"># 使用本地的二进制文件</span></span><br><span class="line">git add c.swf c.jpg                    <span class="comment"># 同上，使用本地的二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再处理文本文件</span></span><br><span class="line">git mergetool -t vimdiff               <span class="comment"># 使用mergetool，也可手工编辑文件，然后git add</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再commit提交，注释参考：`Merge branch &#x27;release/x.x.x&#x27;`</span></span><br><span class="line"><span class="comment"># 在该操作中会提示输入Tag描述，比如`发布WebCC x.x.x版本`然后保存</span></span><br><span class="line"><span class="comment"># git flow会自动创建一个以版本号为名的Tag</span></span><br><span class="line"></span><br><span class="line">NOTE: 如果合并分支错误，且已Push到master，可以重新合并</span><br><span class="line">        git reflog                     <span class="comment"># 找回被删的release分支的版本号[sha1]</span></span><br><span class="line">        git checkout [sha1]            <span class="comment"># 将被删release checkout到本地</span></span><br><span class="line">        git checkout -b release/x.x.x  <span class="comment"># 将分支名改为release/x.x.x</span></span><br><span class="line">        git checkout master            <span class="comment"># 切回master分支</span></span><br><span class="line">        git rebase --hard [sha2]       <span class="comment"># 将master分支设置回错误合并前（如上一版本HEAD^）</span></span><br><span class="line">        git merge release/x.x.x        <span class="comment"># 重新合并release/x.x.x分支，合并成功后再提交</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除远程分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete release/x.x.x</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将合并后的本地master,develop,tag推送到服务器上</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master &amp;&amp; git push origin develop &amp;&amp; git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="紧急修复bug"><a href="#紧急修复bug" class="headerlink" title="紧急修复bug"></a>紧急修复bug</h4><ul>
<li><p>当线上遇到必须要紧急修复的BUG，不能推到下个版本修复时，可以在master基础上创建hotfix分支来修复BUG。BUG修复后，将修改内容合并回master和develop分支。</p>
</li>
<li><p>新发布版本号规则为：</p>
<ul>
<li>如果上一个版本没有第4位，则设置第4位为1</li>
<li>如果上一个版本含有第4位，则递增第4位</li>
</ul>
</li>
<li><p>clone代码，初始化git flow，该操作只做一次</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@projects.git</span><br><span class="line"><span class="built_in">cd</span> projects</span><br><span class="line">git checkout master  <span class="comment"># 由于默认分支改成了develop，需要先导入master分支</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新本地master分支到最新版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master &amp;&amp; git pull</span><br></pre></td></tr></table></figure>

<ul>
<li>创建基于本地master的hotfix分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分支（分支名尽量能提示修复什么bug）</span></span><br><span class="line">git flow hotfix start fix-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在projects查看当前版本号，按规则确定新版本号并修改(视项目以及团队定义的版本文件为准)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在CHANGELOG.txt添加该版本的BUG修复说明</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进行bug修复和提交（hostfix分支不能做新功能开发，只修bug）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status                     <span class="comment"># 查看有哪些文件修改</span></span><br><span class="line">git diff                       <span class="comment"># 查看具体修改内容</span></span><br><span class="line">git add xxx                    <span class="comment"># 添加准备提交的文件或文件夹</span></span><br><span class="line">git commit -m<span class="string">&quot;fix #xxx xxx&quot;</span>    <span class="comment"># 提交代码</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bug修复完成后，将hotfix分支合并到本地master和develop</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master &amp;&amp; git pull</span><br><span class="line">git checkout develop &amp;&amp; git pull</span><br><span class="line">git checkout hotfix/fix-xxx</span><br><span class="line">git flow hotfix finish fix-xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支的时候可能遇到冲突，注意解决冲突方法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看冲突的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理二进制文件</span></span><br><span class="line">git checkout --thires -- a.swf a.jpg   <span class="comment"># 使用release的二进制文件</span></span><br><span class="line">git checkout --ours   -- b.swf b.jpg   <span class="comment"># 使用本地的二进制文件</span></span><br><span class="line">git add c.swf c.jpg                    <span class="comment"># 同上，使用本地的二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再处理文本文件</span></span><br><span class="line">git mergetool -t vimdiff               <span class="comment"># 使用mergetool，也可手工编辑文件，然后git add</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再commit提交，注释参考：`Merge branch &#x27;hotfix/fix-xxx&#x27;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该操作中会提示输入Tag描述，比如`修复xxx问题`，然后保存退出（比如VI编辑器按Esc，再按:wq）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git flow会自动创建一个hotfix同名的Tag</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最后将合并后的本地master,develop,tag推送到服务器上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master &amp;&amp; git push origin develop &amp;&amp; git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="git使用分支进行开发"><a href="#git使用分支进行开发" class="headerlink" title="git使用分支进行开发"></a>git使用分支进行开发</h4><ul>
<li>当要做的功能不是一两行代码就可以完成的时候，需要在本地创建基于develop的feature分支</li>
<li>如果是多人合作，可以将分支publish到服务器上</li>
<li>分支完成并自己测试通过后才合并到develop，再由QA在develop上进行测试和修复bug</li>
</ul>
<blockquote>
<p>clone代码，初始化git flow，该操作只做一次</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@projects.git</span><br><span class="line"><span class="built_in">cd</span> projects</span><br><span class="line">git checkout master  <span class="comment"># webcc默认分支为develop，首次clone需先导入master分支</span></span><br><span class="line">git flow init -d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更新本地develop分支到最新版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout develop &amp;&amp; git pull</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建基于本地develop的feature分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git flow feature start feature-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是多人合作开发某个功能</span></span><br><span class="line"><span class="comment"># 可以将该分支推送到服务器上</span></span><br><span class="line">git flow feature publish feature-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后通知其他人可以使用track签出该分支</span></span><br><span class="line">git flow feature track feature-xxx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行代码修改和提交</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase               <span class="comment"># 如果合作开发，定期拉取别人提交的代码</span></span><br><span class="line">                                <span class="comment"># 如果pull出现冲突，则解决冲突后git add xxx</span></span><br><span class="line">                                <span class="comment"># 然后git rebase --continue继续操作。</span></span><br><span class="line"></span><br><span class="line">git status                      <span class="comment"># 查看有哪些文件修改</span></span><br><span class="line">git diff                        <span class="comment"># 查看具体修改内容</span></span><br><span class="line">git add xxx                     <span class="comment"># 添加准备提交的文件或文件夹</span></span><br><span class="line">git commit -m<span class="string">&quot;close #xxx xxx&quot;</span>   <span class="comment"># 提交代码</span></span><br><span class="line"></span><br><span class="line">git push                        <span class="comment"># 如果合作开发，定期将自己的代码推到服务器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>功能开发完成且自己测试OK后</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于该feature分支测试，所有发现的问题列出一个列表并收集起来</span></span><br><span class="line"><span class="comment"># 测试完成且确定放该功能后将feature分支合并到develop</span></span><br><span class="line">git checkout develop &amp;&amp; git pull              <span class="comment"># 拉取最新的develop</span></span><br><span class="line">git checkout feature/feature-xxx &amp;&amp; git pull  <span class="comment"># 如果合作开发，则先拉取服务器上的最新代码</span></span><br><span class="line">git flow feature finish feature-xxx           <span class="comment"># 完成分支开发，合并代码到本地develop</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并分支的时候可能遇到冲突，注意解决冲突方法</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看冲突的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理二进制文件</span></span><br><span class="line">git checkout --thires -- a.swf a.jpg   <span class="comment"># 使用release的二进制文件</span></span><br><span class="line">git checkout --ours   -- b.swf b.jpg   <span class="comment"># 使用本地的二进制文件</span></span><br><span class="line">git add c.swf c.jpg                    <span class="comment"># 同上，使用本地的二进制文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再处理文本文件</span></span><br><span class="line">git mergetool -t vimdiff               <span class="comment"># 使用mergetool，也可手工编辑文件，然后git add</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再commit提交，注释参考：`Merge branch &#x27;feature/x.x.x&#x27;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该操作中会提示输入Tag描述，比如`发布WebCC x.x.x版本`然后保存（比如VI编辑器按Esc，再按:wq）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git flow会自动创建一个以版本号为名的Tag。</span></span><br><span class="line"><span class="comment"># 然后在CHANGELOG.txt顶部in development段添加功能说明，并提交修改：</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后将合并后的本地develop推送到服务器上</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果合作开发，在新功能发布到线上后再删除远程分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete feature/x.x.x</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git打标签</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag version     # git打标签版本</span><br><span class="line">git push --tags     # git打标签推到服务器上</span><br><span class="line">git tag             # 查看标签</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>git需求管理规范</title>
    <url>/2020/08/05/git_released/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="需求管理与git流程控制"><a href="#需求管理与git流程控制" class="headerlink" title="需求管理与git流程控制"></a>需求管理与git流程控制</h4><h5 id="迭代周期与git版本管理"><a href="#迭代周期与git版本管理" class="headerlink" title="迭代周期与git版本管理"></a>迭代周期与git版本管理</h5><p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/tools/git/git_timeline.jpg"></p>
<h5 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h5><blockquote>
<p>需求开发流程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/tools/git/git_flow.jpg"></p>
<blockquote>
<p>线上紧急修复bug流程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaokunliu/xiaokunliu.github.io/feature/writing/websites/zimages/tools/git/git_flow_hotfix.jpg"></p>
<h5 id="版本号管理"><a href="#版本号管理" class="headerlink" title="版本号管理"></a>版本号管理</h5><p>打包发版是基于release分支,因此进行版本管理是在release分支进行的,对此关于项目版本号的简要说明如下:</p>
<p>当代码在feature开发测试完成并merge回develop后，在发版本前一天打一个基于develop的 release分支。在该分支上进行测试和修复bug，不开发新功能。</p>
<p>新发布版本号规则为：</p>
<ul>
<li>如果是重大功能变更，则递增第1位，第2、3位归0。（如整体换UI、改用新技术）</li>
<li>如果是添加大功能（工作量按周计算），则递增第2位，第1位不变，第3位归0。（如新增贵族功能）</li>
<li>如果是添加小功能（工作量不满一周），则递增第3位，第1、2位不变。（如添加某某接口）</li>
</ul>
<p>当线上遇到必须要紧急修复的BUG，不能推到下个版本修复时，可以在master基础 上创建hotfix分支来修复BUG。BUG修复后，将修改内容合并回master和develop分支。</p>
<p>新发布版本号规则为：</p>
<ul>
<li>如果上一个版本没有第4位，则设置第4位为1</li>
<li>如果上一个版本含有第4位，则递增第4位</li>
</ul>
<h4 id="gitflow简介"><a href="#gitflow简介" class="headerlink" title="gitflow简介"></a>gitflow简介</h4><h5 id="gitflow进行需求开发"><a href="#gitflow进行需求开发" class="headerlink" title="gitflow进行需求开发"></a>gitflow进行需求开发</h5><p>上述的流程规范可以使用gitflow工具来提升基于git开发流程,具体实践如下:</p>
<ul>
<li>首先是项目的前期准备工作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 这里我直接在gitee上创建一个新项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/xiaokunliu/tpp.git &amp;&amp; <span class="built_in">cd</span> tpp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 基于master新建一个develop分支</span></span><br><span class="line">git pull origin master &amp;&amp; git branch develop &amp;&amp; git brnach -a</span><br><span class="line"></span><br><span class="line"><span class="comment">## 切换到develop分支</span></span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line"><span class="comment">## 推送develop到远程服务器</span></span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看分支</span></span><br><span class="line">git branch -a | grep develop</span><br></pre></td></tr></table></figure>

<ul>
<li>其次,是需要开发一个新的需求功能,基于develop分支新建一个feature分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 将远程仓库拉取下来</span></span><br><span class="line"><span class="comment">## 如果当前分支未提交或者是存在冲突先进行提交或者是冲突的问题解决</span></span><br><span class="line">git pull origin master &amp;&amp; git pull origin develop</span><br><span class="line"></span><br><span class="line"><span class="comment">## 第一次使用gitflow</span></span><br><span class="line">git flow init -d</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更新develop分支</span></span><br><span class="line">git checkout develop &amp;&amp; git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">## 基于最新的develop分支新建一个feature分支,比如开发支付模块</span></span><br><span class="line">git flow feature start feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果是多人合作的时候,需要将本地的feature分支推送到远程服务器进行功能测试</span></span><br><span class="line"><span class="comment">## 发布feature分支并推送到远程服务器</span></span><br><span class="line">git flow feature publish feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 通知处理相同需求的同事将feature分支检出</span></span><br><span class="line">git flow feature track feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果中间feature分支存在bug,那么需要将feature拉取下来进行bug修复</span></span><br><span class="line">git pull origin master &amp;&amp; git pull origin develop &amp;&amp; git pull origin feature-payment &amp;&amp; git checkout feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进行bug修复并提交</span></span><br><span class="line">git add ..</span><br><span class="line">git commit -m <span class="string">&quot;&quot;</span></span><br><span class="line">git push origin feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开发并且QA测试完成之后需要将feature分支合并到develop分支进行回归测试</span></span><br><span class="line">git flow feature finish feature-payment</span><br></pre></td></tr></table></figure>

<ul>
<li>然后,feature分支已经完成开发,需要进行发版</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 首先登录测试服务器,将代码拉取下来</span></span><br><span class="line">git pull origin master &amp;&amp; git pull origin develop &amp;&amp; git checkout develop</span><br><span class="line"></span><br><span class="line"><span class="comment">## 其次基于develop分支进行打包发版,需要打一个release分支</span></span><br><span class="line"><span class="comment">## 比如现在的版本号为1.1.0,在项目中增加一个配置文件CHANGLOG.txt用于记录版本号以及对应的版本号修改的时间</span></span><br><span class="line">version=<span class="string">&#x27;1.1.0&#x27;</span></span><br><span class="line">version_date=<span class="string">&quot;2020-08-01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 此时的版本为1.2.0,假设现在是周期版本的需求迭代</span></span><br><span class="line">git flow release start 1.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后更新上述配置文件的版本号以及时间</span></span><br><span class="line">version=<span class="string">&#x27;1.2.0&#x27;</span></span><br><span class="line">version_date=<span class="string">&quot;2020-08-06&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后提交CHANGLOG.txt</span></span><br><span class="line">git add CHANGLOG.txt</span><br><span class="line">git commit -m <span class="string">&quot;change version and version date&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将release版本进行发布到测试环境进行回归测试</span></span><br><span class="line">git flow release publish 1.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果回归测试有问题,需要通知对应需求的功能的同事进行修复</span></span><br><span class="line"><span class="comment">## 将项目检出</span></span><br><span class="line">git flow release track 1.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进行bug修复然后提交,release分支只用于bug修复,不做新的需求功能开发,如果有新的需求功能</span></span><br><span class="line"><span class="comment">## 不紧急的话走周期版本,紧急需求功能将feature分支合并到release分支,注意此时所处的时间点是回归测试阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 完成bug修复之后,准备打包到稳定的master版本</span></span><br><span class="line">git checkout master &amp;&amp; git pull &amp;&amp; git checkout develop &amp;&amp; git checkout release/1.2.0 &amp;&amp; git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">## 打包并合并到当前测试服务器的develop以及master</span></span><br><span class="line">git flow release finish 1.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果有冲突再解决冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 最后将develop以及master推送到远程</span></span><br><span class="line">git push origin master &amp;&amp; git push origin develop &amp;&amp; git push --tags</span><br></pre></td></tr></table></figure>

<ul>
<li>最后,将master版本推送到预发布线上preview环境,线上preveiw环境ok之后再走生产环境,实现逐个单节点发布.</li>
</ul>
<h5 id="gitflow进行紧急修复bug"><a href="#gitflow进行紧急修复bug" class="headerlink" title="gitflow进行紧急修复bug"></a>gitflow进行紧急修复bug</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 紧急bug修复需要基于master分支</span></span><br><span class="line">git checkout master &amp;&amp; git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启一个hotfix的分支</span></span><br><span class="line">git flow hotfix start fix-payment-notoreders</span><br><span class="line"></span><br><span class="line"><span class="comment">## 本地进行bug修复之后,需要进行bug测试回归,需要发布hotfix分支到测试环境上</span></span><br><span class="line">git flow hotfix publish fix-payment-notoreders</span><br><span class="line"><span class="comment">## 登录测试服</span></span><br><span class="line">git checkout master &amp;&amp; git pull &amp;&amp; git checkout develop &amp;&amp; git pull &amp;&amp; git checkout fix-payment-notoreders</span><br><span class="line"><span class="comment">## 进行测试如果没有问题,那么就将hotfix的分支进行打包</span></span><br><span class="line">git flow hotfix finish fix-payment-notoreders</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更新到master以及develop分支上</span></span><br><span class="line">git push origin master &amp;&amp; git push origin develop &amp;&amp; git push --tags</span><br><span class="line"></span><br><span class="line"><span class="comment">## 最后将代码发布到线上即可</span></span><br></pre></td></tr></table></figure>

<h5 id="上线之后删除功能分支以及release分支"><a href="#上线之后删除功能分支以及release分支" class="headerlink" title="上线之后删除功能分支以及release分支"></a>上线之后删除功能分支以及release分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除本地分支</span></span><br><span class="line">git branch -D feature/feature-payment</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除远程分支</span></span><br><span class="line">git push origin :feature/feature-payment</span><br></pre></td></tr></table></figure>

<h4 id="git与gitflow学习资料参考"><a href="#git与gitflow学习资料参考" class="headerlink" title="git与gitflow学习资料参考"></a>git与gitflow学习资料参考</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## github上学习资源: </span><br><span class="line">https://github.com/geeeeeeeeek/git-recipes/wiki</span><br><span class="line"></span><br><span class="line">## gitflow参考资料:</span><br><span class="line">https://datasift.github.io/gitflow/IntroducingGitFlow.html</span><br><span class="line">https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2019/04/02/git_used/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="版本表示法"><a href="#版本表示法" class="headerlink" title="版本表示法"></a>版本表示法</h4><blockquote>
<p>显示git分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-parse --symbolic --branches</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git显示里程碑</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-parse --symbolic --tags</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示定义的所有引用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-parse --symbolic --glob=refs/*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示HEAD对应的SHA的哈希值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-parse HEAD</span><br></pre></td></tr></table></figure>

<h4 id="git使用资料"><a href="#git使用资料" class="headerlink" title="git使用资料"></a>git使用资料</h4><blockquote>
<p>git使用分支的场景</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://stormzhang.com/git/2014/01/29/git-flow/</span><br><span class="line">http://nvie.com/posts/a-successful-git-branching-model/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git使用参考</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/geeeeeeeeek/git-recipes/wiki</span><br><span class="line">https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>git删除远程分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般先查看远程分支是否存在</span></span><br><span class="line">git branch -a | grep remote_branch_name</span><br><span class="line">git push origin :remote_branch_name</span><br><span class="line">git branch -a | grep remote_branch_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除本地分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D branchname</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git创建本地分支并推送到远程新建一个分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch local_branch_name</span><br><span class="line">git checkout local_branch_name</span><br><span class="line">git add files</span><br><span class="line">git commit -m <span class="string">&quot;working context for local branch name&quot;</span></span><br><span class="line">git push origin local_branch_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git切换到远程分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch remotes/origin/xxx</span><br><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git设置不自动转换项目工程所在平台的换行符</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span>  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>git设置项目自动记住账户密码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git将更新的文件回退(本地)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 获取当前最新分支的hash值</span></span><br><span class="line">git checkout commit_id -- file      <span class="comment"># 回退本地file文件的修改</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git-merge合并操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 背景：当前的工作需要引入线上最新代码,则合并线上分支代码到当前分支下</span></span><br><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">git merge master feature</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git-rebase合并操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 背景:会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交</span></span><br><span class="line"><span class="comment"># 将feature并入master分支</span></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交互式rebase操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 背景：被用于将 feature 分支并入 master 分支之前，清理混乱的历史</span></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Rebase 的黄金法则</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git rebase 的黄金法则便是，绝不要在公共的分支上使用它(不要在develop分支上使用rebase)</span></span><br><span class="line"><span class="comment"># 你运行 git rebase 之前，一定要问问你自己[有没有别人正在这个分支上工作]</span></span><br><span class="line"><span class="comment"># 将master分支移动到feature分支后面</span></span><br><span class="line">git checkout master</span><br><span class="line">git rebase feature  <span class="comment"># 确保master分支上没有人在进行工作</span></span><br><span class="line"></span><br><span class="line">git push --force  <span class="comment">## 如果没有使用--force，git会停止push</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git-reset操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reset 将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交</span></span><br><span class="line"><span class="comment"># 比如在一个热修复的分支提交了两次不必要的操作,想要撤回（仅限本地未提交到远程）,下次 Git 执行垃圾回收的时候，这两个提交会被删除</span></span><br><span class="line">git checkout hotfix</span><br><span class="line">git reset HEAD~2</span><br><span class="line"></span><br><span class="line">--soft – 缓存区和工作目录都不会被改变</span><br><span class="line">--mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</span><br><span class="line">--hard – 缓存区和工作目录都同步到你指定的提交</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git-checkout操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入分支名时，可以切换到那个分支</span></span><br><span class="line">git checkout branchname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以传入提交的引用来 checkout 到任意的提交</span></span><br><span class="line">git checkout HEAD~2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git-revert操作(Revert 撤销一个提交的同时会创建一个新的提交)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中</span></span><br><span class="line">git checkout hotfix</span><br><span class="line">git revert HEAD~2</span><br><span class="line"></span><br><span class="line"><span class="comment"># git revert 可以用在公共分支上，git reset 应该用在私有分支上</span></span><br><span class="line"><span class="comment"># git revert 当作撤销已经提交的更改，而 git reset HEAD 用来撤销没有提交的更改</span></span><br></pre></td></tr></table></figure>


<h4 id="git使用日志查看提交历史"><a href="#git使用日志查看提交历史" class="headerlink" title="git使用日志查看提交历史"></a>git使用日志查看提交历史</h4><blockquote>
<p>显示limit个提交</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n &lt;<span class="built_in">limit</span>&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<blockquote>
<p>哪些文件被更改了，以及每个文件相对的增删行数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示每个提交全部的差异</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p</span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索特定作者的提交,<pattern> 可以是字符串或正则表达式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;&lt;pattern&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索提交信息匹配特定 <pattern> 的提交。<pattern> 可以是字符串或正则表达式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=<span class="string">&quot;&lt;pattern&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示在 some-feature 分支而不在 master 分支的所有提交的概览</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline master..some-feature</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git切换为远程分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout -t origin/remote_branch_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git 本地回滚</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout filename</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git冲突</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 内容冲突</span><br><span class="line">1. 相同文件相同区块下的内容存在差异则会出现冲突说明</span><br><span class="line">2. 相同文件相同的区块无差异，相同文件不同区块存在增删代码，则会合并</span><br><span class="line"></span><br><span class="line"># 树冲突</span><br><span class="line">1. git提交的文件信息重命名或删除</span><br><span class="line"></span><br><span class="line"># 逻辑冲突</span><br><span class="line">git项目代码引入的文件名称被修改过</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>linux(macbook)实际工作笔录</title>
    <url>/2020/04/02/macbook/</url>
    <content><![CDATA[<span id="more"></span>


<blockquote>
<p> 批量拷贝某一个目录下的所有指定的文件到另一个指定的目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 比如拷贝视频文件,针对目录下存在空格命名情况,会导致无法处理成功,需要临时使用系统变量的IFS</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">old_IFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=$(<span class="built_in">echo</span> -en <span class="string">&quot;\n\b&quot;</span>)</span><br><span class="line">find . -name <span class="string">&quot;*.mp4&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> filepath </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;move file to 100036 dir: <span class="variable">$filepath</span> &quot;</span></span><br><span class="line">	mv -f <span class="variable">$filepath</span> ./100036</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 恢复系统原理的设置</span></span><br><span class="line">IFS=<span class="variable">$old_IFS</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于云端的API服务进行批量处理</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 比如github上批量删除无效仓库项目</span></span><br><span class="line"><span class="comment"># 在本地新建一个文件repos,逐行贴上对应的一个仓库名称: githubName/repoName,如:</span></span><br><span class="line">xiaokunliu/delRepo1</span><br><span class="line">xiaokunliu/delRepo2</span><br><span class="line">...</span><br><span class="line"><span class="comment"># github上申请对应开发者账户的删除权限token</span></span><br><span class="line"><span class="comment">### 编写脚本完成</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">cat repos | <span class="keyword">while</span> <span class="built_in">read</span> repo</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;delete github for repo: https://api.github.com/repos/<span class="variable">$repo</span>&quot;</span></span><br><span class="line">    curl -XDELETE  -H <span class="string">&#x27;Authorization: token token&#x27;</span> <span class="string">&quot;https://api.github.com/repos/<span class="variable">$repo</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>正则常用参考</title>
    <url>/2020/02/07/regex/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="正则表达式（20个强大的正则表达式）"><a href="#正则表达式（20个强大的正则表达式）" class="headerlink" title="正则表达式（20个强大的正则表达式）"></a>正则表达式（20个强大的正则表达式）</h5><blockquote>
<p>正则测试网站</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在线正则表达式：https://regex101.com/#pcre</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验密码强度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间</span><br><span class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验中文</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串仅能是中文。</span><br><span class="line">^[\\u4e00-\\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由数字、26个英文字母或下划线组成的字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^\\w+$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验E-Mail 地址 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同密码一样，下面是E-mail地址合规性的正则检查语句。</span><br><span class="line">[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验身份证号码 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面是身份证号码的正则校验。15 或 18位。</span><br><span class="line">15位：</span><br><span class="line">^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$</span><br><span class="line">18位：</span><br><span class="line">^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验日期 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</span><br><span class="line">^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验金额 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">金额校验，精确到2位小数。</span><br><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验手机号 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面是国内 13、15、18开头的手机号正则表达式。</span><br><span class="line">^(13[0-9]|14(5|7)+|15[0-3|5-9]+|18[0-3|5-9]+)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断IE的版本 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</span><br><span class="line">^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验IP-v4地址 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP4 正则语句</span><br><span class="line">\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验IP-v6地址 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP6 正则语句</span><br><span class="line">(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查URL的前缀 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</span><br><span class="line">if (!s.match(/^[a-zA-Z]+:\\/\\//))</span><br><span class="line">&#123;</span><br><span class="line">    s = &#x27;http://&#x27; + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提取URL链接 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面的这个表达式可以筛选出一段文本中的URL。</span><br><span class="line">^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件路径及扩展名校验 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证文件路径和扩展名</span><br><span class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提取Color Hex Codes </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时需要抽取网页中的颜色代码，可以使用下面的表达式。</span><br><span class="line">\\#([a-fA-F]|[0-9])&#123;3,6&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提取网页图片 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假若你想提取网页中所有图片信息，可以利用下面的表达式。</span><br><span class="line">\\&lt; *[img][^\\&gt;]*[src] *= *[\\&quot;\\&#x27;]&#123;0,1&#125;([^\\&quot;\\&#x27;\\ &gt;]*)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提取页面超链接 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提取html中的超链接。</span><br><span class="line">(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?://)((?!(?:(?:www\\.)?&#x27;.implode(&#x27;|(?:www\\.)?&#x27;, $follow_list).&#x27;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>精炼CSS </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过下面的表达式，可以搜索相同属性值的CSS，从而达到精炼代码的目的</span><br><span class="line">^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽取注释 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你需要移除HMTL中的注释，可以使用如下的表达式。</span><br><span class="line">&lt;!--(.*?)--&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>匹配HTML标签</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过下面的表达式可以匹配出HTML中的标签。</span><br><span class="line">&lt;/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#x27;.*?&#x27;|[\\^&#x27;&quot;&gt;\\s]+))?)+\\s*|\\s*)/?&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>匹配是否为一个url链接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN命令小结</title>
    <url>/2019/04/02/svn/</url>
    <content><![CDATA[<span id="more"></span>


<blockquote>
<p>将文件checkout到本地目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn checkout path（path是服务器上的目录）</span><br><span class="line">简写：svn co</span><br></pre></td></tr></table></figure>

<blockquote>
<p>往版本库中添加新的文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn add file</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将改动的文件提交到版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn commit -m “LogMessage” [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)</span><br><span class="line">简写：svn ci</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加锁/解锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn lock -m “LockMessage” [--force] PATH</span><br><span class="line">svn unlock PATH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更新到某个版本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn update -r m path</span><br><span class="line">简写：svn up</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看文件或者目录状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）svn status path（目录下的文件和子目录的状态，正常状态不显示）</span><br><span class="line">2）svn status -v path(显示文件和子目录状态)</span><br><span class="line">简写：svn st</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn delete path -m “delete test fle”</span><br><span class="line">简写：svn (del, remove, rm)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看日志</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn log path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看文件详细信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn info path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比较差异</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn diff path(将修改的文件与基础版本比较)</span><br><span class="line">svn diff -r m:n path(对版本m和版本n比较差异)</span><br><span class="line">简写：svn di</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将两个版本之间的差异合并到当前文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn merge -r m:n path</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SVN 帮助</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn help</span><br><span class="line">svn help ci</span><br></pre></td></tr></table></figure>

<h4 id="SVN不常用命令"><a href="#SVN不常用命令" class="headerlink" title="SVN不常用命令"></a>SVN不常用命令</h4><blockquote>
<p>版本库下的文件和目录列表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn list path    显示path目录下的所有属于版本库的文件和目录</span><br><span class="line">简写：svn ls</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建纳入版本控制下的新目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn mkdir: 创建纳入版本控制下的新目录</span><br><span class="line"></span><br><span class="line">用法: </span><br><span class="line">1、mkdir PATH...</span><br><span class="line">每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。</span><br><span class="line">2、mkdir URL... 创建版本控制的目录。 </span><br><span class="line">每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复本地修改</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。</span><br><span class="line">用法: revert PATH... 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码库URL变更</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn switch (sw): 更新工作副本至不同的URL</span><br><span class="line">用法: </span><br><span class="line">1、switch URL [PATH]        </span><br><span class="line">更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将      服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。 </span><br><span class="line">2、switch --relocate FROM TO [PATH...]   </span><br><span class="line">改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动     (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用     这个命令更新工作副本与仓库的对应关系。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决冲突</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn resolved: 移除工作副本的目录或文件的“冲突”状态。</span><br><span class="line">用法: resolved PATH... 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出指定文件或URL的内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn cat 目标[@版本]...如果指定了版本，将从指定的版本开始查找。 </span><br><span class="line">svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的）</span><br></pre></td></tr></table></figure>

<h4 id="SVN其它命令"><a href="#SVN其它命令" class="headerlink" title="SVN其它命令"></a>SVN其它命令</h4><blockquote>
<p>svn cleanup</p>
</blockquote>
<p>当Subversion修改你的工作副本时（或者任何在.svn中的信息），它尝试尽可能做到安全。在改变一个工作副本前，Subversion把它的意 图写到一个日志文件中。接下来它执行日志文件中的命令来应用要求的修改。最后，Subversion删除日志文件。从架构上来说，这与一个日志文件系统 （journaled filesystem）类似。如果一个 Subversion操作被打断（例如，进程被杀掉了，或机器当掉了）了，日志文件仍在硬盘上。重新执行日志文件，Subversion可以完成先前开始 的操作，这样你的工作副本能回到一个可靠的状态。<br>以下是svn cleanup所做的：它搜索你的工作副本并执行所有遗留的日志，在这过程中删除锁。如果Subversion曾告诉你你的工作副本的一部分被“锁定”了，那么你应该执行这个命令。另外， svn status会在锁定的项前显示L。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ svn status</span><br><span class="line">L    somedir</span><br><span class="line">M   somedir/foo.c </span><br><span class="line"></span><br><span class="line">$ svn cleanup</span><br><span class="line">$ svn status</span><br><span class="line">M      somedir/foo.c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>svn import</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用svn import是把未版本化的文件树复制到资料库的快速办法，它需要创建一个临时目录。 </span><br><span class="line">$ svnadmin create /usr/local/svn/newrepos</span><br><span class="line">$ svn import mytree file:///usr/local/svn/newrepos/some/project</span><br><span class="line">Adding         mytree/foo.c</span><br><span class="line">Adding         mytree/bar.c</span><br><span class="line">Adding         mytree/subdir</span><br><span class="line">Adding         mytree/subdir/quux.h</span><br><span class="line"></span><br><span class="line">Committed revision 1.</span><br><span class="line"></span><br><span class="line"># 上面的例子把在some/project目录下mytree目录的内容复制到资料库中。 </span><br><span class="line"></span><br><span class="line">$ svn list file:///usr/local/svn/newrepos/some/project</span><br><span class="line">bar.c</span><br><span class="line">foo.c</span><br><span class="line">subdir/</span><br></pre></td></tr></table></figure>

<p>注意在导入完成后，原来的树没有被转化成一个工作副本。为了开始工作，你仍然需要svn checkout这个树的一个新的工作副本</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
